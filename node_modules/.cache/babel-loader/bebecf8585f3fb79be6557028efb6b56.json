{"ast":null,"code":"import _slicedToArray from \"C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _asyncToGenerator from \"C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _defineProperty from \"C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _regeneratorRuntime from \"C:\\\\Users\\\\PC\\\\Documents\\\\PROGRAMMING\\\\MERN\\\\frontend\\\\node_modules\\\\@babel\\\\runtime\\\\regenerator\\\\index.js\";\n\n/**\n * Applies a function to the value at the given index of an array\n *\n * @param index\n * @param fn\n * @param collection\n * @returns Copy of the array with the element at the given index replaced with the result of the function application.\n */\nvar adjust = function adjust(index, fn, collection) {\n  if (index >= 0 && index >= collection.length) return collection;\n  if (index < 0 && Math.abs(index) > collection.length) return collection;\n  var i = index < 0 ? collection.length + index : index;\n  return Object.assign([], collection, _defineProperty({}, i, fn(collection[i])));\n};\n/* eslint-disable no-await-in-loop */\n\n/**\n * Performs right-to-left function composition with async functions support\n *\n * @param fns - Functions\n * @returns Composed function\n */\n\n\nvar asyncCompose = function asyncCompose() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(value) {\n      var result,\n          reversedFns,\n          _len2,\n          args,\n          _key2,\n          i,\n          fn,\n          _args = arguments;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              result = value;\n              reversedFns = fns.slice().reverse();\n\n              for (_len2 = _args.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n                args[_key2 - 1] = _args[_key2];\n              }\n\n              i = 0;\n\n            case 4:\n              if (!(i < reversedFns.length)) {\n                _context.next = 12;\n                break;\n              }\n\n              fn = reversedFns[i];\n              _context.next = 8;\n              return fn.apply(void 0, [result].concat(args));\n\n            case 8:\n              result = _context.sent;\n\n            case 9:\n              i += 1;\n              _context.next = 4;\n              break;\n\n            case 12:\n              return _context.abrupt(\"return\", result);\n\n            case 13:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n};\n/**\n * Capitalize first letter of each word\n *\n * @param value - Any string\n * @returns Capitalized string\n */\n\n\nvar capitalize = function capitalize(value) {\n  if (!value) return value;\n  return value.replace(/(^|\\s)\\S/g, function (l) {\n    return l.toUpperCase();\n  });\n};\n/**\n * Casts value to array\n *\n * @template T - The type of the value.\n * @param value - The value to cast into an array.\n * @returns An array containing the given value.\n */\n\n\nvar castArray = function castArray(value) {\n  return Array.isArray(value) ? value : [value];\n};\n/**\n * Performs right-to-left function composition\n *\n * @param fns - Functions\n * @returns Composed function\n */\n\n\nvar compose = function compose() {\n  for (var _len3 = arguments.length, fns = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    fns[_key3] = arguments[_key3];\n  }\n\n  return function (value) {\n    var result = value;\n    var reversedFns = fns.slice().reverse();\n\n    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      args[_key4 - 1] = arguments[_key4];\n    }\n\n    for (var i = 0; i < reversedFns.length; i += 1) {\n      var fn = reversedFns[i];\n      result = fn.apply(void 0, [result].concat(args));\n    }\n\n    return result;\n  };\n};\n/**\n * Drops the last element from an array.\n *\n * @template T\n * @param  array - The array to drop the last element from\n * @returns - The new array with the last element dropped\n */\n\n\nvar dropLast = function dropLast(array) {\n  return array.slice(0, array.length - 1);\n};\n/**\n * Applies a set of transformations to an object and returns a new object with the transformed values.\n *\n * @template T\n * @param transformations - The transformations to apply.\n * @param object - The object to transform.\n * @returns The transformed object.\n */\n\n\nfunction evolve(transformations, object) {\n  var result = {};\n  var keys = Object.keys(object);\n\n  for (var i = 0; i < keys.length; i += 1) {\n    var key = keys[i];\n    var transformation = transformations[key];\n\n    if (typeof transformation === 'function') {\n      result[key] = transformation(object[key]);\n    } else {\n      result[key] = object[key];\n    }\n  }\n\n  return result;\n}\n/**\n * Checks if a value is null or undefined.\n *\n * @template T - The type of the value.\n * @param value - The value to check\n * @returns True if the value is null or undefined, false otherwise\n */\n\n\nvar isNil = function isNil(value) {\n  return value === null || value === undefined;\n};\n/**\n * Retrieves the value at a given path from an object.\n *\n * @param target - The object to retrieve the value from.\n * @param path - The path of the value to retrieve.\n * @param defaultValue - The default value to return if the path does not exist.\n * @returns The value at the given path, or the default value if the path does not exist.\n */\n\n\nvar get = function get(target, path, defaultValue) {\n  if (isNil(target)) return defaultValue;\n\n  var _path = castArray(path);\n\n  var result = target;\n\n  for (var i = 0; i < _path.length; i += 1) {\n    if (isNil(result)) return undefined;\n    result = result[_path[i]];\n  }\n\n  return isNil(result) ? defaultValue : result;\n};\n\nfunction last(value) {\n  return value === '' ? '' : value[value.length - 1];\n}\n/**\n * Maps over the values of an object and applies a function to each value.\n *\n * @param object - The object to map over\n * @param fn - The function to apply to each value\n * @returns A new object with the mapped values\n */\n\n\nvar mapValues = function mapValues(object, fn) {\n  var entries = Object.entries(object);\n  var acc = {};\n  return entries.reduce(function (acc, _ref2, index) {\n    var _ref3 = _slicedToArray(_ref2, 2),\n        key = _ref3[0],\n        value = _ref3[1];\n\n    acc[key] = fn(value, key, index);\n    return acc;\n  }, acc);\n};\n\nvar isPercent = function isPercent(value) {\n  return /((-)?\\d+\\.?\\d*)%/g.exec(\"\".concat(value));\n};\n/**\n * Get percentage value of input\n *\n * @param value\n * @returns Percent value (if matches)\n */\n\n\nvar matchPercent = function matchPercent(value) {\n  var match = isPercent(value);\n\n  if (match) {\n    var f = parseFloat(match[1]);\n    var percent = f / 100;\n    return {\n      percent: percent,\n      value: f\n    };\n  }\n\n  return null;\n};\n/**\n * Creates a new object by omitting specified keys from the original object.\n *\n * @param keys - The key or keys to omit\n * @param object - The original object\n * @returns The new object without the omitted keys\n */\n\n\nvar omit = function omit(keys, object) {\n  var _keys = castArray(keys);\n\n  var copy = Object.assign({}, object);\n\n  _keys.forEach(function (key) {\n    delete copy[key];\n  });\n\n  return copy;\n};\n/**\n * Picks the specified keys from an object and returns a new object with only those keys.\n *\n * @param keys - The keys to pick from the object\n * @param object - The object to pick the keys from\n * @returns A new object with only the picked keys\n */\n\n\nvar pick = function pick(keys, obj) {\n  var result = {};\n\n  for (var i = 0; i < keys.length; i += 1) {\n    var key = keys[i];\n    if (key in obj) result[key] = obj[key];\n  }\n\n  return result;\n};\n/**\n * Repeats an element a specified number of times.\n *\n * @template T\n * @param element - Element to be repeated\n * @param length - Number of times to repeat element\n * @returns Repeated elements\n */\n\n\nvar repeat = function repeat(element) {\n  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var result = new Array(length);\n\n  for (var i = 0; i < length; i += 1) {\n    result[i] = element;\n  }\n\n  return result;\n};\n/**\n * Reverses the list\n *\n * @template T\n * @param list - List to be reversed\n * @returns Reversed list\n */\n\n\nvar reverse = function reverse(list) {\n  return Array.prototype.slice.call(list, 0).reverse();\n};\n/**\n * Capitalize first letter of string\n *\n * @param value - String\n * @returns Capitalized string\n */\n\n\nvar upperFirst = function upperFirst(value) {\n  if (!value) return value;\n  return value.charAt(0).toUpperCase() + value.slice(1);\n};\n/**\n * Returns a new array with all the values from the original array that are not present in the keys array.\n *\n * @param keys - The keys to pick from the object\n * @param array - Array to filter the values from\n * @returns A new array with without the omitted values\n */\n\n\nvar without = function without(keys, array) {\n  var result = [];\n\n  for (var i = 0; i < array.length; i += 1) {\n    var value = array[i];\n    if (!keys.includes(value)) result.push(value);\n  }\n\n  return result;\n};\n/**\n * Parse a string or number to a float\n *\n * @param value - String or number\n * @returns Parsed float\n */\n\n\nvar parseFloat$1 = function parseFloat$1(value) {\n  return typeof value === 'string' ? Number.parseFloat(value) : value;\n};\n\nexport { adjust, asyncCompose, capitalize, castArray, compose, dropLast, evolve, get, isNil, last, mapValues, matchPercent, omit, parseFloat$1 as parseFloat, pick, repeat, reverse, upperFirst, without };","map":{"version":3,"sources":["C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/@react-pdf/fns/lib/index.js"],"names":["adjust","index","fn","collection","length","Math","abs","i","Object","assign","asyncCompose","fns","value","result","reversedFns","slice","reverse","args","capitalize","replace","l","toUpperCase","castArray","Array","isArray","compose","dropLast","array","evolve","transformations","object","keys","key","transformation","isNil","undefined","get","target","path","defaultValue","_path","last","mapValues","entries","acc","reduce","isPercent","exec","matchPercent","match","f","parseFloat","percent","omit","_keys","copy","forEach","pick","obj","repeat","element","list","prototype","call","upperFirst","charAt","without","includes","push","parseFloat$1","Number"],"mappings":"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","sourcesContent":["/**\n * Applies a function to the value at the given index of an array\n *\n * @param index\n * @param fn\n * @param collection\n * @returns Copy of the array with the element at the given index replaced with the result of the function application.\n */\nconst adjust = (index, fn, collection) => {\n    if (index >= 0 && index >= collection.length)\n        return collection;\n    if (index < 0 && Math.abs(index) > collection.length)\n        return collection;\n    const i = index < 0 ? collection.length + index : index;\n    return Object.assign([], collection, { [i]: fn(collection[i]) });\n};\n\n/* eslint-disable no-await-in-loop */\n/**\n * Performs right-to-left function composition with async functions support\n *\n * @param fns - Functions\n * @returns Composed function\n */\nconst asyncCompose = (...fns) => async (value, ...args) => {\n    let result = value;\n    const reversedFns = fns.slice().reverse();\n    for (let i = 0; i < reversedFns.length; i += 1) {\n        const fn = reversedFns[i];\n        result = await fn(result, ...args);\n    }\n    return result;\n};\n\n/**\n * Capitalize first letter of each word\n *\n * @param value - Any string\n * @returns Capitalized string\n */\nconst capitalize = (value) => {\n    if (!value)\n        return value;\n    return value.replace(/(^|\\s)\\S/g, (l) => l.toUpperCase());\n};\n\n/**\n * Casts value to array\n *\n * @template T - The type of the value.\n * @param value - The value to cast into an array.\n * @returns An array containing the given value.\n */\nconst castArray = (value) => {\n    return Array.isArray(value) ? value : [value];\n};\n\n/**\n * Performs right-to-left function composition\n *\n * @param fns - Functions\n * @returns Composed function\n */\nconst compose = (...fns) => (value, ...args) => {\n    let result = value;\n    const reversedFns = fns.slice().reverse();\n    for (let i = 0; i < reversedFns.length; i += 1) {\n        const fn = reversedFns[i];\n        result = fn(result, ...args);\n    }\n    return result;\n};\n\n/**\n * Drops the last element from an array.\n *\n * @template T\n * @param  array - The array to drop the last element from\n * @returns - The new array with the last element dropped\n */\nconst dropLast = (array) => array.slice(0, array.length - 1);\n\n/**\n * Applies a set of transformations to an object and returns a new object with the transformed values.\n *\n * @template T\n * @param transformations - The transformations to apply.\n * @param object - The object to transform.\n * @returns The transformed object.\n */\nfunction evolve(transformations, object) {\n    const result = {};\n    const keys = Object.keys(object);\n    for (let i = 0; i < keys.length; i += 1) {\n        const key = keys[i];\n        const transformation = transformations[key];\n        if (typeof transformation === 'function') {\n            result[key] = transformation(object[key]);\n        }\n        else {\n            result[key] = object[key];\n        }\n    }\n    return result;\n}\n\n/**\n * Checks if a value is null or undefined.\n *\n * @template T - The type of the value.\n * @param value - The value to check\n * @returns True if the value is null or undefined, false otherwise\n */\nconst isNil = (value) => value === null || value === undefined;\n\n/**\n * Retrieves the value at a given path from an object.\n *\n * @param target - The object to retrieve the value from.\n * @param path - The path of the value to retrieve.\n * @param defaultValue - The default value to return if the path does not exist.\n * @returns The value at the given path, or the default value if the path does not exist.\n */\nconst get = (target, path, defaultValue) => {\n    if (isNil(target))\n        return defaultValue;\n    const _path = castArray(path);\n    let result = target;\n    for (let i = 0; i < _path.length; i += 1) {\n        if (isNil(result))\n            return undefined;\n        result = result[_path[i]];\n    }\n    return isNil(result) ? defaultValue : result;\n};\n\nfunction last(value) {\n    return value === '' ? '' : value[value.length - 1];\n}\n\n/**\n * Maps over the values of an object and applies a function to each value.\n *\n * @param object - The object to map over\n * @param fn - The function to apply to each value\n * @returns A new object with the mapped values\n */\nconst mapValues = (object, fn) => {\n    const entries = Object.entries(object);\n    const acc = {};\n    return entries.reduce((acc, [key, value], index) => {\n        acc[key] = fn(value, key, index);\n        return acc;\n    }, acc);\n};\n\nconst isPercent = (value) => /((-)?\\d+\\.?\\d*)%/g.exec(`${value}`);\n/**\n * Get percentage value of input\n *\n * @param value\n * @returns Percent value (if matches)\n */\nconst matchPercent = (value) => {\n    const match = isPercent(value);\n    if (match) {\n        const f = parseFloat(match[1]);\n        const percent = f / 100;\n        return { percent, value: f };\n    }\n    return null;\n};\n\n/**\n * Creates a new object by omitting specified keys from the original object.\n *\n * @param keys - The key or keys to omit\n * @param object - The original object\n * @returns The new object without the omitted keys\n */\nconst omit = (keys, object) => {\n    const _keys = castArray(keys);\n    const copy = Object.assign({}, object);\n    _keys.forEach((key) => {\n        delete copy[key];\n    });\n    return copy;\n};\n\n/**\n * Picks the specified keys from an object and returns a new object with only those keys.\n *\n * @param keys - The keys to pick from the object\n * @param object - The object to pick the keys from\n * @returns A new object with only the picked keys\n */\nconst pick = (keys, obj) => {\n    const result = {};\n    for (let i = 0; i < keys.length; i += 1) {\n        const key = keys[i];\n        if (key in obj)\n            result[key] = obj[key];\n    }\n    return result;\n};\n\n/**\n * Repeats an element a specified number of times.\n *\n * @template T\n * @param element - Element to be repeated\n * @param length - Number of times to repeat element\n * @returns Repeated elements\n */\nconst repeat = (element, length = 0) => {\n    const result = new Array(length);\n    for (let i = 0; i < length; i += 1) {\n        result[i] = element;\n    }\n    return result;\n};\n\n/**\n * Reverses the list\n *\n * @template T\n * @param list - List to be reversed\n * @returns Reversed list\n */\nconst reverse = (list) => Array.prototype.slice.call(list, 0).reverse();\n\n/**\n * Capitalize first letter of string\n *\n * @param value - String\n * @returns Capitalized string\n */\nconst upperFirst = (value) => {\n    if (!value)\n        return value;\n    return value.charAt(0).toUpperCase() + value.slice(1);\n};\n\n/**\n * Returns a new array with all the values from the original array that are not present in the keys array.\n *\n * @param keys - The keys to pick from the object\n * @param array - Array to filter the values from\n * @returns A new array with without the omitted values\n */\nconst without = (keys, array) => {\n    const result = [];\n    for (let i = 0; i < array.length; i += 1) {\n        const value = array[i];\n        if (!keys.includes(value))\n            result.push(value);\n    }\n    return result;\n};\n\n/**\n * Parse a string or number to a float\n *\n * @param value - String or number\n * @returns Parsed float\n */\nconst parseFloat$1 = (value) => {\n    return typeof value === 'string' ? Number.parseFloat(value) : value;\n};\n\nexport { adjust, asyncCompose, capitalize, castArray, compose, dropLast, evolve, get, isNil, last, mapValues, matchPercent, omit, parseFloat$1 as parseFloat, pick, repeat, reverse, upperFirst, without };\n"]},"metadata":{},"sourceType":"module"}