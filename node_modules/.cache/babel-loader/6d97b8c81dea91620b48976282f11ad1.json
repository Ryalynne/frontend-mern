{"ast":null,"code":"import _slicedToArray from \"C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectWithoutProperties from \"C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _asyncToGenerator from \"C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _defineProperty from \"C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _objectSpread from \"C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _toConsumableArray from \"C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nvar _excluded = [\"style\", \"children\"];\nimport _regeneratorRuntime from \"C:\\\\Users\\\\PC\\\\Documents\\\\PROGRAMMING\\\\MERN\\\\frontend\\\\node_modules\\\\@babel\\\\runtime\\\\regenerator\\\\index.js\";\nimport { upperFirst, capitalize, parseFloat as parseFloat$1, without, pick, compose, evolve, mapValues, matchPercent, castArray, isNil, omit, asyncCompose } from '@react-pdf/fns';\nimport * as P from '@react-pdf/primitives';\nimport resolveStyle, { transformColor, flatten } from '@react-pdf/stylesheet';\nimport layoutEngine, { fontSubstitution, wordHyphenation, scriptItemizer, textDecoration, justification, linebreaker, bidi, fromFragments } from '@react-pdf/textkit';\nimport * as Yoga from 'yoga-layout/load';\nimport { loadYoga as loadYoga$1 } from 'yoga-layout/load';\nimport emojiRegex from 'emoji-regex';\nimport resolveImage from '@react-pdf/image';\n/**\n * Apply transformation to text string\n *\n * @param {string} text\n * @param {string} transformation type\n * @returns {string} transformed text\n */\n\nvar transformText = function transformText(text, transformation) {\n  switch (transformation) {\n    case 'uppercase':\n      return text.toUpperCase();\n\n    case 'lowercase':\n      return text.toLowerCase();\n\n    case 'capitalize':\n      return capitalize(text);\n\n    case 'upperfirst':\n      return upperFirst(text);\n\n    default:\n      return text;\n  }\n};\n\nvar isTspan = function isTspan(node) {\n  return node.type === P.Tspan;\n};\n\nvar isTextInstance$4 = function isTextInstance$4(node) {\n  return node.type === P.TextInstance;\n};\n\nvar engines$1 = {\n  bidi: bidi,\n  linebreaker: linebreaker,\n  justification: justification,\n  textDecoration: textDecoration,\n  scriptItemizer: scriptItemizer,\n  wordHyphenation: wordHyphenation,\n  fontSubstitution: fontSubstitution\n};\nvar engine$1 = layoutEngine(engines$1);\n\nvar getFragments$1 = function getFragments$1(fontStore, instance) {\n  if (!instance) return [{\n    string: ''\n  }];\n  var fragments = [];\n  var _instance$props = instance.props,\n      _instance$props$fill = _instance$props.fill,\n      fill = _instance$props$fill === void 0 ? 'black' : _instance$props$fill,\n      _instance$props$fontF = _instance$props.fontFamily,\n      fontFamily = _instance$props$fontF === void 0 ? 'Helvetica' : _instance$props$fontF,\n      fontWeight = _instance$props.fontWeight,\n      fontStyle = _instance$props.fontStyle,\n      _instance$props$fontS = _instance$props.fontSize,\n      fontSize = _instance$props$fontS === void 0 ? 18 : _instance$props$fontS,\n      textDecorationColor = _instance$props.textDecorationColor,\n      textDecorationStyle = _instance$props.textDecorationStyle,\n      textTransform = _instance$props.textTransform,\n      opacity = _instance$props.opacity;\n  var _textDecoration = instance.props.textDecoration;\n  var fontFamilies = typeof fontFamily === 'string' ? [fontFamily] : _toConsumableArray(fontFamily || []); // Fallback font\n\n  fontFamilies.push('Helvetica');\n  var font = fontFamilies.map(function (fontFamilyName) {\n    var opts = {\n      fontFamily: fontFamilyName,\n      fontWeight: fontWeight,\n      fontStyle: fontStyle\n    };\n    var obj = fontStore.getFont(opts);\n    return obj === null || obj === void 0 ? void 0 : obj.data;\n  });\n  var attributes = {\n    font: font,\n    opacity: opacity,\n    fontSize: fontSize,\n    color: fill,\n    underlineStyle: textDecorationStyle,\n    underline: _textDecoration === 'underline' || _textDecoration === 'underline line-through' || _textDecoration === 'line-through underline',\n    underlineColor: textDecorationColor || fill,\n    strike: _textDecoration === 'line-through' || _textDecoration === 'underline line-through' || _textDecoration === 'line-through underline',\n    strikeStyle: textDecorationStyle,\n    strikeColor: textDecorationColor || fill\n  };\n\n  for (var i = 0; i < instance.children.length; i += 1) {\n    var child = instance.children[i];\n\n    if (isTextInstance$4(child)) {\n      fragments.push({\n        string: transformText(child.value, textTransform),\n        attributes: attributes\n      });\n    } else if (child) {\n      fragments.push.apply(fragments, _toConsumableArray(getFragments$1(fontStore, child)));\n    }\n  }\n\n  return fragments;\n};\n\nvar getAttributedString$1 = function getAttributedString$1(fontStore, instance) {\n  return fromFragments(getFragments$1(fontStore, instance));\n};\n\nvar AlmostInfinity = 999999999999;\nvar shrinkWhitespaceFactor = {\n  before: -0.5,\n  after: -0.5\n};\n\nvar layoutTspan = function layoutTspan(fontStore) {\n  return function (node, xOffset) {\n    var _node$props;\n\n    var attributedString = getAttributedString$1(fontStore, node);\n    var x = node.props.x === undefined ? xOffset : node.props.x;\n    var y = ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.y) || 0;\n    var container = {\n      x: x,\n      y: y,\n      width: AlmostInfinity,\n      height: AlmostInfinity\n    };\n    var hyphenationCallback = node.props.hyphenationCallback || (fontStore === null || fontStore === void 0 ? void 0 : fontStore.getHyphenationCallback()) || null;\n    var layoutOptions = {\n      hyphenationCallback: hyphenationCallback,\n      shrinkWhitespaceFactor: shrinkWhitespaceFactor\n    };\n    var lines = engine$1(attributedString, container, layoutOptions).flat();\n    return Object.assign({}, node, {\n      lines: lines\n    });\n  };\n}; // Consecutive TSpan elements should be joined with a space\n\n\nvar joinTSpanLines = function joinTSpanLines(node) {\n  var children = node.children.map(function (child, index) {\n    if (!isTspan(child)) return child;\n    var textInstance = child.children[0];\n\n    if (child.props.x === undefined && index < node.children.length - 1 && textInstance !== null && textInstance !== void 0 && textInstance.value) {\n      return Object.assign({}, child, {\n        children: [_objectSpread(_objectSpread({}, textInstance), {}, {\n          value: \"\".concat(textInstance.value, \" \")\n        })]\n      });\n    }\n\n    return child;\n  }, []);\n  return Object.assign({}, node, {\n    children: children\n  });\n};\n\nvar layoutText$1 = function layoutText$1(fontStore, node) {\n  var _node$props2;\n\n  if (!node.children) return node;\n  var currentXOffset = ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.x) || 0;\n  var layoutFn = layoutTspan(fontStore);\n  var joinedNode = joinTSpanLines(node);\n  var children = joinedNode.children.map(function (child) {\n    var childWithLayout = layoutFn(child, currentXOffset);\n    currentXOffset += childWithLayout.lines[0].xAdvance;\n    return childWithLayout;\n  });\n  return Object.assign({}, node, {\n    children: children\n  });\n};\n\nvar isDefs = function isDefs(node) {\n  return node.type === P.Defs;\n};\n\nvar getDefs = function getDefs(node) {\n  var children = node.children || [];\n  var defs = children.find(isDefs);\n  var values = (defs === null || defs === void 0 ? void 0 : defs.children) || [];\n  return values.reduce(function (acc, value) {\n    var _value$props;\n\n    var id = (_value$props = value.props) === null || _value$props === void 0 ? void 0 : _value$props.id;\n    if (id) acc[id] = value;\n    return acc;\n  }, {});\n};\n\nvar isNotDefs = function isNotDefs(node) {\n  return node.type !== P.Defs;\n};\n\nvar detachDefs = function detachDefs(node) {\n  if (!node.children) return node;\n  var children = node.children.filter(isNotDefs);\n  return Object.assign({}, node, {\n    children: children\n  });\n};\n\nvar URL_REGEX = /url\\(['\"]?#([^'\"]+)['\"]?\\)/;\n\nvar replaceDef = function replaceDef(defs, value) {\n  if (!value) return undefined;\n  if (!URL_REGEX.test(value)) return value;\n  var match = value.match(URL_REGEX);\n  return defs[match[1]];\n};\n\nvar parseNodeDefs = function parseNodeDefs(defs) {\n  return function (node) {\n    var props = node.props;\n    var fill = \"fill\" in props ? replaceDef(defs, props === null || props === void 0 ? void 0 : props.fill) : undefined;\n    var clipPath = \"clipPath\" in props ? replaceDef(defs, props === null || props === void 0 ? void 0 : props.clipPath) : undefined;\n    var newProps = Object.assign({}, node.props, {\n      fill: fill,\n      clipPath: clipPath\n    });\n    var children = node.children ? node.children.map(parseNodeDefs(defs)) : undefined;\n    return Object.assign({}, node, {\n      props: newProps,\n      children: children\n    });\n  };\n};\n\nvar parseDefs = function parseDefs(root) {\n  if (!root.children) return root;\n  var defs = getDefs(root);\n  var children = root.children.map(parseNodeDefs(defs));\n  return Object.assign({}, root, {\n    children: children\n  });\n};\n\nvar replaceDefs = function replaceDefs(node) {\n  return detachDefs(parseDefs(node));\n};\n\nvar parseViewbox = function parseViewbox(value) {\n  if (!value) return null;\n  if (typeof value !== 'string') return value;\n  var values = value.split(/[,\\s]+/).map(parseFloat$1);\n  if (values.length !== 4) return null;\n  return {\n    minX: values[0],\n    minY: values[1],\n    maxX: values[2],\n    maxY: values[3]\n  };\n};\n\nvar getContainer$1 = function getContainer$1(node) {\n  var viewbox = parseViewbox(node.props.viewBox);\n\n  if (viewbox) {\n    return {\n      width: viewbox.maxX,\n      height: viewbox.maxY\n    };\n  }\n\n  if (node.props.width && node.props.height) {\n    return {\n      width: parseFloat$1(node.props.width),\n      height: parseFloat$1(node.props.height)\n    };\n  }\n\n  return {\n    width: 0,\n    height: 0\n  };\n};\n\nvar BASE_SVG_INHERITED_PROPS = ['x', 'y', 'clipPath', 'clipRule', 'opacity', 'fill', 'fillOpacity', 'fillRule', 'stroke', 'strokeLinecap', 'strokeLinejoin', 'strokeOpacity', 'strokeWidth', 'textAnchor', 'dominantBaseline', 'color', 'fontFamily', 'fontSize', 'fontStyle', 'fontWeight', 'letterSpacing', 'opacity', 'textDecoration', 'lineHeight', 'textAlign', 'visibility', 'wordSpacing']; // Do not inherit \"x\" for <tspan> elements from <text> parent\n\nvar TEXT_SVG_INHERITED_PROPS = without(['x'], BASE_SVG_INHERITED_PROPS);\n\nvar SVG_INHERITED_PROPS = _defineProperty({}, P.Text, TEXT_SVG_INHERITED_PROPS);\n\nvar getInheritProps = function getInheritProps(node) {\n  var _SVG_INHERITED_PROPS$;\n\n  var props = node.props || {};\n  var svgInheritedProps = (_SVG_INHERITED_PROPS$ = SVG_INHERITED_PROPS[node.type]) !== null && _SVG_INHERITED_PROPS$ !== void 0 ? _SVG_INHERITED_PROPS$ : BASE_SVG_INHERITED_PROPS;\n  return pick(svgInheritedProps, props);\n};\n\nvar inheritProps = function inheritProps(node) {\n  if (!node.children) return node;\n  var inheritedProps = getInheritProps(node);\n  var children = node.children.map(function (child) {\n    var props = Object.assign({}, inheritedProps, child.props || {});\n    var newChild = Object.assign({}, child, {\n      props: props\n    });\n    return inheritProps(newChild);\n  });\n  return Object.assign({}, node, {\n    children: children\n  });\n};\n\nvar parseAspectRatio = function parseAspectRatio(value) {\n  if (typeof value !== 'string') return value;\n  var match = value.replace(/[\\s\\r\\t\\n]+/gm, ' ').replace(/^defer\\s/, '').split(' ');\n  var align = match[0] || 'xMidYMid';\n  var meetOrSlice = match[1] || 'meet';\n  return {\n    align: align,\n    meetOrSlice: meetOrSlice\n  };\n};\n\nvar STYLE_PROPS = ['width', 'height', 'color', 'stroke', 'strokeWidth', 'opacity', 'fillOpacity', 'strokeOpacity', 'fill', 'fillRule', 'clipPath', 'offset', 'transform', 'strokeLinejoin', 'strokeLinecap', 'strokeDasharray', 'gradientUnits', 'gradientTransform'];\nvar VERTICAL_PROPS = ['y', 'y1', 'y2', 'height', 'cy', 'ry'];\nvar HORIZONTAL_PROPS = ['x', 'x1', 'x2', 'width', 'cx', 'rx'];\n\nvar isSvg$3 = function isSvg$3(node) {\n  return node.type === P.Svg;\n};\n\nvar isText$5 = function isText$5(node) {\n  return node.type === P.Text;\n};\n\nvar isTextInstance$3 = function isTextInstance$3(node) {\n  return node.type === P.TextInstance;\n};\n\nvar transformPercent = function transformPercent(container) {\n  return function (props) {\n    return mapValues(props, function (value, key) {\n      var match = matchPercent(value);\n\n      if (match && VERTICAL_PROPS.includes(key)) {\n        return match.percent * container.height;\n      }\n\n      if (match && HORIZONTAL_PROPS.includes(key)) {\n        return match.percent * container.width;\n      }\n\n      return value;\n    });\n  };\n};\n\nvar parsePercent = function parsePercent(value) {\n  var match = matchPercent(value);\n  return match ? match.percent : parseFloat$1(value);\n};\n\nvar parseTransform = function parseTransform(container) {\n  return function (value) {\n    return resolveStyle(container, {\n      transform: value\n    }).transform;\n  };\n};\n\nvar parseProps = function parseProps(container) {\n  return function (node) {\n    var props = transformPercent(container)(node.props);\n    props = evolve({\n      x: parseFloat$1,\n      x1: parseFloat$1,\n      x2: parseFloat$1,\n      y: parseFloat$1,\n      y1: parseFloat$1,\n      y2: parseFloat$1,\n      r: parseFloat$1,\n      rx: parseFloat$1,\n      ry: parseFloat$1,\n      cx: parseFloat$1,\n      cy: parseFloat$1,\n      width: parseFloat$1,\n      height: parseFloat$1,\n      offset: parsePercent,\n      fill: transformColor,\n      opacity: parsePercent,\n      stroke: transformColor,\n      stopOpacity: parsePercent,\n      stopColor: transformColor,\n      transform: parseTransform(container),\n      gradientTransform: parseTransform(container)\n    }, props);\n    return Object.assign({}, node, {\n      props: props\n    });\n  };\n};\n\nvar mergeStyles$1 = function mergeStyles$1(node) {\n  var style = node.style || {};\n  var props = Object.assign({}, style, node.props);\n  return Object.assign({}, node, {\n    props: props\n  });\n};\n\nvar removeNoneValues = function removeNoneValues(node) {\n  var removeNone = function removeNone(value) {\n    return value === 'none' ? null : value;\n  };\n\n  var props = mapValues(node.props, removeNone);\n  return Object.assign({}, node, {\n    props: props\n  });\n};\n\nvar pickStyleProps = function pickStyleProps(node) {\n  var props = node.props || {};\n  var styleProps = pick(STYLE_PROPS, props);\n  var style = Object.assign({}, styleProps, node.style || {});\n  return Object.assign({}, node, {\n    style: style\n  });\n};\n\nvar parseSvgProps = function parseSvgProps(node) {\n  var props = evolve({\n    width: parseFloat$1,\n    height: parseFloat$1,\n    viewBox: parseViewbox,\n    preserveAspectRatio: parseAspectRatio\n  }, node.props);\n  return Object.assign({}, node, {\n    props: props\n  });\n};\n\nvar wrapBetweenTspan = function wrapBetweenTspan(node) {\n  return {\n    type: P.Tspan,\n    props: {},\n    style: {},\n    children: [node]\n  };\n};\n\nvar addMissingTspan = function addMissingTspan(node) {\n  if (!isText$5(node)) return node;\n  if (!node.children) return node;\n\n  var resolveChild = function resolveChild(child) {\n    return isTextInstance$3(child) ? wrapBetweenTspan(child) : child;\n  };\n\n  var children = node.children.map(resolveChild);\n  return Object.assign({}, node, {\n    children: children\n  });\n};\n\nvar parseText = function parseText(fontStore) {\n  return function (node) {\n    if (isText$5(node)) return layoutText$1(fontStore, node);\n    if (!node.children) return node;\n    var children = node.children.map(parseText(fontStore));\n    return Object.assign({}, node, {\n      children: children\n    });\n  };\n};\n\nvar resolveSvgNode = function resolveSvgNode(container) {\n  return compose(parseProps(container), addMissingTspan, removeNoneValues, mergeStyles$1);\n};\n\nvar resolveChildren = function resolveChildren(container) {\n  return function (node) {\n    if (!node.children) return node;\n    var resolveChild = compose(resolveChildren(container), resolveSvgNode(container));\n    var children = node.children.map(resolveChild);\n    return Object.assign({}, node, {\n      children: children\n    });\n  };\n};\n\nvar buildXLinksIndex = function buildXLinksIndex(node) {\n  var _node$children;\n\n  var idIndex = {};\n  var listToExplore = ((_node$children = node.children) === null || _node$children === void 0 ? void 0 : _node$children.slice(0)) || [];\n\n  while (listToExplore.length > 0) {\n    var child = listToExplore.shift();\n\n    if (child.props && 'id' in child.props) {\n      idIndex[child.props.id] = child;\n    }\n\n    if (child.children) listToExplore.push.apply(listToExplore, _toConsumableArray(child.children));\n  }\n\n  return idIndex;\n};\n\nvar replaceXLinks = function replaceXLinks(node, idIndex) {\n  var _node$children2;\n\n  if (node.props && 'xlinkHref' in node.props) {\n    var linkedNode = idIndex[node.props.xlinkHref.replace(/^#/, '')]; // No node to extend from\n\n    if (!linkedNode) return node;\n    var newProps = Object.assign({}, linkedNode.props, node.props);\n    delete newProps.xlinkHref;\n    return Object.assign({}, linkedNode, {\n      props: newProps\n    });\n  }\n\n  var children = (_node$children2 = node.children) === null || _node$children2 === void 0 ? void 0 : _node$children2.map(function (child) {\n    return replaceXLinks(child, idIndex);\n  });\n  return Object.assign({}, node, {\n    children: children\n  });\n};\n\nvar resolveXLinks = function resolveXLinks(node) {\n  var idIndex = buildXLinksIndex(node);\n  return replaceXLinks(node, idIndex);\n};\n\nvar resolveSvgRoot = function resolveSvgRoot(node, fontStore) {\n  var container = getContainer$1(node);\n  return compose(replaceDefs, parseText(fontStore), parseSvgProps, pickStyleProps, inheritProps, resolveChildren(container), resolveXLinks)(node);\n};\n/**\n * Pre-process SVG nodes so they can be rendered in the next steps\n *\n * @param node - Root node\n * @param fontStore - Font store\n * @returns Root node\n */\n\n\nvar resolveSvg = function resolveSvg(node, fontStore) {\n  var _root$children;\n\n  if (!('children' in node)) return node;\n\n  var resolveChild = function resolveChild(child) {\n    return resolveSvg(child, fontStore);\n  };\n\n  var root = isSvg$3(node) ? resolveSvgRoot(node, fontStore) : node;\n  var children = (_root$children = root.children) === null || _root$children === void 0 ? void 0 : _root$children.map(resolveChild);\n  return Object.assign({}, root, {\n    children: children\n  });\n};\n\nvar instancePromise;\n\nvar loadYoga = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var _instancePromise;\n\n    var instance, config, node;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return (_instancePromise = instancePromise) !== null && _instancePromise !== void 0 ? _instancePromise : instancePromise = loadYoga$1();\n\n          case 2:\n            instance = _context.sent;\n            config = instance.Config.create();\n            config.setPointScaleFactor(0);\n            node = {\n              create: function create() {\n                return instance.Node.createWithConfig(config);\n              }\n            };\n            return _context.abrupt(\"return\", {\n              node: node\n            });\n\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function loadYoga() {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar resolveYoga = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(root) {\n    var yoga;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return loadYoga();\n\n          case 2:\n            yoga = _context2.sent;\n            return _context2.abrupt(\"return\", Object.assign({}, root, {\n              yoga: yoga\n            }));\n\n          case 4:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function resolveYoga(_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar getZIndex = function getZIndex(node) {\n  return node.style.zIndex;\n};\n\nvar shouldSort = function shouldSort(node) {\n  return node.type !== P.Document && node.type !== P.Svg;\n};\n\nvar sortZIndex = function sortZIndex(a, b) {\n  var za = getZIndex(a);\n  var zb = getZIndex(b);\n  if (!za && !zb) return 0;\n  if (!za) return 1;\n  if (!zb) return -1;\n  return zb - za;\n};\n/**\n * Sort children by zIndex value\n *\n * @param node\n * @returns Node\n */\n\n\nvar resolveNodeZIndex = function resolveNodeZIndex(node) {\n  if (!node.children) return node;\n  var sortedChildren = shouldSort(node) ? node.children.sort(sortZIndex) : node.children;\n  var children = sortedChildren.map(resolveNodeZIndex);\n  return Object.assign({}, node, {\n    children: children\n  });\n};\n/**\n * Sort children by zIndex value\n *\n * @param node\n * @returns Node\n */\n\n\nvar resolveZIndex = function resolveZIndex(root) {\n  return resolveNodeZIndex(root);\n}; // Caches emoji images data\n\n\nvar emojis = {};\nvar regex = emojiRegex();\n/**\n * When an emoji as no variations, it might still have 2 parts,\n * the canonical emoji and an empty string.\n * ex.\n *   (no color) Array.from('â¤ï¸') => [\"â¤\", \"ï¸\"]\n *   (w/ color) Array.from('ðŸ‘ðŸ¿') => [\"ðŸ‘\", \"ðŸ¿\"]\n *\n * The empty string needs to be removed otherwise the generated\n * url will be incorect.\n */\n\nvar removeVariationSelectors = function removeVariationSelectors(x) {\n  return x !== 'ï¸';\n};\n\nvar getCodePoints = function getCodePoints(string) {\n  var withVariationSelectors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return Array.from(string).filter(withVariationSelectors ? function () {\n    return true;\n  } : removeVariationSelectors).map(function (char) {\n    return char.codePointAt(0).toString(16);\n  }).join('-');\n};\n\nvar buildEmojiUrl = function buildEmojiUrl(emoji, source) {\n  if ('builder' in source) {\n    return source.builder(getCodePoints(emoji, source.withVariationSelectors));\n  }\n\n  var url = source.url,\n      _source$format = source.format,\n      format = _source$format === void 0 ? 'png' : _source$format,\n      withVariationSelectors = source.withVariationSelectors;\n  return \"\".concat(url).concat(getCodePoints(emoji, withVariationSelectors), \".\").concat(format);\n};\n\nvar fetchEmojis = function fetchEmojis(string, source) {\n  if (!source) return [];\n  var promises = [];\n  Array.from(string.matchAll(regex)).forEach(function (match) {\n    var emoji = match[0];\n\n    if (!emojis[emoji] || emojis[emoji].loading) {\n      var emojiUrl = buildEmojiUrl(emoji, source);\n      emojis[emoji] = {\n        loading: true\n      };\n      promises.push(resolveImage({\n        uri: emojiUrl\n      }).then(function (image) {\n        emojis[emoji].loading = false;\n        emojis[emoji].data = image.data;\n      }));\n    }\n  });\n  return promises;\n};\n\nvar embedEmojis = function embedEmojis(fragments) {\n  var result = [];\n\n  var _loop = function _loop(i) {\n    var fragment = fragments[i];\n    var lastIndex = 0;\n    Array.from(fragment.string.matchAll(regex)).forEach(function (match) {\n      var index = match.index;\n      var emoji = match[0];\n      var emojiSize = fragment.attributes.fontSize;\n      var chunk = fragment.string.slice(lastIndex, index + match[0].length); // If emoji image was found, we create a new fragment with the\n      // correct attachment and object substitution character;\n\n      if (emojis[emoji] && emojis[emoji].data) {\n        result.push({\n          string: chunk.replace(match[0], String.fromCharCode(0xfffc)),\n          attributes: _objectSpread(_objectSpread({}, fragment.attributes), {}, {\n            attachment: {\n              width: emojiSize,\n              height: emojiSize,\n              yOffset: Math.floor(emojiSize * 0.1),\n              image: emojis[emoji].data\n            }\n          })\n        });\n      } else {\n        // If no emoji data, we try to use emojis in the font\n        result.push({\n          string: chunk,\n          attributes: fragment.attributes\n        });\n      }\n\n      lastIndex = index + emoji.length;\n    });\n\n    if (lastIndex < fragment.string.length) {\n      result.push({\n        string: fragment.string.slice(lastIndex),\n        attributes: fragment.attributes\n      });\n    }\n  };\n\n  for (var i = 0; i < fragments.length; i += 1) {\n    _loop(i);\n  }\n\n  return result;\n};\n/**\n * Get image source\n *\n * @param node - Image node\n * @returns Image src\n */\n\n\nvar getSource = function getSource(node) {\n  if (node.props.src) return node.props.src;\n  if (node.props.source) return node.props.source;\n};\n/**\n * Resolves `src` to `@react-pdf/image` interface.\n *\n * Also it handles factories and async sources.\n *\n * @param src\n * @returns Resolved src\n */\n\n\nvar resolveSource = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(src) {\n    var source;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            if (!(typeof src === 'function')) {\n              _context3.next = 6;\n              break;\n            }\n\n            _context3.next = 3;\n            return src();\n\n          case 3:\n            _context3.t0 = _context3.sent;\n            _context3.next = 9;\n            break;\n\n          case 6:\n            _context3.next = 8;\n            return src;\n\n          case 8:\n            _context3.t0 = _context3.sent;\n\n          case 9:\n            source = _context3.t0;\n            return _context3.abrupt(\"return\", typeof source === 'string' ? {\n              uri: source\n            } : source);\n\n          case 11:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function resolveSource(_x2) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n/**\n * Fetches image and append data to node\n * Ideally this fn should be immutable.\n *\n * @param node\n */\n\n\nvar fetchImage = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(node) {\n    var src, cache, source;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            src = getSource(node);\n            cache = node.props.cache;\n\n            if (src) {\n              _context4.next = 5;\n              break;\n            }\n\n            console.warn(false, 'Image should receive either a \"src\" or \"source\" prop');\n            return _context4.abrupt(\"return\");\n\n          case 5:\n            _context4.prev = 5;\n            _context4.next = 8;\n            return resolveSource(src);\n\n          case 8:\n            source = _context4.sent;\n\n            if (source) {\n              _context4.next = 11;\n              break;\n            }\n\n            throw new Error(\"Image's \\\"src\\\" or \\\"source\\\" prop returned \".concat(source));\n\n          case 11:\n            _context4.next = 13;\n            return resolveImage(source, {\n              cache: cache\n            });\n\n          case 13:\n            node.image = _context4.sent;\n\n            if (!(Buffer.isBuffer(source) || source instanceof Blob)) {\n              _context4.next = 16;\n              break;\n            }\n\n            return _context4.abrupt(\"return\");\n\n          case 16:\n            node.image.key = 'data' in source ? source.data.toString() : source.uri;\n            _context4.next = 22;\n            break;\n\n          case 19:\n            _context4.prev = 19;\n            _context4.t0 = _context4[\"catch\"](5);\n            console.warn(_context4.t0.message);\n\n          case 22:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4, null, [[5, 19]]);\n  }));\n\n  return function fetchImage(_x3) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nvar isImage$2 = function isImage$2(node) {\n  return node.type === P.Image;\n};\n/**\n * Get all asset promises that need to be resolved\n *\n * @param fontStore - Font store\n * @param node - Root node\n * @returns Asset promises\n */\n\n\nvar fetchAssets = function fetchAssets(fontStore, node) {\n  var _node$children3;\n\n  var promises = [];\n  var listToExplore = ((_node$children3 = node.children) === null || _node$children3 === void 0 ? void 0 : _node$children3.slice(0)) || [];\n  var emojiSource = fontStore ? fontStore.getEmojiSource() : null;\n\n  var _loop2 = function _loop2() {\n    var _n$style;\n\n    var n = listToExplore.shift();\n\n    if (isImage$2(n)) {\n      promises.push(fetchImage(n));\n    }\n\n    if (fontStore && (_n$style = n.style) !== null && _n$style !== void 0 && _n$style.fontFamily) {\n      var fontFamilies = castArray(n.style.fontFamily);\n      promises.push.apply(promises, _toConsumableArray(fontFamilies.map(function (fontFamily) {\n        return fontStore.load({\n          fontFamily: fontFamily,\n          fontStyle: n.style.fontStyle,\n          fontWeight: n.style.fontWeight\n        });\n      })));\n    }\n\n    if (typeof n === 'string') {\n      promises.push.apply(promises, _toConsumableArray(fetchEmojis(n, emojiSource)));\n    }\n\n    if ('value' in n && typeof n.value === 'string') {\n      promises.push.apply(promises, _toConsumableArray(fetchEmojis(n.value, emojiSource)));\n    }\n\n    if (n.children) {\n      n.children.forEach(function (childNode) {\n        listToExplore.push(childNode);\n      });\n    }\n  };\n\n  while (listToExplore.length > 0) {\n    _loop2();\n  }\n\n  return promises;\n};\n/**\n * Fetch image, font and emoji assets in parallel.\n * Layout process will not be resumed until promise resolves.\n *\n * @param node root node\n * @param fontStore font store\n * @returns Root node\n */\n\n\nvar resolveAssets = /*#__PURE__*/function () {\n  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(node, fontStore) {\n    var promises;\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            promises = fetchAssets(fontStore, node);\n            _context5.next = 3;\n            return Promise.all(promises);\n\n          case 3:\n            return _context5.abrupt(\"return\", node);\n\n          case 4:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n\n  return function resolveAssets(_x4, _x5) {\n    return _ref5.apply(this, arguments);\n  };\n}();\n\nvar isLink$1 = function isLink$1(node) {\n  return node.type === P.Link;\n};\n\nvar DEFAULT_LINK_STYLES = {\n  color: 'blue',\n  textDecoration: 'underline'\n};\n/**\n * Computes styles using stylesheet\n *\n * @param container\n * @param node - Document node\n * @returns Computed styles\n */\n\nvar computeStyle = function computeStyle(container, node) {\n  var baseStyle = [node.style];\n\n  if (isLink$1(node)) {\n    baseStyle = Array.isArray(node.style) ? [DEFAULT_LINK_STYLES].concat(_toConsumableArray(node.style)) : [DEFAULT_LINK_STYLES, node.style];\n  }\n\n  return resolveStyle(container, baseStyle);\n};\n/**\n * Resolves node styles\n *\n * @param container\n * @returns Resolve node styles\n */\n\n\nvar resolveNodeStyles = function resolveNodeStyles(container) {\n  return function (node) {\n    var style = computeStyle(container, node);\n    if (!node.children) return Object.assign({}, node, {\n      style: style\n    });\n    var children = node.children.map(resolveNodeStyles(container));\n    return Object.assign({}, node, {\n      style: style,\n      children: children\n    });\n  };\n};\n/**\n * Resolves page styles\n *\n * @param page Document page\n * @returns Document page with resolved styles\n */\n\n\nvar resolvePageStyles = function resolvePageStyles(page) {\n  var _page$props, _page$box, _page$box2, _page$props2;\n\n  var dpi = ((_page$props = page.props) === null || _page$props === void 0 ? void 0 : _page$props.dpi) || 72;\n  var style = page.style;\n  var width = ((_page$box = page.box) === null || _page$box === void 0 ? void 0 : _page$box.width) || style.width;\n  var height = ((_page$box2 = page.box) === null || _page$box2 === void 0 ? void 0 : _page$box2.height) || style.height;\n  var orientation = ((_page$props2 = page.props) === null || _page$props2 === void 0 ? void 0 : _page$props2.orientation) || 'portrait';\n  var remBase = (style === null || style === void 0 ? void 0 : style.fontSize) || 18;\n  var container = {\n    width: width,\n    height: height,\n    orientation: orientation,\n    dpi: dpi,\n    remBase: remBase\n  };\n  return resolveNodeStyles(container)(page);\n};\n/**\n * Resolves document styles\n *\n * @param root - Document root\n * @returns Document root with resolved styles\n */\n\n\nvar resolveStyles = function resolveStyles(root) {\n  if (!root.children) return root;\n  var children = root.children.map(resolvePageStyles);\n  return Object.assign({}, root, {\n    children: children\n  });\n};\n\nvar getTransformStyle = function getTransformStyle(s) {\n  return function (node) {\n    var _node$style, _node$style$s, _node$style2;\n\n    return isNil((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style[s]) ? '50%' : (_node$style$s = (_node$style2 = node.style) === null || _node$style2 === void 0 ? void 0 : _node$style2[s]) !== null && _node$style$s !== void 0 ? _node$style$s : null;\n  };\n};\n/**\n * Get node origin\n *\n * @param node\n * @returns {{ left?: number, top?: number }} node origin\n */\n\n\nvar getOrigin = function getOrigin(node) {\n  if (!node.box) return null;\n  var _node$box = node.box,\n      left = _node$box.left,\n      top = _node$box.top,\n      width = _node$box.width,\n      height = _node$box.height;\n  var transformOriginX = getTransformStyle('transformOriginX')(node);\n  var transformOriginY = getTransformStyle('transformOriginY')(node);\n  var percentX = matchPercent(transformOriginX);\n  var percentY = matchPercent(transformOriginY);\n  var offsetX = percentX ? width * percentX.percent : transformOriginX;\n  var offsetY = percentY ? height * percentY.percent : transformOriginY;\n  if (isNil(offsetX) || typeof offsetX === 'string') throw new Error(\"Invalid origin offsetX: \".concat(offsetX));\n  if (isNil(offsetY) || typeof offsetY === 'string') throw new Error(\"Invalid origin offsetY: \".concat(offsetY));\n  return {\n    left: left + offsetX,\n    top: top + offsetY\n  };\n};\n/**\n * Resolve node origin\n *\n * @param node\n * @returns Node with origin attribute\n */\n\n\nvar resolveNodeOrigin = function resolveNodeOrigin(node) {\n  var origin = getOrigin(node);\n  var newNode = Object.assign({}, node, {\n    origin: origin\n  });\n  if (!node.children) return newNode;\n  var children = node.children.map(resolveNodeOrigin);\n  return Object.assign({}, newNode, {\n    children: children\n  });\n};\n/**\n * Resolve document origins\n *\n * @param root - Document root\n * @returns Document root\n */\n\n\nvar resolveOrigin = function resolveOrigin(root) {\n  if (!root.children) return root;\n  var children = root.children.map(resolveNodeOrigin);\n  return Object.assign({}, root, {\n    children: children\n  });\n};\n\nvar getBookmarkValue = function getBookmarkValue(bookmark) {\n  return typeof bookmark === 'string' ? {\n    title: bookmark,\n    fit: false,\n    expanded: false\n  } : bookmark;\n};\n\nvar resolveBookmarks = function resolveBookmarks(node) {\n  var refs = 0;\n  var children = (node.children || []).slice(0);\n  var listToExplore = children.map(function (value) {\n    return {\n      value: value,\n      parent: null\n    };\n  });\n\n  var _loop3 = function _loop3() {\n    var element = listToExplore.shift();\n    if (!element) return \"break\";\n    var child = element.value;\n    var parent = element.parent;\n\n    if (child.props && 'bookmark' in child.props) {\n      var _parent;\n\n      var bookmark = getBookmarkValue(child.props.bookmark);\n      var ref = refs++;\n\n      var newHierarchy = _objectSpread({\n        ref: ref,\n        parent: (_parent = parent) === null || _parent === void 0 ? void 0 : _parent.ref\n      }, bookmark);\n\n      child.props.bookmark = newHierarchy;\n      parent = newHierarchy;\n    }\n\n    if (child.children) {\n      child.children.forEach(function (childNode) {\n        listToExplore.push({\n          value: childNode,\n          parent: parent\n        });\n      });\n    }\n  };\n\n  while (listToExplore.length > 0) {\n    var _ret = _loop3();\n\n    if (_ret === \"break\") break;\n  }\n\n  return node;\n};\n\nvar VALID_ORIENTATIONS = ['portrait', 'landscape'];\n/**\n * Get page orientation. Defaults to portrait\n *\n * @param page - Page object\n * @returns Page orientation\n */\n\nvar getOrientation = function getOrientation(page) {\n  var _page$props3;\n\n  var value = ((_page$props3 = page.props) === null || _page$props3 === void 0 ? void 0 : _page$props3.orientation) || 'portrait';\n  return VALID_ORIENTATIONS.includes(value) ? value : 'portrait';\n};\n/**\n * Return true if page is landscape\n *\n * @param page - Page instance\n * @returns Is page landscape\n */\n\n\nvar isLandscape = function isLandscape(page) {\n  return getOrientation(page) === 'landscape';\n}; // Page sizes for 72dpi. 72dpi is used internally by pdfkit.\n\n\nvar PAGE_SIZES = {\n  '4A0': [4767.87, 6740.79],\n  '2A0': [3370.39, 4767.87],\n  A0: [2383.94, 3370.39],\n  A1: [1683.78, 2383.94],\n  A2: [1190.55, 1683.78],\n  A3: [841.89, 1190.55],\n  A4: [595.28, 841.89],\n  A5: [419.53, 595.28],\n  A6: [297.64, 419.53],\n  A7: [209.76, 297.64],\n  A8: [147.4, 209.76],\n  A9: [104.88, 147.4],\n  A10: [73.7, 104.88],\n  B0: [2834.65, 4008.19],\n  B1: [2004.09, 2834.65],\n  B2: [1417.32, 2004.09],\n  B3: [1000.63, 1417.32],\n  B4: [708.66, 1000.63],\n  B5: [498.9, 708.66],\n  B6: [354.33, 498.9],\n  B7: [249.45, 354.33],\n  B8: [175.75, 249.45],\n  B9: [124.72, 175.75],\n  B10: [87.87, 124.72],\n  C0: [2599.37, 3676.54],\n  C1: [1836.85, 2599.37],\n  C2: [1298.27, 1836.85],\n  C3: [918.43, 1298.27],\n  C4: [649.13, 918.43],\n  C5: [459.21, 649.13],\n  C6: [323.15, 459.21],\n  C7: [229.61, 323.15],\n  C8: [161.57, 229.61],\n  C9: [113.39, 161.57],\n  C10: [79.37, 113.39],\n  RA0: [2437.8, 3458.27],\n  RA1: [1729.13, 2437.8],\n  RA2: [1218.9, 1729.13],\n  RA3: [864.57, 1218.9],\n  RA4: [609.45, 864.57],\n  SRA0: [2551.18, 3628.35],\n  SRA1: [1814.17, 2551.18],\n  SRA2: [1275.59, 1814.17],\n  SRA3: [907.09, 1275.59],\n  SRA4: [637.8, 907.09],\n  EXECUTIVE: [521.86, 756.0],\n  FOLIO: [612.0, 936.0],\n  LEGAL: [612.0, 1008.0],\n  LETTER: [612.0, 792.0],\n  TABLOID: [792.0, 1224.0],\n  ID1: [153, 243]\n};\n/**\n * Parses scalar value in value and unit pairs\n *\n * @param value - Scalar value\n * @returns Parsed value\n */\n\nvar parseValue = function parseValue(value) {\n  if (typeof value === 'number') return {\n    value: value,\n    unit: undefined\n  };\n  var match = /^(-?\\d*\\.?\\d+)(in|mm|cm|pt|px)?$/g.exec(value);\n  return match ? {\n    value: parseFloat(match[1]),\n    unit: match[2] || 'pt'\n  } : {\n    value: value,\n    unit: undefined\n  };\n};\n/**\n * Transform given scalar value to 72dpi equivalent of size\n *\n * @param value - Styles value\n * @param inputDpi - User defined dpi\n * @returns Transformed value\n */\n\n\nvar transformUnit = function transformUnit(value, inputDpi) {\n  if (!value) return 0;\n  var scalar = parseValue(value);\n  var outputDpi = 72;\n  var mmFactor = 1 / 25.4 * outputDpi;\n  var cmFactor = 1 / 2.54 * outputDpi;\n  if (typeof scalar.value === 'string') throw new Error(\"Invalid page size: \".concat(value));\n\n  switch (scalar.unit) {\n    case 'in':\n      return scalar.value * outputDpi;\n\n    case 'mm':\n      return scalar.value * mmFactor;\n\n    case 'cm':\n      return scalar.value * cmFactor;\n\n    case 'px':\n      return Math.round(scalar.value * (outputDpi / inputDpi));\n\n    default:\n      return scalar.value;\n  }\n};\n\nvar transformUnits = function transformUnits(_ref6, dpi) {\n  var width = _ref6.width,\n      height = _ref6.height;\n  return {\n    width: transformUnit(width, dpi),\n    height: transformUnit(height, dpi)\n  };\n};\n/**\n * Transforms array into size object\n *\n * @param v - Values array\n * @returns Size object with width and height\n */\n\n\nvar toSizeObject = function toSizeObject(v) {\n  return {\n    width: v[0],\n    height: v[1]\n  };\n};\n/**\n * Flip size object\n *\n * @param v - Size object\n * @returns Flipped size object\n */\n\n\nvar flipSizeObject = function flipSizeObject(v) {\n  return {\n    width: v.height,\n    height: v.width\n  };\n};\n/**\n * Returns size object from a given string\n *\n * @param v - Page size string\n * @returns Size object with width and height\n */\n\n\nvar getStringSize = function getStringSize(v) {\n  return toSizeObject(PAGE_SIZES[v.toUpperCase()]);\n};\n/**\n * Returns size object from a single number\n *\n * @param n - Page size number\n * @returns Size object with width and height\n */\n\n\nvar getNumberSize = function getNumberSize(n) {\n  return toSizeObject([n, n]);\n};\n/**\n * Return page size in an object { width, height }\n *\n * @param page - Page node\n * @returns Size object with width and height\n */\n\n\nvar getSize = function getSize(page) {\n  var _page$props4, _page$props5;\n\n  var value = ((_page$props4 = page.props) === null || _page$props4 === void 0 ? void 0 : _page$props4.size) || 'A4';\n  var dpi = ((_page$props5 = page.props) === null || _page$props5 === void 0 ? void 0 : _page$props5.dpi) || 72;\n  var size;\n\n  if (typeof value === 'string') {\n    size = getStringSize(value);\n  } else if (Array.isArray(value)) {\n    size = transformUnits(toSizeObject(value), dpi);\n  } else if (typeof value === 'number') {\n    size = transformUnits(getNumberSize(value), dpi);\n  } else {\n    size = transformUnits(value, dpi);\n  }\n\n  return isLandscape(page) ? flipSizeObject(size) : size;\n};\n/**\n * Resolves page size\n *\n * @param page\n * @returns Page with resolved size in style attribute\n */\n\n\nvar resolvePageSize = function resolvePageSize(page) {\n  var size = getSize(page);\n  var style = flatten(page.style || {});\n  return _objectSpread(_objectSpread({}, page), {}, {\n    style: _objectSpread(_objectSpread({}, style), size)\n  });\n};\n/**\n * Resolves page sizes\n *\n * @param root  -Document root\n * @returns Document root with resolved page sizes\n */\n\n\nvar resolvePageSizes = function resolvePageSizes(root) {\n  if (!root.children) return root;\n  var children = root.children.map(resolvePageSize);\n  return Object.assign({}, root, {\n    children: children\n  });\n};\n\nvar isFixed = function isFixed(node) {\n  if (!node.props) return false;\n  return 'fixed' in node.props ? node.props.fixed === true : false;\n};\n/**\n * Get line index at given height\n *\n * @param node\n * @param height\n */\n\n\nvar lineIndexAtHeight = function lineIndexAtHeight(node, height) {\n  var y = 0;\n  if (!node.lines) return 0;\n\n  for (var i = 0; i < node.lines.length; i += 1) {\n    var line = node.lines[i];\n    if (y + line.box.height > height) return i;\n    y += line.box.height;\n  }\n\n  return node.lines.length;\n};\n/**\n * Get height for given text line index\n *\n * @param node\n * @param index\n */\n\n\nvar heightAtLineIndex = function heightAtLineIndex(node, index) {\n  var counter = 0;\n  if (!node.lines) return counter;\n\n  for (var i = 0; i < index; i += 1) {\n    var line = node.lines[i];\n    if (!line) break;\n    counter += line.box.height;\n  }\n\n  return counter;\n};\n\nvar getLineBreak = function getLineBreak(node, height) {\n  var _node$box2;\n\n  var top = ((_node$box2 = node.box) === null || _node$box2 === void 0 ? void 0 : _node$box2.top) || 0;\n  var widows = node.props.widows || 2;\n  var orphans = node.props.orphans || 2;\n  var linesQuantity = node.lines.length;\n  var slicedLine = lineIndexAtHeight(node, height - top);\n\n  if (slicedLine === 0) {\n    return 0;\n  }\n\n  if (linesQuantity < orphans) {\n    return linesQuantity;\n  }\n\n  if (slicedLine < orphans || linesQuantity < orphans + widows) {\n    return 0;\n  }\n\n  if (linesQuantity === orphans + widows) {\n    return orphans;\n  }\n\n  if (linesQuantity - slicedLine < widows) {\n    return linesQuantity - widows;\n  }\n\n  return slicedLine;\n}; // Also receives contentArea in case it's needed\n\n\nvar splitText = function splitText(node, height) {\n  var slicedLineIndex = getLineBreak(node, height);\n  var currentHeight = heightAtLineIndex(node, slicedLineIndex);\n  var nextHeight = node.box.height - currentHeight;\n  var current = Object.assign({}, node, {\n    box: _objectSpread(_objectSpread({}, node.box), {}, {\n      height: currentHeight,\n      borderBottomWidth: 0\n    }),\n    style: _objectSpread(_objectSpread({}, node.style), {}, {\n      marginBottom: 0,\n      paddingBottom: 0,\n      borderBottomWidth: 0,\n      borderBottomLeftRadius: 0,\n      borderBottomRightRadius: 0\n    }),\n    lines: node.lines.slice(0, slicedLineIndex)\n  });\n  var next = Object.assign({}, node, {\n    box: _objectSpread(_objectSpread({}, node.box), {}, {\n      top: 0,\n      height: nextHeight,\n      borderTopWidth: 0\n    }),\n    style: _objectSpread(_objectSpread({}, node.style), {}, {\n      marginTop: 0,\n      paddingTop: 0,\n      borderTopWidth: 0,\n      borderTopLeftRadius: 0,\n      borderTopRightRadius: 0\n    }),\n    lines: node.lines.slice(slicedLineIndex)\n  });\n  return [current, next];\n};\n\nvar getTop$1 = function getTop$1(node) {\n  var _node$box3;\n\n  return ((_node$box3 = node.box) === null || _node$box3 === void 0 ? void 0 : _node$box3.top) || 0;\n};\n\nvar hasFixedHeight = function hasFixedHeight(node) {\n  var _node$style3;\n\n  return !isNil((_node$style3 = node.style) === null || _node$style3 === void 0 ? void 0 : _node$style3.height);\n};\n\nvar splitNode = function splitNode(node, height) {\n  if (!node) return [null, null];\n  var nodeTop = getTop$1(node);\n  var current = Object.assign({}, node, {\n    box: _objectSpread(_objectSpread({}, node.box), {}, {\n      borderBottomWidth: 0\n    }),\n    style: _objectSpread(_objectSpread({}, node.style), {}, {\n      marginBottom: 0,\n      paddingBottom: 0,\n      borderBottomWidth: 0,\n      borderBottomLeftRadius: 0,\n      borderBottomRightRadius: 0\n    })\n  });\n  current.style.height = height - nodeTop;\n  var nextHeight = hasFixedHeight(node) ? node.box.height - (height - nodeTop) : null;\n  var next = Object.assign({}, node, {\n    box: _objectSpread(_objectSpread({}, node.box), {}, {\n      top: 0,\n      borderTopWidth: 0\n    }),\n    style: _objectSpread(_objectSpread({}, node.style), {}, {\n      marginTop: 0,\n      paddingTop: 0,\n      borderTopWidth: 0,\n      borderTopLeftRadius: 0,\n      borderTopRightRadius: 0\n    })\n  });\n\n  if (nextHeight) {\n    next.style.height = nextHeight;\n  }\n\n  return [current, next];\n};\n\nvar NON_WRAP_TYPES = [P.Svg, P.Note, P.Image, P.Canvas];\n\nvar getWrap = function getWrap(node) {\n  if (NON_WRAP_TYPES.includes(node.type)) return false;\n  if (!node.props) return true;\n  return 'wrap' in node.props ? node.props.wrap : true;\n};\n\nvar getComputedPadding = function getComputedPadding(node, edge) {\n  var yogaNode = node.yogaNode;\n  return yogaNode ? yogaNode.getComputedPadding(edge) : null;\n};\n/**\n * Get Yoga computed paddings. Zero otherwise\n *\n * @param  node\n * @returns paddings\n */\n\n\nvar getPadding = function getPadding(node) {\n  var style = node.style,\n      box = node.box;\n  var paddingTop = getComputedPadding(node, Yoga.Edge.Top) || (box === null || box === void 0 ? void 0 : box.paddingTop) || (style === null || style === void 0 ? void 0 : style.paddingTop) || 0;\n  var paddingRight = getComputedPadding(node, Yoga.Edge.Right) || (box === null || box === void 0 ? void 0 : box.paddingRight) || (style === null || style === void 0 ? void 0 : style.paddingRight) || 0;\n  var paddingBottom = getComputedPadding(node, Yoga.Edge.Bottom) || (box === null || box === void 0 ? void 0 : box.paddingBottom) || (style === null || style === void 0 ? void 0 : style.paddingBottom) || 0;\n  var paddingLeft = getComputedPadding(node, Yoga.Edge.Left) || (box === null || box === void 0 ? void 0 : box.paddingLeft) || (style === null || style === void 0 ? void 0 : style.paddingLeft) || 0;\n  return {\n    paddingTop: paddingTop,\n    paddingRight: paddingRight,\n    paddingBottom: paddingBottom,\n    paddingLeft: paddingLeft\n  };\n};\n\nvar getWrapArea = function getWrapArea(page) {\n  var _page$style;\n\n  var height = (_page$style = page.style) === null || _page$style === void 0 ? void 0 : _page$style.height;\n\n  var _getPadding = getPadding(page),\n      paddingBottom = _getPadding.paddingBottom;\n\n  return height - paddingBottom;\n};\n\nvar getContentArea = function getContentArea(page) {\n  var _page$style2;\n\n  var height = (_page$style2 = page.style) === null || _page$style2 === void 0 ? void 0 : _page$style2.height;\n\n  var _getPadding2 = getPadding(page),\n      paddingTop = _getPadding2.paddingTop,\n      paddingBottom = _getPadding2.paddingBottom;\n\n  return height - paddingBottom - paddingTop;\n};\n\nvar isString = function isString(value) {\n  return typeof value === 'string';\n};\n\nvar isNumber = function isNumber(value) {\n  return typeof value === 'number';\n};\n\nvar isBoolean = function isBoolean(value) {\n  return typeof value === 'boolean';\n};\n\nvar isFragment = function isFragment(value) {\n  return value && value.type === Symbol.for('react.fragment');\n};\n/**\n * Transforms a react element instance to internal element format.\n *\n * Can return multiple instances in the case of arrays or fragments.\n *\n * @param element - React element\n * @returns Parsed React elements\n */\n\n\nvar createInstances = function createInstances(element) {\n  if (!element) return [];\n\n  if (Array.isArray(element)) {\n    return element.reduce(function (acc, el) {\n      return acc.concat(createInstances(el));\n    }, []);\n  }\n\n  if (isBoolean(element)) {\n    return [];\n  }\n\n  if (isString(element) || isNumber(element)) {\n    return [{\n      type: P.TextInstance,\n      value: \"\".concat(element)\n    }];\n  }\n\n  if (isFragment(element)) {\n    // @ts-expect-error figure out why this is complains\n    return createInstances(element.props.children);\n  }\n\n  if (!isString(element.type)) {\n    // @ts-expect-error figure out why this is complains\n    return createInstances(element.type(element.props));\n  }\n\n  var type = element.type,\n      _element$props = element.props,\n      _element$props$style = _element$props.style,\n      style = _element$props$style === void 0 ? {} : _element$props$style,\n      children = _element$props.children,\n      props = _objectWithoutProperties(_element$props, _excluded);\n\n  var nextChildren = castArray(children).reduce(function (acc, child) {\n    return acc.concat(createInstances(child));\n  }, []);\n  return [{\n    type: type,\n    style: style,\n    props: props,\n    children: nextChildren\n  }];\n};\n\nvar getBreak = function getBreak(node) {\n  return 'break' in node.props ? node.props.break : false;\n};\n\nvar getMinPresenceAhead = function getMinPresenceAhead(node) {\n  return 'minPresenceAhead' in node.props ? node.props.minPresenceAhead : 0;\n};\n\nvar getFurthestEnd = function getFurthestEnd(elements) {\n  return Math.max.apply(Math, _toConsumableArray(elements.map(function (node) {\n    return node.box.top + node.box.height;\n  })));\n};\n\nvar getEndOfMinPresenceAhead = function getEndOfMinPresenceAhead(child) {\n  return child.box.top + child.box.height + child.box.marginBottom + getMinPresenceAhead(child);\n};\n\nvar getEndOfPresence = function getEndOfPresence(child, futureElements) {\n  var afterMinPresenceAhead = getEndOfMinPresenceAhead(child);\n  var endOfFurthestFutureElement = getFurthestEnd(futureElements.filter(function (node) {\n    return !('fixed' in node.props);\n  }));\n  return Math.min(afterMinPresenceAhead, endOfFurthestFutureElement);\n};\n\nvar shouldBreak = function shouldBreak(child, futureElements, height) {\n  if ('fixed' in child.props) return false;\n  var shouldSplit = height < child.box.top + child.box.height;\n  var canWrap = getWrap(child); // Calculate the y coordinate where the desired presence of the child ends\n\n  var endOfPresence = getEndOfPresence(child, futureElements); // If the child is already at the top of the page, breaking won't improve its presence\n  // (as long as react-pdf does not support breaking into differently sized containers)\n\n  var breakingImprovesPresence = child.box.top > child.box.marginTop;\n  return getBreak(child) || shouldSplit && !canWrap || !shouldSplit && endOfPresence > height && breakingImprovesPresence;\n};\n\nvar IGNORABLE_CODEPOINTS = [8232, // LINE_SEPARATOR\n8233 // PARAGRAPH_SEPARATOR\n];\n\nvar buildSubsetForFont = function buildSubsetForFont(font) {\n  return IGNORABLE_CODEPOINTS.reduce(function (acc, codePoint) {\n    if (font && font.hasGlyphForCodePoint && font.hasGlyphForCodePoint(codePoint)) {\n      return acc;\n    }\n\n    return [].concat(_toConsumableArray(acc), [String.fromCharCode(codePoint)]);\n  }, []);\n};\n\nvar ignoreChars = function ignoreChars(fragments) {\n  return fragments.map(function (fragment) {\n    var charSubset = buildSubsetForFont(fragment.attributes.font[0]);\n    var subsetRegex = new RegExp(charSubset.join('|'));\n    return {\n      string: fragment.string.replace(subsetRegex, ''),\n      attributes: fragment.attributes\n    };\n  });\n};\n\nvar PREPROCESSORS = [ignoreChars, embedEmojis];\n\nvar isImage$1 = function isImage$1(node) {\n  return node.type === P.Image;\n};\n\nvar isTextInstance$2 = function isTextInstance$2(node) {\n  return node.type === P.TextInstance;\n};\n/**\n * Get textkit fragments of given node object\n *\n * @param fontStore - Font store\n * @param instance - Node\n * @param parentLink - Parent link\n * @param level - Fragment level\n * @returns Text fragments\n */\n\n\nvar getFragments = function getFragments(fontStore, instance) {\n  var _instance$props2, _instance$props3;\n\n  var parentLink = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var level = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  if (!instance) return [{\n    string: ''\n  }];\n  var fragments = [];\n  var _instance$style = instance.style,\n      _instance$style$color = _instance$style.color,\n      color = _instance$style$color === void 0 ? 'black' : _instance$style$color,\n      _instance$style$direc = _instance$style.direction,\n      direction = _instance$style$direc === void 0 ? 'ltr' : _instance$style$direc,\n      _instance$style$fontF = _instance$style.fontFamily,\n      fontFamily = _instance$style$fontF === void 0 ? 'Helvetica' : _instance$style$fontF,\n      fontWeight = _instance$style.fontWeight,\n      fontStyle = _instance$style.fontStyle,\n      _instance$style$fontS = _instance$style.fontSize,\n      fontSize = _instance$style$fontS === void 0 ? 18 : _instance$style$fontS,\n      textAlign = _instance$style.textAlign,\n      lineHeight = _instance$style.lineHeight,\n      textDecoration = _instance$style.textDecoration,\n      textDecorationColor = _instance$style.textDecorationColor,\n      textDecorationStyle = _instance$style.textDecorationStyle,\n      textTransform = _instance$style.textTransform,\n      letterSpacing = _instance$style.letterSpacing,\n      textIndent = _instance$style.textIndent,\n      opacity = _instance$style.opacity,\n      verticalAlign = _instance$style.verticalAlign;\n  var fontFamilies = typeof fontFamily === 'string' ? [fontFamily] : _toConsumableArray(fontFamily || []); // Fallback font\n\n  fontFamilies.push('Helvetica');\n  var font = fontFamilies.map(function (fontFamilyName) {\n    var opts = {\n      fontFamily: fontFamilyName,\n      fontWeight: fontWeight,\n      fontStyle: fontStyle\n    };\n    var obj = fontStore.getFont(opts);\n    return obj === null || obj === void 0 ? void 0 : obj.data;\n  }); // Don't pass main background color to textkit. Will be rendered by the render package instead\n\n  var backgroundColor = level === 0 ? null : instance.style.backgroundColor;\n  var attributes = {\n    font: font,\n    color: color,\n    opacity: opacity,\n    fontSize: fontSize,\n    lineHeight: lineHeight,\n    direction: direction,\n    verticalAlign: verticalAlign,\n    backgroundColor: backgroundColor,\n    indent: textIndent,\n    characterSpacing: letterSpacing,\n    strikeStyle: textDecorationStyle,\n    underlineStyle: textDecorationStyle,\n    underline: textDecoration === 'underline' || textDecoration === 'underline line-through' || textDecoration === 'line-through underline',\n    strike: textDecoration === 'line-through' || textDecoration === 'underline line-through' || textDecoration === 'line-through underline',\n    strikeColor: textDecorationColor || color,\n    underlineColor: textDecorationColor || color,\n    // @ts-expect-error allow this props access\n    link: parentLink || ((_instance$props2 = instance.props) === null || _instance$props2 === void 0 ? void 0 : _instance$props2.src) || ((_instance$props3 = instance.props) === null || _instance$props3 === void 0 ? void 0 : _instance$props3.href),\n    align: textAlign || (direction === 'rtl' ? 'right' : 'left')\n  };\n\n  for (var i = 0; i < instance.children.length; i += 1) {\n    var child = instance.children[i];\n\n    if (isImage$1(child)) {\n      fragments.push({\n        string: String.fromCharCode(0xfffc),\n        attributes: _objectSpread(_objectSpread({}, attributes), {}, {\n          attachment: {\n            width: child.style.width || fontSize,\n            height: child.style.height || fontSize,\n            image: child.image.data\n          }\n        })\n      });\n    } else if (isTextInstance$2(child)) {\n      fragments.push({\n        string: transformText(child.value, textTransform),\n        attributes: attributes\n      });\n    } else if (child) {\n      var _fragments;\n\n      (_fragments = fragments).push.apply(_fragments, _toConsumableArray(getFragments(fontStore, child, attributes.link, level + 1)));\n    }\n  }\n\n  for (var _i = 0; _i < PREPROCESSORS.length; _i += 1) {\n    var preprocessor = PREPROCESSORS[_i];\n    fragments = preprocessor(fragments);\n  }\n\n  return fragments;\n};\n/**\n * Get textkit attributed string from text node\n *\n * @param fontStore - Font store\n * @param instance Node\n * @returns Attributed string\n */\n\n\nvar getAttributedString = function getAttributedString(fontStore, instance) {\n  var fragments = getFragments(fontStore, instance);\n  return fromFragments(fragments);\n};\n\nvar engines = {\n  bidi: bidi,\n  linebreaker: linebreaker,\n  justification: justification,\n  textDecoration: textDecoration,\n  scriptItemizer: scriptItemizer,\n  wordHyphenation: wordHyphenation,\n  fontSubstitution: fontSubstitution\n};\nvar engine = layoutEngine(engines);\n\nvar getMaxLines = function getMaxLines(node) {\n  var _node$style4;\n\n  return (_node$style4 = node.style) === null || _node$style4 === void 0 ? void 0 : _node$style4.maxLines;\n};\n\nvar getTextOverflow = function getTextOverflow(node) {\n  var _node$style5;\n\n  return (_node$style5 = node.style) === null || _node$style5 === void 0 ? void 0 : _node$style5.textOverflow;\n};\n/**\n * Get layout container for specific text node\n *\n * @param {number} width\n * @param {number} height\n * @param {Object} node\n * @returns {Object} layout container\n */\n\n\nvar getContainer = function getContainer(width, height, node) {\n  var maxLines = getMaxLines(node);\n  var textOverflow = getTextOverflow(node);\n  return {\n    x: 0,\n    y: 0,\n    width: width,\n    maxLines: maxLines,\n    height: height || Infinity,\n    truncateMode: textOverflow\n  };\n};\n/**\n * Get text layout options for specific text node\n *\n * @param {Object} node instance\n * @returns {Object} layout options\n */\n\n\nvar getLayoutOptions = function getLayoutOptions(fontStore, node) {\n  return {\n    hyphenationPenalty: node.props.hyphenationPenalty,\n    shrinkWhitespaceFactor: {\n      before: -0.5,\n      after: -0.5\n    },\n    hyphenationCallback: node.props.hyphenationCallback || (fontStore === null || fontStore === void 0 ? void 0 : fontStore.getHyphenationCallback()) || null\n  };\n};\n/**\n * Get text lines for given node\n *\n * @param node - Node\n * @param width - Container width\n * @param height - Container height\n * @param fontStore - Font store\n * @returns Layout lines\n */\n\n\nvar layoutText = function layoutText(node, width, height, fontStore) {\n  var attributedString = getAttributedString(fontStore, node);\n  var container = getContainer(width, height, node);\n  var options = getLayoutOptions(fontStore, node);\n  var lines = engine(attributedString, container, options);\n  return lines.reduce(function (acc, line) {\n    return [].concat(_toConsumableArray(acc), _toConsumableArray(line));\n  }, []);\n};\n\nvar isSvg$2 = function isSvg$2(node) {\n  return node.type === P.Svg;\n};\n\nvar isText$4 = function isText$4(node) {\n  return node.type === P.Text;\n};\n\nvar shouldIterate = function shouldIterate(node) {\n  return !isSvg$2(node) && !isText$4(node);\n};\n\nvar shouldLayoutText = function shouldLayoutText(node) {\n  return isText$4(node) && !node.lines;\n};\n/**\n * Performs text layout on text node if wasn't calculated before.\n * Text layout is usually performed on Yoga's layout process (via setMeasureFunc),\n * but we need to layout those nodes with fixed width and height.\n *\n * @param node\n * @returns Layout node\n */\n\n\nvar resolveTextLayout = function resolveTextLayout(node, fontStore) {\n  if (shouldLayoutText(node)) {\n    var width = node.box.width - (node.box.paddingRight + node.box.paddingLeft);\n    var height = node.box.height - (node.box.paddingTop + node.box.paddingBottom);\n    node.lines = layoutText(node, width, height, fontStore);\n  }\n\n  if (shouldIterate(node)) {\n    if (!node.children) return node;\n\n    var mapChild = function mapChild(child) {\n      return resolveTextLayout(child, fontStore);\n    };\n\n    var children = node.children.map(mapChild);\n    return Object.assign({}, node, {\n      children: children\n    });\n  }\n\n  return node;\n};\n\nvar BASE_INHERITABLE_PROPERTIES = ['color', 'fontFamily', 'fontSize', 'fontStyle', 'fontWeight', 'letterSpacing', 'opacity', 'textDecoration', 'textTransform', 'lineHeight', 'textAlign', 'visibility', 'wordSpacing'];\nvar TEXT_INHERITABLE_PROPERTIES = [].concat(BASE_INHERITABLE_PROPERTIES, ['backgroundColor']);\n\nvar isType$2 = function isType$2(type) {\n  return function (node) {\n    return node.type === type;\n  };\n};\n\nvar isSvg$1 = isType$2(P.Svg);\nvar isText$3 = isType$2(P.Text); // Merge style values\n\nvar mergeValues = function mergeValues(styleName, value, inheritedValue) {\n  switch (styleName) {\n    case 'textDecoration':\n      {\n        // merge not none and not false textDecoration values to one rule\n        return [inheritedValue, value].filter(function (v) {\n          return v && v !== 'none';\n        }).join(' ');\n      }\n\n    default:\n      return value;\n  }\n}; // Merge inherited and node styles\n\n\nvar merge = function merge(inheritedStyles, style) {\n  var mergedStyles = _objectSpread({}, inheritedStyles);\n\n  Object.entries(style).forEach(function (_ref7) {\n    var _ref8 = _slicedToArray(_ref7, 2),\n        styleName = _ref8[0],\n        value = _ref8[1];\n\n    mergedStyles[styleName] = mergeValues(styleName, value, inheritedStyles[styleName]);\n  });\n  return mergedStyles;\n};\n/**\n * Merges styles with node\n *\n * @param inheritedStyles - Style object\n * @returns Merge styles function\n */\n\n\nvar mergeStyles = function mergeStyles(inheritedStyles) {\n  return function (node) {\n    var style = merge(inheritedStyles, node.style || {});\n    return Object.assign({}, node, {\n      style: style\n    });\n  };\n};\n/**\n * Inherit style values from the root to the leafs\n *\n * @param node - Document root\n * @returns Document root with inheritance\n *\n */\n\n\nvar resolveInheritance = function resolveInheritance(node) {\n  if (isSvg$1(node)) return node;\n  if (!('children' in node)) return node;\n  var inheritableProperties = isText$3(node) ? TEXT_INHERITABLE_PROPERTIES : BASE_INHERITABLE_PROPERTIES;\n  var inheritStyles = pick(inheritableProperties, node.style || {});\n  var resolveChild = compose(resolveInheritance, mergeStyles(inheritStyles));\n  var children = node.children.map(resolveChild);\n  return Object.assign({}, node, {\n    children: children\n  });\n};\n\nvar getComputedMargin = function getComputedMargin(node, edge) {\n  var yogaNode = node.yogaNode;\n  return yogaNode ? yogaNode.getComputedMargin(edge) : null;\n};\n/**\n * Get Yoga computed magins. Zero otherwise\n *\n * @param node\n * @returns Margins\n */\n\n\nvar getMargin = function getMargin(node) {\n  var style = node.style,\n      box = node.box;\n  var marginTop = getComputedMargin(node, Yoga.Edge.Top) || (box === null || box === void 0 ? void 0 : box.marginTop) || (style === null || style === void 0 ? void 0 : style.marginTop) || 0;\n  var marginRight = getComputedMargin(node, Yoga.Edge.Right) || (box === null || box === void 0 ? void 0 : box.marginRight) || (style === null || style === void 0 ? void 0 : style.marginRight) || 0;\n  var marginBottom = getComputedMargin(node, Yoga.Edge.Bottom) || (box === null || box === void 0 ? void 0 : box.marginBottom) || (style === null || style === void 0 ? void 0 : style.marginBottom) || 0;\n  var marginLeft = getComputedMargin(node, Yoga.Edge.Left) || (box === null || box === void 0 ? void 0 : box.marginLeft) || (style === null || style === void 0 ? void 0 : style.marginLeft) || 0;\n  return {\n    marginTop: marginTop,\n    marginRight: marginRight,\n    marginBottom: marginBottom,\n    marginLeft: marginLeft\n  };\n};\n/**\n * Get Yoga computed position. Zero otherwise\n *\n * @param node\n * @returns Position\n */\n\n\nvar getPosition = function getPosition(node) {\n  var yogaNode = node.yogaNode;\n  return {\n    top: (yogaNode === null || yogaNode === void 0 ? void 0 : yogaNode.getComputedTop()) || 0,\n    right: (yogaNode === null || yogaNode === void 0 ? void 0 : yogaNode.getComputedRight()) || 0,\n    bottom: (yogaNode === null || yogaNode === void 0 ? void 0 : yogaNode.getComputedBottom()) || 0,\n    left: (yogaNode === null || yogaNode === void 0 ? void 0 : yogaNode.getComputedLeft()) || 0\n  };\n};\n\nvar DEFAULT_DIMENSION = {\n  width: 0,\n  height: 0\n};\n/**\n * Get Yoga computed dimensions. Zero otherwise\n *\n * @param node\n * @returns Dimensions\n */\n\nvar getDimension = function getDimension(node) {\n  var yogaNode = node.yogaNode;\n  if (!yogaNode) return DEFAULT_DIMENSION;\n  return {\n    width: yogaNode.getComputedWidth(),\n    height: yogaNode.getComputedHeight()\n  };\n};\n\nvar getComputedBorder = function getComputedBorder(yogaNode, edge) {\n  return yogaNode ? yogaNode.getComputedBorder(edge) : 0;\n};\n/**\n * Get Yoga computed border width. Zero otherwise\n *\n * @param node\n * @returns Border widths\n */\n\n\nvar getBorderWidth = function getBorderWidth(node) {\n  var yogaNode = node.yogaNode;\n  return {\n    borderTopWidth: getComputedBorder(yogaNode, Yoga.Edge.Top),\n    borderRightWidth: getComputedBorder(yogaNode, Yoga.Edge.Right),\n    borderBottomWidth: getComputedBorder(yogaNode, Yoga.Edge.Bottom),\n    borderLeftWidth: getComputedBorder(yogaNode, Yoga.Edge.Left)\n  };\n};\n/**\n * Set display attribute to node's Yoga instance\n *\n * @param value - Display\n * @returns Node instance wrapper\n */\n\n\nvar setDisplay = function setDisplay(value) {\n  return function (node) {\n    var yogaNode = node.yogaNode;\n\n    if (yogaNode) {\n      yogaNode.setDisplay(value === 'none' ? Yoga.Display.None : Yoga.Display.Flex);\n    }\n\n    return node;\n  };\n};\n\nvar OVERFLOW = {\n  hidden: Yoga.Overflow.Hidden,\n  scroll: Yoga.Overflow.Scroll\n};\n/**\n * Set overflow attribute to node's Yoga instance\n *\n * @param value - Overflow value\n * @returns Node instance wrapper\n */\n\nvar setOverflow = function setOverflow(value) {\n  return function (node) {\n    var yogaNode = node.yogaNode;\n\n    if (!isNil(value) && yogaNode) {\n      var overflow = OVERFLOW[value] || Yoga.Overflow.Visible;\n      yogaNode.setOverflow(overflow);\n    }\n\n    return node;\n  };\n};\n\nvar FLEX_WRAP = {\n  wrap: Yoga.Wrap.Wrap,\n  'wrap-reverse': Yoga.Wrap.WrapReverse\n};\n/**\n * Set flex wrap attribute to node's Yoga instance\n *\n * @param value - Flex wrap value\n * @returns Node instance wrapper\n */\n\nvar setFlexWrap = function setFlexWrap(value) {\n  return function (node) {\n    var yogaNode = node.yogaNode;\n\n    if (yogaNode) {\n      var flexWrap = FLEX_WRAP[value] || Yoga.Wrap.NoWrap;\n      yogaNode.setFlexWrap(flexWrap);\n    }\n\n    return node;\n  };\n};\n/**\n * Set generic yoga attribute to node's Yoga instance, handing `auto`, edges and percentage cases\n *\n * @param attr - Property\n * @param edge - Edge\n * @returns Node instance wrapper\n */\n\n\nvar setYogaValue = function setYogaValue(attr, edge) {\n  return function (value) {\n    return function (node) {\n      var yogaNode = node.yogaNode;\n\n      if (!isNil(value) && yogaNode) {\n        var hasEdge = !isNil(edge);\n        var fixedMethod = \"set\".concat(upperFirst(attr));\n        var autoMethod = \"\".concat(fixedMethod, \"Auto\");\n        var percentMethod = \"\".concat(fixedMethod, \"Percent\");\n        var percent = matchPercent(value);\n\n        if (percent && !yogaNode[percentMethod]) {\n          throw new Error(\"You can't pass percentage values to \".concat(attr, \" property\"));\n        }\n\n        if (percent) {\n          if (hasEdge) {\n            var _yogaNode$percentMeth;\n\n            (_yogaNode$percentMeth = yogaNode[percentMethod]) === null || _yogaNode$percentMeth === void 0 ? void 0 : _yogaNode$percentMeth.call(yogaNode, edge, percent.value);\n          } else {\n            var _yogaNode$percentMeth2;\n\n            (_yogaNode$percentMeth2 = yogaNode[percentMethod]) === null || _yogaNode$percentMeth2 === void 0 ? void 0 : _yogaNode$percentMeth2.call(yogaNode, percent.value);\n          }\n        } else if (value === 'auto') {\n          if (hasEdge) {\n            var _yogaNode$autoMethod;\n\n            (_yogaNode$autoMethod = yogaNode[autoMethod]) === null || _yogaNode$autoMethod === void 0 ? void 0 : _yogaNode$autoMethod.call(yogaNode, edge);\n          } else {\n            var _yogaNode$autoMethod2;\n\n            (_yogaNode$autoMethod2 = yogaNode[autoMethod]) === null || _yogaNode$autoMethod2 === void 0 ? void 0 : _yogaNode$autoMethod2.call(yogaNode);\n          }\n        } else if (hasEdge) {\n          var _yogaNode$fixedMethod;\n\n          (_yogaNode$fixedMethod = yogaNode[fixedMethod]) === null || _yogaNode$fixedMethod === void 0 ? void 0 : _yogaNode$fixedMethod.call(yogaNode, edge, value);\n        } else {\n          var _yogaNode$fixedMethod2;\n\n          (_yogaNode$fixedMethod2 = yogaNode[fixedMethod]) === null || _yogaNode$fixedMethod2 === void 0 ? void 0 : _yogaNode$fixedMethod2.call(yogaNode, value);\n        }\n      }\n\n      return node;\n    };\n  };\n};\n/**\n * Set flex grow attribute to node's Yoga instance\n *\n * @param  value - Flex grow value\n * @returns Node instance wrapper\n */\n\n\nvar setFlexGrow = function setFlexGrow(value) {\n  return function (node) {\n    return setYogaValue('flexGrow')(value || 0)(node);\n  };\n};\n/**\n * Set flex basis attribute to node's Yoga instance\n *\n * @param flex - Basis value\n * @param node - Node instance\n * @returns Node instance\n */\n\n\nvar setFlexBasis = setYogaValue('flexBasis');\nvar ALIGN = {\n  'flex-start': Yoga.Align.FlexStart,\n  center: Yoga.Align.Center,\n  'flex-end': Yoga.Align.FlexEnd,\n  stretch: Yoga.Align.Stretch,\n  baseline: Yoga.Align.Baseline,\n  'space-between': Yoga.Align.SpaceBetween,\n  'space-around': Yoga.Align.SpaceAround,\n  'space-evenly': Yoga.Align.SpaceEvenly\n};\n/**\n * Set generic align attribute to node's Yoga instance\n *\n * @param attr - Specific align property\n * @param value - Specific align value\n * @param node - Node\n * @returns Node\n */\n\nvar setAlign = function setAlign(attr) {\n  return function (value) {\n    return function (node) {\n      var yogaNode = node.yogaNode;\n      var defaultValue = attr === 'items' ? Yoga.Align.Stretch : Yoga.Align.Auto;\n\n      if (yogaNode) {\n        var align = ALIGN[value] || defaultValue;\n        yogaNode[\"setAlign\".concat(upperFirst(attr))](align);\n      }\n\n      return node;\n    };\n  };\n};\n/**\n * Set align self attribute to node's Yoga instance\n *\n * @param align - Value\n * @param node - Node instance\n * @returns Node instance\n */\n\n\nvar setAlignSelf = setAlign('self');\n/**\n * Set align items attribute to node's Yoga instance\n *\n * @param align - Value\n * @param node - Node instance\n * @returns Node instance\n */\n\nvar setAlignItems = setAlign('items');\n/**\n * Set flex shrink attribute to node's Yoga instance\n *\n * @param value - Flex shrink value\n * @returns Node instance wrapper\n */\n\nvar setFlexShrink = function setFlexShrink(value) {\n  return function (node) {\n    return setYogaValue('flexShrink')(value || 1)(node);\n  };\n};\n/**\n * Set aspect ratio attribute to node's Yoga instance\n *\n * @param value - Ratio\n * @returns Node instance\n */\n\n\nvar setAspectRatio = function setAspectRatio(value) {\n  return function (node) {\n    var yogaNode = node.yogaNode;\n\n    if (!isNil(value) && yogaNode) {\n      yogaNode.setAspectRatio(value);\n    }\n\n    return node;\n  };\n};\n/**\n * Set align content attribute to node's Yoga instance\n *\n * @param align - Value\n * @param node - Instance\n * @returns Node instance\n */\n\n\nvar setAlignContent = setAlign('content');\nvar POSITION = {\n  absolute: Yoga.PositionType.Absolute,\n  relative: Yoga.PositionType.Relative,\n  static: Yoga.PositionType.Static\n};\n/**\n * Set position type attribute to node's Yoga instance\n *\n * @param value - Position position type\n * @returns Node instance\n */\n\nvar setPositionType = function setPositionType(value) {\n  return function (node) {\n    var yogaNode = node.yogaNode;\n\n    if (!isNil(value) && yogaNode) {\n      yogaNode.setPositionType(POSITION[value]);\n    }\n\n    return node;\n  };\n};\n\nvar FLEX_DIRECTIONS = {\n  row: Yoga.FlexDirection.Row,\n  'row-reverse': Yoga.FlexDirection.RowReverse,\n  'column-reverse': Yoga.FlexDirection.ColumnReverse\n};\n/**\n * Set flex direction attribute to node's Yoga instance\n *\n * @param value - Flex direction value\n * @returns Node instance wrapper\n */\n\nvar setFlexDirection = function setFlexDirection(value) {\n  return function (node) {\n    var yogaNode = node.yogaNode;\n\n    if (yogaNode) {\n      var flexDirection = FLEX_DIRECTIONS[value] || Yoga.FlexDirection.Column;\n      yogaNode.setFlexDirection(flexDirection);\n    }\n\n    return node;\n  };\n};\n\nvar JUSTIFY_CONTENT = {\n  center: Yoga.Justify.Center,\n  'flex-end': Yoga.Justify.FlexEnd,\n  'space-between': Yoga.Justify.SpaceBetween,\n  'space-around': Yoga.Justify.SpaceAround,\n  'space-evenly': Yoga.Justify.SpaceEvenly\n};\n/**\n * Set justify content attribute to node's Yoga instance\n *\n * @param value - Justify content value\n * @returns Node instance wrapper\n */\n\nvar setJustifyContent = function setJustifyContent(value) {\n  return function (node) {\n    var yogaNode = node.yogaNode;\n\n    if (!isNil(value) && yogaNode) {\n      var justifyContent = JUSTIFY_CONTENT[value] || Yoga.Justify.FlexStart;\n      yogaNode.setJustifyContent(justifyContent);\n    }\n\n    return node;\n  };\n};\n/**\n * Set margin top attribute to node's Yoga instance\n *\n * @param margin - Margin top\n * @param node - Node instance\n * @returns Node instance\n */\n\n\nvar setMarginTop = setYogaValue('margin', Yoga.Edge.Top);\n/**\n * Set margin right attribute to node's Yoga instance\n *\n * @param margin - Margin right\n * @param node - Node instance\n * @returns Node instance\n */\n\nvar setMarginRight = setYogaValue('margin', Yoga.Edge.Right);\n/**\n * Set margin bottom attribute to node's Yoga instance\n *\n * @param margin - Margin bottom\n * @param node - Node instance\n * @returns Node instance\n */\n\nvar setMarginBottom = setYogaValue('margin', Yoga.Edge.Bottom);\n/**\n * Set margin left attribute to node's Yoga instance\n *\n * @param margin - Margin left\n * @param node - Node instance\n * @returns Node instance\n */\n\nvar setMarginLeft = setYogaValue('margin', Yoga.Edge.Left);\n/**\n * Set padding top attribute to node's Yoga instance\n *\n * @param padding - Padding top\n * @param node - Node instance\n * @returns Node instance\n */\n\nvar setPaddingTop = setYogaValue('padding', Yoga.Edge.Top);\n/**\n * Set padding right attribute to node's Yoga instance\n *\n * @param padding - Padding right\n * @param node - Node instance\n * @returns Node instance\n */\n\nvar setPaddingRight = setYogaValue('padding', Yoga.Edge.Right);\n/**\n * Set padding bottom attribute to node's Yoga instance\n *\n * @param padding - Padding bottom\n * @param node Node instance\n * @returns Node instance\n */\n\nvar setPaddingBottom = setYogaValue('padding', Yoga.Edge.Bottom);\n/**\n * Set padding left attribute to node's Yoga instance\n *\n * @param padding - Padding left\n * @param node - Node instance\n * @returns Node instance\n */\n\nvar setPaddingLeft = setYogaValue('padding', Yoga.Edge.Left);\n/**\n * Set border top attribute to node's Yoga instance\n *\n * @param border - Border top width\n * @param node - Node instance\n * @returns Node instance\n */\n\nvar setBorderTop = setYogaValue('border', Yoga.Edge.Top);\n/**\n * Set border right attribute to node's Yoga instance\n *\n * @param border - Border right width\n * @param node - Node instance\n * @returns Node instance\n */\n\nvar setBorderRight = setYogaValue('border', Yoga.Edge.Right);\n/**\n * Set border bottom attribute to node's Yoga instance\n *\n * @param border - Border bottom width\n * @param node - Node instance\n * @returns Node instance\n */\n\nvar setBorderBottom = setYogaValue('border', Yoga.Edge.Bottom);\n/**\n * Set border left attribute to node's Yoga instance\n *\n * @param border - Border left width\n * @param node - Node instance\n * @returns Node instance\n */\n\nvar setBorderLeft = setYogaValue('border', Yoga.Edge.Left);\n/**\n * Set position top attribute to node's Yoga instance\n *\n * @param position - Position top\n * @param node - Node instance\n * @returns Node instance\n */\n\nvar setPositionTop = setYogaValue('position', Yoga.Edge.Top);\n/**\n * Set position right attribute to node's Yoga instance\n *\n * @param position - Position right\n * @param node - Node instance\n * @returns Node instance\n */\n\nvar setPositionRight = setYogaValue('position', Yoga.Edge.Right);\n/**\n * Set position bottom attribute to node's Yoga instance\n *\n * @param position - Position bottom\n * @param node - Node instance\n * @returns Node instance\n */\n\nvar setPositionBottom = setYogaValue('position', Yoga.Edge.Bottom);\n/**\n * Set position left attribute to node's Yoga instance\n *\n * @param position - Position left\n * @param node - Node instance\n * @returns Node instance\n */\n\nvar setPositionLeft = setYogaValue('position', Yoga.Edge.Left);\n/**\n * Set width to node's Yoga instance\n *\n * @param width - Width\n * @param node - Node instance\n * @returns Node instance\n */\n\nvar setWidth = setYogaValue('width');\n/**\n * Set min width to node's Yoga instance\n *\n * @param min - Width\n * @param node - Node instance\n * @returns Node instance\n */\n\nvar setMinWidth = setYogaValue('minWidth');\n/**\n * Set max width to node's Yoga instance\n *\n * @param max - Width\n * @param node - Node instance\n * @returns Node instance\n */\n\nvar setMaxWidth = setYogaValue('maxWidth');\n/**\n * Set height to node's Yoga instance\n *\n * @param height - Height\n * @param node - Node instance\n * @returns Node instance\n */\n\nvar setHeight = setYogaValue('height');\n/**\n * Set min height to node's Yoga instance\n *\n * @param min - Height\n * @param node - Node instance\n * @returns Node instance\n */\n\nvar setMinHeight = setYogaValue('minHeight');\n/**\n * Set max height to node's Yoga instance\n *\n * @param max - Height\n * @param node - Node instance\n * @returns Node instance\n */\n\nvar setMaxHeight = setYogaValue('maxHeight');\n/**\n * Set rowGap value to node's Yoga instance\n *\n * @param value - Gap value\n * @returns Node instance wrapper\n */\n\nvar setRowGap = setYogaValue('gap', Yoga.Gutter.Row);\n/**\n * Set columnGap value to node's Yoga instance\n *\n * @param value - Gap value\n * @returns Node instance wrapper\n */\n\nvar setColumnGap = setYogaValue('gap', Yoga.Gutter.Column);\n\nvar getAspectRatio = function getAspectRatio(viewbox) {\n  if (!viewbox) return null;\n  if (typeof viewbox === 'string') return null;\n  return (viewbox.maxX - viewbox.minX) / (viewbox.maxY - viewbox.minY);\n};\n/**\n * Yoga svg measure function\n *\n * @param page\n * @param node\n * @returns Measure svg\n */\n\n\nvar measureCanvas$1 = function measureCanvas$1(page, node) {\n  return function (width, widthMode, height, heightMode) {\n    var aspectRatio = getAspectRatio(node.props.viewBox) || 1;\n\n    if (widthMode === Yoga.MeasureMode.Exactly || widthMode === Yoga.MeasureMode.AtMost) {\n      return {\n        width: width,\n        height: width / aspectRatio\n      };\n    }\n\n    if (heightMode === Yoga.MeasureMode.Exactly) {\n      return {\n        width: height * aspectRatio\n      };\n    }\n\n    return {};\n  };\n};\n/**\n * Get lines width (if any)\n *\n * @param node\n * @returns Lines width\n */\n\n\nvar linesWidth = function linesWidth(node) {\n  if (!node.lines) return 0;\n  return Math.max.apply(Math, [0].concat(_toConsumableArray(node.lines.map(function (line) {\n    return line.xAdvance;\n  }))));\n};\n/**\n * Get lines height (if any)\n *\n * @param node\n * @returns Lines height\n */\n\n\nvar linesHeight = function linesHeight(node) {\n  if (!node.lines) return -1;\n  return node.lines.reduce(function (acc, line) {\n    return acc + line.box.height;\n  }, 0);\n};\n\nvar ALIGNMENT_FACTORS = {\n  center: 0.5,\n  right: 1\n};\n/**\n * Yoga text measure function\n *\n * @param page\n * @param node\n * @param fontStore\n * @returns {MeasureText} measure text function\n */\n\nvar measureText = function measureText(page, node, fontStore) {\n  return function (width, widthMode, height) {\n    if (widthMode === Yoga.MeasureMode.Exactly) {\n      if (!node.lines) node.lines = layoutText(node, width, height, fontStore);\n      return {\n        height: linesHeight(node)\n      };\n    }\n\n    if (widthMode === Yoga.MeasureMode.AtMost) {\n      var _node$style6;\n\n      var alignFactor = ALIGNMENT_FACTORS[(_node$style6 = node.style) === null || _node$style6 === void 0 ? void 0 : _node$style6.textAlign] || 0;\n\n      if (!node.lines) {\n        node.lines = layoutText(node, width, height, fontStore);\n        node.alignOffset = (width - linesWidth(node)) * alignFactor; // Compensate align in variable width containers\n      }\n\n      return {\n        height: linesHeight(node),\n        width: Math.min(width, linesWidth(node))\n      };\n    }\n\n    return {};\n  };\n};\n/**\n * Get image ratio\n *\n * @param node - Image node\n * @returns Image ratio\n */\n\n\nvar getRatio = function getRatio(node) {\n  var _node$image;\n\n  return (_node$image = node.image) !== null && _node$image !== void 0 && _node$image.data ? node.image.width / node.image.height : 1;\n};\n/**\n * Checks if page has auto height\n *\n * @param page\n * @returns Is page height auto\n */\n\n\nvar isHeightAuto = function isHeightAuto(page) {\n  var _page$box3;\n\n  return isNil((_page$box3 = page.box) === null || _page$box3 === void 0 ? void 0 : _page$box3.height);\n};\n\nvar SAFETY_HEIGHT$1 = 10;\n/**\n * Yoga image measure function\n *\n * @param page - Page\n * @param node - Node\n * @returns Measure image\n */\n\nvar measureImage = function measureImage(page, node) {\n  return function (width, widthMode, height, heightMode) {\n    var _page$box4;\n\n    var imageRatio = getRatio(node);\n    var imageMargin = getMargin(node);\n    var pagePadding = getPadding(page); // TODO: Check image percentage margins\n\n    var pageArea = isHeightAuto(page) ? Infinity : (((_page$box4 = page.box) === null || _page$box4 === void 0 ? void 0 : _page$box4.height) || 0) - pagePadding.paddingTop - pagePadding.paddingBottom - imageMargin.marginTop - imageMargin.marginBottom - SAFETY_HEIGHT$1; // Skip measure if image data not present yet\n\n    if (!node.image) return {\n      width: 0,\n      height: 0\n    };\n\n    if (widthMode === Yoga.MeasureMode.Exactly && heightMode === Yoga.MeasureMode.Undefined) {\n      var scaledHeight = width / imageRatio;\n      return {\n        height: Math.min(pageArea, scaledHeight)\n      };\n    }\n\n    if (heightMode === Yoga.MeasureMode.Exactly && (widthMode === Yoga.MeasureMode.AtMost || widthMode === Yoga.MeasureMode.Undefined)) {\n      return {\n        width: Math.min(height * imageRatio, width)\n      };\n    }\n\n    if (widthMode === Yoga.MeasureMode.Exactly && heightMode === Yoga.MeasureMode.AtMost) {\n      var _scaledHeight = width / imageRatio;\n\n      return {\n        height: Math.min(height, pageArea, _scaledHeight)\n      };\n    }\n\n    if (widthMode === Yoga.MeasureMode.AtMost && heightMode === Yoga.MeasureMode.AtMost) {\n      if (imageRatio > 1) {\n        return {\n          width: width,\n          height: Math.min(width / imageRatio, height)\n        };\n      }\n\n      return {\n        height: height,\n        width: Math.min(height * imageRatio, width)\n      };\n    }\n\n    return {\n      height: height,\n      width: width\n    };\n  };\n};\n\nvar SAFETY_HEIGHT = 10;\n\nvar getMax = function getMax(values) {\n  return Math.max.apply(Math, [-Infinity].concat(_toConsumableArray(values)));\n};\n/**\n * Helper object to predict canvas size\n * TODO: Implement remaining functions (as close as possible);\n */\n\n\nvar measureCtx = function measureCtx() {\n  var ctx = {};\n  var points = [];\n\n  var nil = function nil() {\n    return ctx;\n  };\n\n  var addPoint = function addPoint(x, y) {\n    return points.push([x, y]);\n  };\n\n  var moveTo = function moveTo(x, y) {\n    addPoint(x, y);\n    return ctx;\n  };\n\n  var rect = function rect(x, y, w, h) {\n    addPoint(x, y);\n    addPoint(x + w, y);\n    addPoint(x, y + h);\n    addPoint(x + w, y + h);\n    return ctx;\n  };\n\n  var ellipse = function ellipse(x, y, rx, ry) {\n    ry = ry || rx;\n    addPoint(x - rx, y - ry);\n    addPoint(x + rx, y - ry);\n    addPoint(x + rx, y + ry);\n    addPoint(x - rx, y + ry);\n    return ctx;\n  };\n\n  var polygon = function polygon() {\n    points.push.apply(points, arguments);\n    return ctx;\n  }; // Change dimensions\n\n\n  ctx.rect = rect;\n  ctx.moveTo = moveTo;\n  ctx.lineTo = moveTo;\n  ctx.circle = ellipse;\n  ctx.polygon = polygon;\n  ctx.ellipse = ellipse;\n  ctx.roundedRect = rect; // To be implemented\n\n  ctx.text = nil;\n  ctx.path = nil;\n  ctx.lineWidth = nil;\n  ctx.bezierCurveTo = nil;\n  ctx.quadraticCurveTo = nil;\n  ctx.scale = nil;\n  ctx.rotate = nil;\n  ctx.translate = nil; // These don't change dimensions\n\n  ctx.dash = nil;\n  ctx.clip = nil;\n  ctx.save = nil;\n  ctx.fill = nil;\n  ctx.font = nil;\n  ctx.stroke = nil;\n  ctx.lineCap = nil;\n  ctx.opacity = nil;\n  ctx.restore = nil;\n  ctx.lineJoin = nil;\n  ctx.fontSize = nil;\n  ctx.fillColor = nil;\n  ctx.miterLimit = nil;\n  ctx.strokeColor = nil;\n  ctx.fillOpacity = nil;\n  ctx.strokeOpacity = nil;\n  ctx.linearGradient = nil;\n  ctx.radialGradient = nil;\n\n  ctx.getWidth = function () {\n    return getMax(points.map(function (p) {\n      return p[0];\n    }));\n  };\n\n  ctx.getHeight = function () {\n    return getMax(points.map(function (p) {\n      return p[1];\n    }));\n  };\n\n  return ctx;\n};\n/**\n * @typedef {Function} MeasureCanvas\n * @returns {{ width: number, height: number }} canvas width and height\n */\n\n/**\n * Yoga canvas measure function\n *\n * @param {Object} page\n * @param {Object} node\n * @returns {MeasureCanvas} measure canvas\n */\n\n\nvar measureCanvas = function measureCanvas(page, node) {\n  return function () {\n    var _page$box5;\n\n    var imageMargin = getMargin(node);\n    var pagePadding = getPadding(page); // TODO: Check image percentage margins\n\n    var pageArea = isHeightAuto(page) ? Infinity : (((_page$box5 = page.box) === null || _page$box5 === void 0 ? void 0 : _page$box5.height) || 0) - pagePadding.paddingTop - pagePadding.paddingBottom - imageMargin.marginTop - imageMargin.marginBottom - SAFETY_HEIGHT;\n    var ctx = measureCtx();\n    node.props.paint(ctx);\n    var width = ctx.getWidth();\n    var height = Math.min(pageArea, ctx.getHeight());\n    return {\n      width: width,\n      height: height\n    };\n  };\n};\n\nvar isType$1 = function isType$1(type) {\n  return function (node) {\n    return node.type === type;\n  };\n};\n\nvar isSvg = isType$1(P.Svg);\nvar isText$2 = isType$1(P.Text);\nvar isNote = isType$1(P.Note);\nvar isPage = isType$1(P.Page);\nvar isImage = isType$1(P.Image);\nvar isCanvas = isType$1(P.Canvas);\nvar isTextInstance$1 = isType$1(P.TextInstance);\n\nvar setNodeHeight = function setNodeHeight(node) {\n  var _node$box4, _node$style7;\n\n  var value = isPage(node) ? (_node$box4 = node.box) === null || _node$box4 === void 0 ? void 0 : _node$box4.height : (_node$style7 = node.style) === null || _node$style7 === void 0 ? void 0 : _node$style7.height;\n  return setHeight(value);\n};\n/**\n * Set styles valeus into yoga node before layout calculation\n *\n * @param node\n */\n\n\nvar setYogaValues = function setYogaValues(node) {\n  compose(setNodeHeight(node), setWidth(node.style.width), setMinWidth(node.style.minWidth), setMaxWidth(node.style.maxWidth), setMinHeight(node.style.minHeight), setMaxHeight(node.style.maxHeight), setMarginTop(node.style.marginTop), setMarginRight(node.style.marginRight), setMarginBottom(node.style.marginBottom), setMarginLeft(node.style.marginLeft), setPaddingTop(node.style.paddingTop), setPaddingRight(node.style.paddingRight), setPaddingBottom(node.style.paddingBottom), setPaddingLeft(node.style.paddingLeft), setPositionType(node.style.position), setPositionTop(node.style.top), setPositionRight(node.style.right), setPositionBottom(node.style.bottom), setPositionLeft(node.style.left), setBorderTop(node.style.borderTopWidth), setBorderRight(node.style.borderRightWidth), setBorderBottom(node.style.borderBottomWidth), setBorderLeft(node.style.borderLeftWidth), setDisplay(node.style.display), setFlexDirection(node.style.flexDirection), setAlignSelf(node.style.alignSelf), setAlignContent(node.style.alignContent), setAlignItems(node.style.alignItems), setJustifyContent(node.style.justifyContent), setFlexWrap(node.style.flexWrap), setOverflow(node.style.overflow), setAspectRatio(node.style.aspectRatio), setFlexBasis(node.style.flexBasis), setFlexGrow(node.style.flexGrow), setFlexShrink(node.style.flexShrink), setRowGap(node.style.rowGap), setColumnGap(node.style.columnGap))(node);\n};\n/**\n * Inserts child into parent' yoga node\n *\n * @param parent parent\n * @returns Insert yoga nodes\n */\n\n\nvar insertYogaNodes = function insertYogaNodes(parent) {\n  return function (child) {\n    parent.insertChild(child.yogaNode, parent.getChildCount());\n    return child;\n  };\n};\n\nvar setMeasureFunc = function setMeasureFunc(node, page, fontStore) {\n  var yogaNode = node.yogaNode;\n\n  if (isText$2(node)) {\n    yogaNode.setMeasureFunc(measureText(page, node, fontStore));\n  }\n\n  if (isImage(node)) {\n    yogaNode.setMeasureFunc(measureImage(page, node));\n  }\n\n  if (isCanvas(node)) {\n    yogaNode.setMeasureFunc(measureCanvas(page, node));\n  }\n\n  if (isSvg(node)) {\n    yogaNode.setMeasureFunc(measureCanvas$1(page, node));\n  }\n\n  return node;\n};\n\nvar isLayoutElement = function isLayoutElement(node) {\n  return !isText$2(node) && !isNote(node) && !isSvg(node);\n};\n/**\n * @typedef {Function} CreateYogaNodes\n * @param {Object} node\n * @returns {Object} node with appended yoga node\n */\n\n/**\n * Creates and add yoga node to document tree\n * Handles measure function for text and image nodes\n *\n * @returns Create yoga nodes\n */\n\n\nvar createYogaNodes = function createYogaNodes(page, fontStore, yoga) {\n  return function (node) {\n    var yogaNode = yoga.node.create();\n    var result = Object.assign({}, node, {\n      yogaNode: yogaNode\n    });\n    setYogaValues(result);\n\n    if (isLayoutElement(node) && node.children) {\n      var resolveChild = compose(insertYogaNodes(yogaNode), createYogaNodes(page, fontStore, yoga));\n      result.children = node.children.map(resolveChild);\n    }\n\n    setMeasureFunc(result, page, fontStore);\n    return result;\n  };\n};\n/**\n * Performs yoga calculation\n *\n * @param page - Page node\n * @returns Page node\n */\n\n\nvar calculateLayout = function calculateLayout(page) {\n  page.yogaNode.calculateLayout();\n  return page;\n};\n/**\n * Saves Yoga layout result into 'box' attribute of node\n *\n * @param node\n * @returns Node with box data\n */\n\n\nvar persistDimensions = function persistDimensions(node) {\n  if (isTextInstance$1(node)) return node;\n  var box = Object.assign(getPadding(node), getMargin(node), getBorderWidth(node), getPosition(node), getDimension(node));\n  var newNode = Object.assign({}, node, {\n    box: box\n  });\n  if (!node.children) return newNode;\n  var children = node.children.map(persistDimensions);\n  return Object.assign({}, newNode, {\n    children: children\n  });\n};\n/**\n * Removes yoga node from document tree\n *\n * @param node\n * @returns Node without yoga node\n */\n\n\nvar destroyYogaNodes = function destroyYogaNodes(node) {\n  var newNode = Object.assign({}, node);\n  delete newNode.yogaNode;\n  if (!node.children) return newNode;\n  var children = node.children.map(destroyYogaNodes);\n  return Object.assign({}, newNode, {\n    children: children\n  });\n};\n/**\n * Free yoga node from document tree\n *\n * @param node\n * @returns Node without yoga node\n */\n\n\nvar freeYogaNodes = function freeYogaNodes(node) {\n  if (node.yogaNode) node.yogaNode.freeRecursive();\n  return node;\n};\n/**\n * Calculates page object layout using Yoga.\n * Takes node values from 'box' and 'style' attributes, and persist them back into 'box'\n * Destroy yoga values at the end.\n *\n * @param page - Object\n * @returns Page object with correct 'box' layout attributes\n */\n\n\nvar resolvePageDimensions = function resolvePageDimensions(page, fontStore, yoga) {\n  if (isNil(page)) return null;\n  return compose(destroyYogaNodes, freeYogaNodes, persistDimensions, calculateLayout, createYogaNodes(page, fontStore, yoga))(page);\n};\n/**\n * Calculates root object layout using Yoga.\n *\n * @param node - Root object\n * @param fontStore - Font store\n * @returns Root object with correct 'box' layout attributes\n */\n\n\nvar resolveDimensions = function resolveDimensions(node, fontStore) {\n  if (!node.children) return node;\n\n  var resolveChild = function resolveChild(child) {\n    return resolvePageDimensions(child, fontStore, node.yoga);\n  };\n\n  var children = node.children.map(resolveChild);\n  return Object.assign({}, node, {\n    children: children\n  });\n};\n\nvar isText$1 = function isText$1(node) {\n  return node.type === P.Text;\n}; // Prevent splitting elements by low decimal numbers\n\n\nvar SAFETY_THRESHOLD = 0.001;\n\nvar assingChildren = function assingChildren(children, node) {\n  return Object.assign({}, node, {\n    children: children\n  });\n};\n\nvar getTop = function getTop(node) {\n  var _node$box5;\n\n  return ((_node$box5 = node.box) === null || _node$box5 === void 0 ? void 0 : _node$box5.top) || 0;\n};\n\nvar allFixed = function allFixed(nodes) {\n  return nodes.every(isFixed);\n};\n\nvar isDynamic = function isDynamic(node) {\n  return node.props && 'render' in node.props;\n};\n\nvar relayoutPage = compose(resolveTextLayout, resolvePageDimensions, resolveInheritance, resolvePageStyles);\n\nvar warnUnavailableSpace = function warnUnavailableSpace(node) {\n  console.warn(\"Node of type \".concat(node.type, \" can't wrap between pages and it's bigger than available page height\"));\n};\n\nvar splitNodes = function splitNodes(height, contentArea, nodes) {\n  var currentChildren = [];\n  var nextChildren = [];\n\n  for (var i = 0; i < nodes.length; i += 1) {\n    var child = nodes[i];\n    var futureNodes = nodes.slice(i + 1);\n    var futureFixedNodes = futureNodes.filter(isFixed);\n    var nodeTop = getTop(child);\n    var nodeHeight = child.box.height;\n    var isOutside = height <= nodeTop;\n    var shouldBreak$1 = shouldBreak(child, futureNodes, height);\n    var shouldSplit = height + SAFETY_THRESHOLD < nodeTop + nodeHeight;\n    var canWrap = getWrap(child);\n    var fitsInsidePage = nodeHeight <= contentArea;\n\n    if (isFixed(child)) {\n      nextChildren.push(child);\n      currentChildren.push(child);\n      continue;\n    }\n\n    if (isOutside) {\n      var box = Object.assign({}, child.box, {\n        top: child.box.top - height\n      });\n      var next = Object.assign({}, child, {\n        box: box\n      });\n      nextChildren.push(next);\n      continue;\n    }\n\n    if (!fitsInsidePage && !canWrap) {\n      currentChildren.push(child);\n      nextChildren.push.apply(nextChildren, _toConsumableArray(futureNodes));\n      warnUnavailableSpace(child);\n      break;\n    }\n\n    if (shouldBreak$1) {\n      var _box = Object.assign({}, child.box, {\n        top: child.box.top - height\n      });\n\n      var props = Object.assign({}, child.props, {\n        wrap: true,\n        break: false\n      });\n\n      var _next = Object.assign({}, child, {\n        box: _box,\n        props: props\n      });\n\n      currentChildren.push.apply(currentChildren, _toConsumableArray(futureFixedNodes));\n      nextChildren.push.apply(nextChildren, [_next].concat(_toConsumableArray(futureNodes)));\n      break;\n    }\n\n    if (shouldSplit) {\n      var _split = split(child, height, contentArea),\n          _split2 = _slicedToArray(_split, 2),\n          currentChild = _split2[0],\n          nextChild = _split2[1]; // All children are moved to the next page, it doesn't make sense to show the parent on the current page\n\n\n      if (child.children.length > 0 && currentChild.children.length === 0) {\n        // But if the current page is empty then we can just include the parent on the current page\n        if (currentChildren.length === 0) {\n          currentChildren.push.apply(currentChildren, [child].concat(_toConsumableArray(futureFixedNodes)));\n          nextChildren.push.apply(nextChildren, _toConsumableArray(futureNodes));\n        } else {\n          var _box2 = Object.assign({}, child.box, {\n            top: child.box.top - height\n          });\n\n          var _next2 = Object.assign({}, child, {\n            box: _box2\n          });\n\n          currentChildren.push.apply(currentChildren, _toConsumableArray(futureFixedNodes));\n          nextChildren.push.apply(nextChildren, [_next2].concat(_toConsumableArray(futureNodes)));\n        }\n\n        break;\n      }\n\n      if (currentChild) currentChildren.push(currentChild);\n      if (nextChild) nextChildren.push(nextChild);\n      continue;\n    }\n\n    currentChildren.push(child);\n  }\n\n  return [currentChildren, nextChildren];\n};\n\nvar splitChildren = function splitChildren(height, contentArea, node) {\n  var children = node.children || [];\n  var availableHeight = height - getTop(node);\n  return splitNodes(availableHeight, contentArea, children);\n};\n\nvar splitView = function splitView(node, height, contentArea) {\n  var _splitNode = splitNode(node, height),\n      _splitNode2 = _slicedToArray(_splitNode, 2),\n      currentNode = _splitNode2[0],\n      nextNode = _splitNode2[1];\n\n  var _splitChildren = splitChildren(height, contentArea, node),\n      _splitChildren2 = _slicedToArray(_splitChildren, 2),\n      currentChilds = _splitChildren2[0],\n      nextChildren = _splitChildren2[1];\n\n  return [assingChildren(currentChilds, currentNode), assingChildren(nextChildren, nextNode)];\n};\n\nvar split = function split(node, height, contentArea) {\n  return isText$1(node) ? splitText(node, height) : splitView(node, height, contentArea);\n};\n\nvar shouldResolveDynamicNodes = function shouldResolveDynamicNodes(node) {\n  var children = node.children || [];\n  return isDynamic(node) || children.some(shouldResolveDynamicNodes);\n};\n\nvar resolveDynamicNodes = function resolveDynamicNodes(props, node) {\n  var isNodeDynamic = isDynamic(node); // Call render prop on dynamic nodes and append result to children\n\n  var resolveChildren = function resolveChildren() {\n    var children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    if (isNodeDynamic) {\n      var res = node.props.render(props);\n      return createInstances(res).filter(Boolean) // @ts-expect-error rework dynamic nodes. conflicting types\n      .map(function (n) {\n        return resolveDynamicNodes(props, n);\n      });\n    }\n\n    return children.map(function (c) {\n      return resolveDynamicNodes(props, c);\n    });\n  }; // We reset dynamic text box so it can be computed again later on\n\n\n  var resetHeight = isNodeDynamic && isText$1(node);\n  var box = resetHeight ? _objectSpread(_objectSpread({}, node.box), {}, {\n    height: 0\n  }) : node.box;\n  var children = resolveChildren(node.children); // @ts-expect-error handle text here specifically\n\n  var lines = isNodeDynamic ? null : node.lines;\n  return Object.assign({}, node, {\n    box: box,\n    lines: lines,\n    children: children\n  });\n};\n\nvar resolveDynamicPage = function resolveDynamicPage(props, page, fontStore, yoga) {\n  if (shouldResolveDynamicNodes(page)) {\n    var resolvedPage = resolveDynamicNodes(props, page);\n    return relayoutPage(resolvedPage, fontStore, yoga);\n  }\n\n  return page;\n};\n\nvar splitPage = function splitPage(page, pageNumber, fontStore, yoga) {\n  var wrapArea = getWrapArea(page);\n  var contentArea = getContentArea(page);\n  var dynamicPage = resolveDynamicPage({\n    pageNumber: pageNumber\n  }, page, fontStore, yoga);\n  var height = page.style.height;\n\n  var _splitNodes = splitNodes(wrapArea, contentArea, dynamicPage.children),\n      _splitNodes2 = _slicedToArray(_splitNodes, 2),\n      currentChilds = _splitNodes2[0],\n      nextChilds = _splitNodes2[1];\n\n  var relayout = function relayout(node) {\n    return (// @ts-expect-error rework pagination\n      relayoutPage(node, fontStore, yoga)\n    );\n  };\n\n  var currentBox = _objectSpread(_objectSpread({}, page.box), {}, {\n    height: height\n  });\n\n  var currentPage = relayout(Object.assign({}, page, {\n    box: currentBox,\n    children: currentChilds\n  }));\n  if (nextChilds.length === 0 || allFixed(nextChilds)) return [currentPage, null];\n  var nextBox = omit('height', page.box);\n  var nextProps = omit('bookmark', page.props);\n  var nextPage = relayout(Object.assign({}, page, {\n    props: nextProps,\n    box: nextBox,\n    children: nextChilds\n  }));\n  return [currentPage, nextPage];\n};\n\nvar resolvePageIndices = function resolvePageIndices(fontStore, yoga, page, pageNumber, pages) {\n  var totalPages = pages.length;\n  var props = {\n    totalPages: totalPages,\n    pageNumber: pageNumber + 1,\n    subPageNumber: page.subPageNumber + 1,\n    subPageTotalPages: page.subPageTotalPages\n  };\n  return resolveDynamicPage(props, page, fontStore, yoga);\n};\n\nvar assocSubPageData = function assocSubPageData(subpages) {\n  return subpages.map(function (page, i) {\n    return _objectSpread(_objectSpread({}, page), {}, {\n      subPageNumber: i,\n      subPageTotalPages: subpages.length\n    });\n  });\n};\n\nvar dissocSubPageData = function dissocSubPageData(page) {\n  return omit(['subPageNumber', 'subPageTotalPages'], page);\n};\n\nvar paginate = function paginate(page, pageNumber, fontStore, yoga) {\n  var _page$props6;\n\n  if (!page) return [];\n  if (((_page$props6 = page.props) === null || _page$props6 === void 0 ? void 0 : _page$props6.wrap) === false) return [page];\n  var splittedPage = splitPage(page, pageNumber, fontStore, yoga);\n  var pages = [splittedPage[0]];\n  var nextPage = splittedPage[1];\n\n  while (nextPage !== null) {\n    splittedPage = splitPage(nextPage, pageNumber + pages.length, fontStore, yoga);\n    pages.push(splittedPage[0]);\n    nextPage = splittedPage[1];\n  }\n\n  return pages;\n};\n/**\n * Performs pagination. This is the step responsible of breaking the whole document\n * into pages following pagiation rules, such as `fixed`, `break` and dynamic nodes.\n *\n * @param root - Document node\n * @param fontStore - Font store\n * @returns Layout node\n */\n\n\nvar resolvePagination = function resolvePagination(root, fontStore) {\n  var pages = [];\n  var pageNumber = 1;\n\n  for (var i = 0; i < root.children.length; i += 1) {\n    var page = root.children[i];\n    var subpages = paginate(page, pageNumber, fontStore, root.yoga);\n    subpages = assocSubPageData(subpages);\n    pageNumber += subpages.length;\n    pages = pages.concat(subpages);\n  }\n\n  pages = pages.map(function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return dissocSubPageData(resolvePageIndices.apply(void 0, [fontStore, root.yoga].concat(args)));\n  });\n  return assingChildren(pages, root);\n};\n/**\n * Translates page percentage horizontal paddings in fixed ones\n *\n * @param container - Page container\n * @returns Resolve page horizontal padding\n */\n\n\nvar resolvePageHorizontalPadding = function resolvePageHorizontalPadding(container) {\n  return function (value) {\n    var match = matchPercent(value);\n    var width = container.width;\n    return match ? match.percent * width : value;\n  };\n};\n/**\n * Translates page percentage vertical paddings in fixed ones\n *\n * @param container - Page container\n * @returns Resolve page vertical padding\n */\n\n\nvar resolvePageVerticalPadding = function resolvePageVerticalPadding(container) {\n  return function (value) {\n    var match = matchPercent(value);\n    var height = container.height;\n    return match ? match.percent * height : value;\n  };\n};\n/**\n * Translates page percentage paddings in fixed ones\n *\n * @param page\n * @returns Page with fixed paddings\n */\n\n\nvar resolvePagePaddings = function resolvePagePaddings(page) {\n  var container = page.style;\n  var style = evolve({\n    paddingTop: resolvePageVerticalPadding(container),\n    paddingLeft: resolvePageHorizontalPadding(container),\n    paddingRight: resolvePageHorizontalPadding(container),\n    paddingBottom: resolvePageVerticalPadding(container)\n  }, page.style);\n  return Object.assign({}, page, {\n    style: style\n  });\n};\n/**\n * Translates all pages percentage paddings in fixed ones\n * This has to be computed from pages calculated size and not by Yoga\n * because at this point we didn't performed pagination yet.\n *\n * @param root - Document root\n * @returns Document root with translated page paddings\n */\n\n\nvar resolvePagesPaddings = function resolvePagesPaddings(root) {\n  if (!root.children) return root;\n  var children = root.children.map(resolvePagePaddings);\n  return Object.assign({}, root, {\n    children: children\n  });\n};\n\nvar resolveRadius = function resolveRadius(box) {\n  return function (value) {\n    if (!value) return undefined;\n    var match = matchPercent(value);\n    return match ? match.percent * Math.min(box.width, box.height) : value;\n  };\n};\n/**\n * Transforms percent border radius into fixed values\n *\n * @param node\n * @returns Node\n */\n\n\nvar resolvePercentRadius = function resolvePercentRadius(node) {\n  var style = evolve({\n    borderTopLeftRadius: resolveRadius(node.box),\n    borderTopRightRadius: resolveRadius(node.box),\n    borderBottomRightRadius: resolveRadius(node.box),\n    borderBottomLeftRadius: resolveRadius(node.box)\n  }, node.style || {});\n  var newNode = Object.assign({}, node, {\n    style: style\n  });\n  if (!node.children) return newNode;\n  var children = node.children.map(resolvePercentRadius);\n  return Object.assign({}, newNode, {\n    children: children\n  });\n};\n/**\n * Transform percent height into fixed\n *\n * @param height\n * @returns Height\n */\n\n\nvar transformHeight = function transformHeight(pageArea, height) {\n  var match = matchPercent(height);\n  return match ? match.percent * pageArea : height;\n};\n/**\n * Get page area (height minus paddings)\n *\n * @param page\n * @returns Page area\n */\n\n\nvar getPageArea = function getPageArea(page) {\n  var _page$style3, _page$style4;\n\n  var pageHeight = page.style.height;\n  var pagePaddingTop = ((_page$style3 = page.style) === null || _page$style3 === void 0 ? void 0 : _page$style3.paddingTop) || 0;\n  var pagePaddingBottom = ((_page$style4 = page.style) === null || _page$style4 === void 0 ? void 0 : _page$style4.paddingBottom) || 0;\n  return pageHeight - pagePaddingTop - pagePaddingBottom;\n};\n/**\n * Transform node percent height to fixed\n *\n * @param page\n * @param node\n * @returns Transformed node\n */\n\n\nvar resolveNodePercentHeight = function resolveNodePercentHeight(page, node) {\n  var _page$style5, _node$style8;\n\n  if (isNil((_page$style5 = page.style) === null || _page$style5 === void 0 ? void 0 : _page$style5.height)) return node;\n  if (isNil((_node$style8 = node.style) === null || _node$style8 === void 0 ? void 0 : _node$style8.height)) return node;\n  var pageArea = getPageArea(page);\n  var height = transformHeight(pageArea, node.style.height);\n  var style = Object.assign({}, node.style, {\n    height: height\n  });\n  return Object.assign({}, node, {\n    style: style\n  });\n};\n/**\n * Transform page immediate children with percent height to fixed\n *\n * @param page\n * @returns Transformed page\n */\n\n\nvar resolvePagePercentHeight = function resolvePagePercentHeight(page) {\n  if (!page.children) return page;\n\n  var resolveChild = function resolveChild(child) {\n    return resolveNodePercentHeight(page, child);\n  };\n\n  var children = page.children.map(resolveChild);\n  return Object.assign({}, page, {\n    children: children\n  });\n};\n/**\n * Transform all page immediate children with percent height to fixed.\n * This is needed for computing correct dimensions on pre-pagination layout.\n *\n * @param root - Document root\n * @returns Transformed document root\n */\n\n\nvar resolvePercentHeight = function resolvePercentHeight(root) {\n  if (!root.children) return root;\n  var children = root.children.map(resolvePagePercentHeight);\n  return Object.assign({}, root, {\n    children: children\n  });\n};\n\nvar isType = function isType(type) {\n  return function (node) {\n    return node.type === type;\n  };\n};\n\nvar isLink = isType(P.Link);\nvar isText = isType(P.Text);\nvar isTextInstance = isType(P.TextInstance);\n/**\n * Checks if node has render prop\n *\n * @param node\n * @returns Has render prop?\n */\n\nvar hasRenderProp = function hasRenderProp(node) {\n  return 'render' in node.props;\n};\n/**\n * Checks if node is text type (Text or TextInstance)\n *\n * @param node\n * @returns Are all children text instances?\n */\n\n\nvar isTextType = function isTextType(node) {\n  return isText(node) || isTextInstance(node);\n};\n/**\n * Checks if is tet link that needs to be wrapped in Text\n *\n * @param node\n * @returns Are all children text instances?\n */\n\n\nvar isTextLink = function isTextLink(node) {\n  var children = node.children || []; // Text string inside a Link\n\n  if (children.every(isTextInstance)) return true; // Text node inside a Link\n\n  if (children.every(isText)) return false;\n  return children.every(isTextType);\n};\n/**\n * Wraps node children inside Text node\n *\n * @param node\n * @returns Node with intermediate Text child\n */\n\n\nvar wrapText = function wrapText(node) {\n  var textElement = {\n    type: P.Text,\n    props: {},\n    style: {},\n    box: {},\n    children: node.children\n  };\n  return Object.assign({}, node, {\n    children: [textElement]\n  });\n};\n\nvar transformLink = function transformLink(node) {\n  if (!isLink(node)) return node; // If has render prop substitute the instance by a Text, that will\n  // ultimately render the inline Link via the textkit PDF renderer.\n\n  if (hasRenderProp(node)) return Object.assign({}, node, {\n    type: P.Text\n  }); // If is a text link (either contains Text or TextInstance), wrap it\n  // inside a Text element so styles are applied correctly\n\n  if (isTextLink(node)) return wrapText(node);\n  return node;\n};\n/**\n * Transforms Link layout to correctly render text and dynamic rendered links\n *\n * @param node\n * @returns Node with link substitution\n */\n\n\nvar resolveLinkSubstitution = function resolveLinkSubstitution(node) {\n  if (!node.children) return node;\n  var resolveChild = compose(transformLink, resolveLinkSubstitution);\n  var children = node.children.map(resolveChild);\n  return Object.assign({}, node, {\n    children: children\n  });\n};\n\nvar layout = asyncCompose(resolveZIndex, resolveOrigin, resolveAssets, resolvePagination, resolveTextLayout, resolvePercentRadius, resolveDimensions, resolveSvg, resolveAssets, resolveInheritance, resolvePercentHeight, resolvePagesPaddings, resolveStyles, resolveLinkSubstitution, resolveBookmarks, resolvePageSizes, resolveYoga);\nexport { layout as default };","map":{"version":3,"sources":["C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/@react-pdf/layout/lib/index.js"],"names":["upperFirst","capitalize","parseFloat","parseFloat$1","without","pick","compose","evolve","mapValues","matchPercent","castArray","isNil","omit","asyncCompose","P","resolveStyle","transformColor","flatten","layoutEngine","fontSubstitution","wordHyphenation","scriptItemizer","textDecoration","justification","linebreaker","bidi","fromFragments","Yoga","loadYoga","loadYoga$1","emojiRegex","resolveImage","transformText","text","transformation","toUpperCase","toLowerCase","isTspan","node","type","Tspan","isTextInstance$4","TextInstance","engines$1","engine$1","getFragments$1","fontStore","instance","string","fragments","props","fill","fontFamily","fontWeight","fontStyle","fontSize","textDecorationColor","textDecorationStyle","textTransform","opacity","_textDecoration","fontFamilies","push","font","map","fontFamilyName","opts","obj","getFont","data","attributes","color","underlineStyle","underline","underlineColor","strike","strikeStyle","strikeColor","i","children","length","child","value","getAttributedString$1","AlmostInfinity","shrinkWhitespaceFactor","before","after","layoutTspan","xOffset","attributedString","x","undefined","y","container","width","height","hyphenationCallback","getHyphenationCallback","layoutOptions","lines","flat","Object","assign","joinTSpanLines","index","textInstance","layoutText$1","currentXOffset","layoutFn","joinedNode","childWithLayout","xAdvance","isDefs","Defs","getDefs","defs","find","values","reduce","acc","id","isNotDefs","detachDefs","filter","URL_REGEX","replaceDef","test","match","parseNodeDefs","clipPath","newProps","parseDefs","root","replaceDefs","parseViewbox","split","minX","minY","maxX","maxY","getContainer$1","viewbox","viewBox","BASE_SVG_INHERITED_PROPS","TEXT_SVG_INHERITED_PROPS","SVG_INHERITED_PROPS","Text","getInheritProps","svgInheritedProps","inheritProps","inheritedProps","newChild","parseAspectRatio","replace","align","meetOrSlice","STYLE_PROPS","VERTICAL_PROPS","HORIZONTAL_PROPS","isSvg$3","Svg","isText$5","isTextInstance$3","transformPercent","key","includes","percent","parsePercent","parseTransform","transform","parseProps","x1","x2","y1","y2","r","rx","ry","cx","cy","offset","stroke","stopOpacity","stopColor","gradientTransform","mergeStyles$1","style","removeNoneValues","removeNone","pickStyleProps","styleProps","parseSvgProps","preserveAspectRatio","wrapBetweenTspan","addMissingTspan","resolveChild","parseText","resolveSvgNode","resolveChildren","buildXLinksIndex","idIndex","listToExplore","slice","shift","replaceXLinks","linkedNode","xlinkHref","resolveXLinks","resolveSvgRoot","resolveSvg","instancePromise","config","Config","create","setPointScaleFactor","Node","createWithConfig","resolveYoga","yoga","getZIndex","zIndex","shouldSort","Document","sortZIndex","a","b","za","zb","resolveNodeZIndex","sortedChildren","sort","resolveZIndex","emojis","regex","removeVariationSelectors","getCodePoints","withVariationSelectors","Array","from","char","codePointAt","toString","join","buildEmojiUrl","emoji","source","builder","url","format","fetchEmojis","promises","matchAll","forEach","loading","emojiUrl","uri","then","image","embedEmojis","result","fragment","lastIndex","emojiSize","chunk","String","fromCharCode","attachment","yOffset","Math","floor","getSource","src","resolveSource","fetchImage","cache","console","warn","Error","Buffer","isBuffer","Blob","message","isImage$2","Image","fetchAssets","emojiSource","getEmojiSource","n","load","childNode","resolveAssets","Promise","all","isLink$1","Link","DEFAULT_LINK_STYLES","computeStyle","baseStyle","isArray","resolveNodeStyles","resolvePageStyles","page","dpi","box","orientation","remBase","resolveStyles","getTransformStyle","s","getOrigin","left","top","transformOriginX","transformOriginY","percentX","percentY","offsetX","offsetY","resolveNodeOrigin","origin","newNode","resolveOrigin","getBookmarkValue","bookmark","title","fit","expanded","resolveBookmarks","refs","parent","element","ref","newHierarchy","VALID_ORIENTATIONS","getOrientation","isLandscape","PAGE_SIZES","A0","A1","A2","A3","A4","A5","A6","A7","A8","A9","A10","B0","B1","B2","B3","B4","B5","B6","B7","B8","B9","B10","C0","C1","C2","C3","C4","C5","C6","C7","C8","C9","C10","RA0","RA1","RA2","RA3","RA4","SRA0","SRA1","SRA2","SRA3","SRA4","EXECUTIVE","FOLIO","LEGAL","LETTER","TABLOID","ID1","parseValue","unit","exec","transformUnit","inputDpi","scalar","outputDpi","mmFactor","cmFactor","round","transformUnits","toSizeObject","v","flipSizeObject","getStringSize","getNumberSize","getSize","size","resolvePageSize","resolvePageSizes","isFixed","fixed","lineIndexAtHeight","line","heightAtLineIndex","counter","getLineBreak","widows","orphans","linesQuantity","slicedLine","splitText","slicedLineIndex","currentHeight","nextHeight","current","borderBottomWidth","marginBottom","paddingBottom","borderBottomLeftRadius","borderBottomRightRadius","next","borderTopWidth","marginTop","paddingTop","borderTopLeftRadius","borderTopRightRadius","getTop$1","hasFixedHeight","splitNode","nodeTop","NON_WRAP_TYPES","Note","Canvas","getWrap","wrap","getComputedPadding","edge","yogaNode","getPadding","Edge","Top","paddingRight","Right","Bottom","paddingLeft","Left","getWrapArea","getContentArea","isString","isNumber","isBoolean","isFragment","Symbol","for","createInstances","el","concat","nextChildren","getBreak","break","getMinPresenceAhead","minPresenceAhead","getFurthestEnd","elements","max","getEndOfMinPresenceAhead","getEndOfPresence","futureElements","afterMinPresenceAhead","endOfFurthestFutureElement","min","shouldBreak","shouldSplit","canWrap","endOfPresence","breakingImprovesPresence","IGNORABLE_CODEPOINTS","buildSubsetForFont","codePoint","hasGlyphForCodePoint","ignoreChars","charSubset","subsetRegex","RegExp","PREPROCESSORS","isImage$1","isTextInstance$2","getFragments","parentLink","level","direction","textAlign","lineHeight","letterSpacing","textIndent","verticalAlign","backgroundColor","indent","characterSpacing","link","href","preprocessor","getAttributedString","engines","engine","getMaxLines","maxLines","getTextOverflow","textOverflow","getContainer","Infinity","truncateMode","getLayoutOptions","hyphenationPenalty","layoutText","options","isSvg$2","isText$4","shouldIterate","shouldLayoutText","resolveTextLayout","mapChild","BASE_INHERITABLE_PROPERTIES","TEXT_INHERITABLE_PROPERTIES","isType$2","isSvg$1","isText$3","mergeValues","styleName","inheritedValue","merge","inheritedStyles","mergedStyles","entries","mergeStyles","resolveInheritance","inheritableProperties","inheritStyles","getComputedMargin","getMargin","marginRight","marginLeft","getPosition","getComputedTop","right","getComputedRight","bottom","getComputedBottom","getComputedLeft","DEFAULT_DIMENSION","getDimension","getComputedWidth","getComputedHeight","getComputedBorder","getBorderWidth","borderRightWidth","borderLeftWidth","setDisplay","Display","None","Flex","OVERFLOW","hidden","Overflow","Hidden","scroll","Scroll","setOverflow","overflow","Visible","FLEX_WRAP","Wrap","WrapReverse","setFlexWrap","flexWrap","NoWrap","setYogaValue","attr","hasEdge","fixedMethod","autoMethod","percentMethod","setFlexGrow","setFlexBasis","ALIGN","Align","FlexStart","center","Center","FlexEnd","stretch","Stretch","baseline","Baseline","SpaceBetween","SpaceAround","SpaceEvenly","setAlign","defaultValue","Auto","setAlignSelf","setAlignItems","setFlexShrink","setAspectRatio","setAlignContent","POSITION","absolute","PositionType","Absolute","relative","Relative","static","Static","setPositionType","FLEX_DIRECTIONS","row","FlexDirection","Row","RowReverse","ColumnReverse","setFlexDirection","flexDirection","Column","JUSTIFY_CONTENT","Justify","setJustifyContent","justifyContent","setMarginTop","setMarginRight","setMarginBottom","setMarginLeft","setPaddingTop","setPaddingRight","setPaddingBottom","setPaddingLeft","setBorderTop","setBorderRight","setBorderBottom","setBorderLeft","setPositionTop","setPositionRight","setPositionBottom","setPositionLeft","setWidth","setMinWidth","setMaxWidth","setHeight","setMinHeight","setMaxHeight","setRowGap","Gutter","setColumnGap","getAspectRatio","measureCanvas$1","widthMode","heightMode","aspectRatio","MeasureMode","Exactly","AtMost","linesWidth","linesHeight","ALIGNMENT_FACTORS","measureText","alignFactor","alignOffset","getRatio","isHeightAuto","SAFETY_HEIGHT$1","measureImage","imageRatio","imageMargin","pagePadding","pageArea","Undefined","scaledHeight","SAFETY_HEIGHT","getMax","measureCtx","ctx","points","nil","addPoint","moveTo","rect","w","h","ellipse","polygon","lineTo","circle","roundedRect","path","lineWidth","bezierCurveTo","quadraticCurveTo","scale","rotate","translate","dash","clip","save","lineCap","restore","lineJoin","fillColor","miterLimit","strokeColor","fillOpacity","strokeOpacity","linearGradient","radialGradient","getWidth","p","getHeight","measureCanvas","paint","isType$1","isSvg","isText$2","isNote","isPage","Page","isImage","isCanvas","isTextInstance$1","setNodeHeight","setYogaValues","minWidth","maxWidth","minHeight","maxHeight","position","display","alignSelf","alignContent","alignItems","flexBasis","flexGrow","flexShrink","rowGap","columnGap","insertYogaNodes","insertChild","getChildCount","setMeasureFunc","isLayoutElement","createYogaNodes","calculateLayout","persistDimensions","destroyYogaNodes","freeYogaNodes","freeRecursive","resolvePageDimensions","resolveDimensions","isText$1","SAFETY_THRESHOLD","assingChildren","getTop","allFixed","nodes","every","isDynamic","relayoutPage","warnUnavailableSpace","splitNodes","contentArea","currentChildren","futureNodes","futureFixedNodes","nodeHeight","isOutside","shouldBreak$1","fitsInsidePage","currentChild","nextChild","splitChildren","availableHeight","splitView","currentNode","nextNode","currentChilds","shouldResolveDynamicNodes","some","resolveDynamicNodes","isNodeDynamic","res","render","Boolean","c","resetHeight","resolveDynamicPage","resolvedPage","splitPage","pageNumber","wrapArea","dynamicPage","nextChilds","relayout","currentBox","currentPage","nextBox","nextProps","nextPage","resolvePageIndices","pages","totalPages","subPageNumber","subPageTotalPages","assocSubPageData","subpages","dissocSubPageData","paginate","splittedPage","resolvePagination","args","resolvePageHorizontalPadding","resolvePageVerticalPadding","resolvePagePaddings","resolvePagesPaddings","resolveRadius","resolvePercentRadius","transformHeight","getPageArea","pageHeight","pagePaddingTop","pagePaddingBottom","resolveNodePercentHeight","resolvePagePercentHeight","resolvePercentHeight","isType","isLink","isText","isTextInstance","hasRenderProp","isTextType","isTextLink","wrapText","textElement","transformLink","resolveLinkSubstitution","layout","default"],"mappings":"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","sourcesContent":["import { upperFirst, capitalize, parseFloat as parseFloat$1, without, pick, compose, evolve, mapValues, matchPercent, castArray, isNil, omit, asyncCompose } from '@react-pdf/fns';\nimport * as P from '@react-pdf/primitives';\nimport resolveStyle, { transformColor, flatten } from '@react-pdf/stylesheet';\nimport layoutEngine, { fontSubstitution, wordHyphenation, scriptItemizer, textDecoration, justification, linebreaker, bidi, fromFragments } from '@react-pdf/textkit';\nimport * as Yoga from 'yoga-layout/load';\nimport { loadYoga as loadYoga$1 } from 'yoga-layout/load';\nimport emojiRegex from 'emoji-regex';\nimport resolveImage from '@react-pdf/image';\n\n/**\n * Apply transformation to text string\n *\n * @param {string} text\n * @param {string} transformation type\n * @returns {string} transformed text\n */\nconst transformText = (text, transformation) => {\n    switch (transformation) {\n        case 'uppercase':\n            return text.toUpperCase();\n        case 'lowercase':\n            return text.toLowerCase();\n        case 'capitalize':\n            return capitalize(text);\n        case 'upperfirst':\n            return upperFirst(text);\n        default:\n            return text;\n    }\n};\n\nconst isTspan = (node) => node.type === P.Tspan;\nconst isTextInstance$4 = (node) => node.type === P.TextInstance;\nconst engines$1 = {\n    bidi,\n    linebreaker,\n    justification,\n    textDecoration,\n    scriptItemizer,\n    wordHyphenation,\n    fontSubstitution,\n};\nconst engine$1 = layoutEngine(engines$1);\nconst getFragments$1 = (fontStore, instance) => {\n    if (!instance)\n        return [{ string: '' }];\n    const fragments = [];\n    const { fill = 'black', fontFamily = 'Helvetica', fontWeight, fontStyle, fontSize = 18, textDecorationColor, textDecorationStyle, textTransform, opacity, } = instance.props;\n    const _textDecoration = instance.props.textDecoration;\n    const fontFamilies = typeof fontFamily === 'string' ? [fontFamily] : [...(fontFamily || [])];\n    // Fallback font\n    fontFamilies.push('Helvetica');\n    const font = fontFamilies.map((fontFamilyName) => {\n        const opts = { fontFamily: fontFamilyName, fontWeight, fontStyle };\n        const obj = fontStore.getFont(opts);\n        return obj?.data;\n    });\n    const attributes = {\n        font,\n        opacity,\n        fontSize,\n        color: fill,\n        underlineStyle: textDecorationStyle,\n        underline: _textDecoration === 'underline' ||\n            _textDecoration === 'underline line-through' ||\n            _textDecoration === 'line-through underline',\n        underlineColor: textDecorationColor || fill,\n        strike: _textDecoration === 'line-through' ||\n            _textDecoration === 'underline line-through' ||\n            _textDecoration === 'line-through underline',\n        strikeStyle: textDecorationStyle,\n        strikeColor: textDecorationColor || fill,\n    };\n    for (let i = 0; i < instance.children.length; i += 1) {\n        const child = instance.children[i];\n        if (isTextInstance$4(child)) {\n            fragments.push({\n                string: transformText(child.value, textTransform),\n                attributes,\n            });\n        }\n        else if (child) {\n            fragments.push(...getFragments$1(fontStore, child));\n        }\n    }\n    return fragments;\n};\nconst getAttributedString$1 = (fontStore, instance) => fromFragments(getFragments$1(fontStore, instance));\nconst AlmostInfinity = 999999999999;\nconst shrinkWhitespaceFactor = { before: -0.5, after: -0.5 };\nconst layoutTspan = (fontStore) => (node, xOffset) => {\n    const attributedString = getAttributedString$1(fontStore, node);\n    const x = node.props.x === undefined ? xOffset : node.props.x;\n    const y = node.props?.y || 0;\n    const container = { x, y, width: AlmostInfinity, height: AlmostInfinity };\n    const hyphenationCallback = node.props.hyphenationCallback ||\n        fontStore?.getHyphenationCallback() ||\n        null;\n    const layoutOptions = { hyphenationCallback, shrinkWhitespaceFactor };\n    const lines = engine$1(attributedString, container, layoutOptions).flat();\n    return Object.assign({}, node, { lines });\n};\n// Consecutive TSpan elements should be joined with a space\nconst joinTSpanLines = (node) => {\n    const children = node.children.map((child, index) => {\n        if (!isTspan(child))\n            return child;\n        const textInstance = child.children[0];\n        if (child.props.x === undefined &&\n            index < node.children.length - 1 &&\n            textInstance?.value) {\n            return Object.assign({}, child, {\n                children: [{ ...textInstance, value: `${textInstance.value} ` }],\n            });\n        }\n        return child;\n    }, []);\n    return Object.assign({}, node, { children });\n};\nconst layoutText$1 = (fontStore, node) => {\n    if (!node.children)\n        return node;\n    let currentXOffset = node.props?.x || 0;\n    const layoutFn = layoutTspan(fontStore);\n    const joinedNode = joinTSpanLines(node);\n    const children = joinedNode.children.map((child) => {\n        const childWithLayout = layoutFn(child, currentXOffset);\n        currentXOffset += childWithLayout.lines[0].xAdvance;\n        return childWithLayout;\n    });\n    return Object.assign({}, node, { children });\n};\n\nconst isDefs = (node) => node.type === P.Defs;\nconst getDefs = (node) => {\n    const children = node.children || [];\n    const defs = children.find(isDefs);\n    const values = defs?.children || [];\n    return values.reduce((acc, value) => {\n        const id = value.props?.id;\n        if (id)\n            acc[id] = value;\n        return acc;\n    }, {});\n};\n\nconst isNotDefs = (node) => node.type !== P.Defs;\nconst detachDefs = (node) => {\n    if (!node.children)\n        return node;\n    const children = node.children.filter(isNotDefs);\n    return Object.assign({}, node, { children });\n};\nconst URL_REGEX = /url\\(['\"]?#([^'\"]+)['\"]?\\)/;\nconst replaceDef = (defs, value) => {\n    if (!value)\n        return undefined;\n    if (!URL_REGEX.test(value))\n        return value;\n    const match = value.match(URL_REGEX);\n    return defs[match[1]];\n};\nconst parseNodeDefs = (defs) => (node) => {\n    const props = node.props;\n    const fill = `fill` in props ? replaceDef(defs, props?.fill) : undefined;\n    const clipPath = `clipPath` in props\n        ? replaceDef(defs, props?.clipPath)\n        : undefined;\n    const newProps = Object.assign({}, node.props, { fill, clipPath });\n    const children = node.children\n        ? node.children.map(parseNodeDefs(defs))\n        : undefined;\n    return Object.assign({}, node, { props: newProps, children });\n};\nconst parseDefs = (root) => {\n    if (!root.children)\n        return root;\n    const defs = getDefs(root);\n    const children = root.children.map(parseNodeDefs(defs));\n    return Object.assign({}, root, { children });\n};\nconst replaceDefs = (node) => {\n    return detachDefs(parseDefs(node));\n};\n\nconst parseViewbox = (value) => {\n    if (!value)\n        return null;\n    if (typeof value !== 'string')\n        return value;\n    const values = value.split(/[,\\s]+/).map(parseFloat$1);\n    if (values.length !== 4)\n        return null;\n    return { minX: values[0], minY: values[1], maxX: values[2], maxY: values[3] };\n};\n\nconst getContainer$1 = (node) => {\n    const viewbox = parseViewbox(node.props.viewBox);\n    if (viewbox) {\n        return { width: viewbox.maxX, height: viewbox.maxY };\n    }\n    if (node.props.width && node.props.height) {\n        return {\n            width: parseFloat$1(node.props.width),\n            height: parseFloat$1(node.props.height),\n        };\n    }\n    return { width: 0, height: 0 };\n};\n\nconst BASE_SVG_INHERITED_PROPS = [\n    'x',\n    'y',\n    'clipPath',\n    'clipRule',\n    'opacity',\n    'fill',\n    'fillOpacity',\n    'fillRule',\n    'stroke',\n    'strokeLinecap',\n    'strokeLinejoin',\n    'strokeOpacity',\n    'strokeWidth',\n    'textAnchor',\n    'dominantBaseline',\n    'color',\n    'fontFamily',\n    'fontSize',\n    'fontStyle',\n    'fontWeight',\n    'letterSpacing',\n    'opacity',\n    'textDecoration',\n    'lineHeight',\n    'textAlign',\n    'visibility',\n    'wordSpacing',\n];\n// Do not inherit \"x\" for <tspan> elements from <text> parent\nconst TEXT_SVG_INHERITED_PROPS = without(['x'], BASE_SVG_INHERITED_PROPS);\nconst SVG_INHERITED_PROPS = {\n    [P.Text]: TEXT_SVG_INHERITED_PROPS,\n};\nconst getInheritProps = (node) => {\n    const props = node.props || {};\n    const svgInheritedProps = SVG_INHERITED_PROPS[node.type] ?? BASE_SVG_INHERITED_PROPS;\n    return pick(svgInheritedProps, props);\n};\nconst inheritProps = (node) => {\n    if (!node.children)\n        return node;\n    const inheritedProps = getInheritProps(node);\n    const children = node.children.map((child) => {\n        const props = Object.assign({}, inheritedProps, child.props || {});\n        const newChild = Object.assign({}, child, { props });\n        return inheritProps(newChild);\n    });\n    return Object.assign({}, node, { children });\n};\n\nconst parseAspectRatio = (value) => {\n    if (typeof value !== 'string')\n        return value;\n    const match = value\n        .replace(/[\\s\\r\\t\\n]+/gm, ' ')\n        .replace(/^defer\\s/, '')\n        .split(' ');\n    const align = (match[0] || 'xMidYMid');\n    const meetOrSlice = (match[1] ||\n        'meet');\n    return { align, meetOrSlice };\n};\n\nconst STYLE_PROPS = [\n    'width',\n    'height',\n    'color',\n    'stroke',\n    'strokeWidth',\n    'opacity',\n    'fillOpacity',\n    'strokeOpacity',\n    'fill',\n    'fillRule',\n    'clipPath',\n    'offset',\n    'transform',\n    'strokeLinejoin',\n    'strokeLinecap',\n    'strokeDasharray',\n    'gradientUnits',\n    'gradientTransform',\n];\nconst VERTICAL_PROPS = ['y', 'y1', 'y2', 'height', 'cy', 'ry'];\nconst HORIZONTAL_PROPS = ['x', 'x1', 'x2', 'width', 'cx', 'rx'];\nconst isSvg$3 = (node) => node.type === P.Svg;\nconst isText$5 = (node) => node.type === P.Text;\nconst isTextInstance$3 = (node) => node.type === P.TextInstance;\nconst transformPercent = (container) => (props) => mapValues(props, (value, key) => {\n    const match = matchPercent(value);\n    if (match && VERTICAL_PROPS.includes(key)) {\n        return match.percent * container.height;\n    }\n    if (match && HORIZONTAL_PROPS.includes(key)) {\n        return match.percent * container.width;\n    }\n    return value;\n});\nconst parsePercent = (value) => {\n    const match = matchPercent(value);\n    return match ? match.percent : parseFloat$1(value);\n};\nconst parseTransform = (container) => (value) => {\n    return resolveStyle(container, { transform: value }).transform;\n};\nconst parseProps = (container) => (node) => {\n    let props = transformPercent(container)(node.props);\n    props = evolve({\n        x: parseFloat$1,\n        x1: parseFloat$1,\n        x2: parseFloat$1,\n        y: parseFloat$1,\n        y1: parseFloat$1,\n        y2: parseFloat$1,\n        r: parseFloat$1,\n        rx: parseFloat$1,\n        ry: parseFloat$1,\n        cx: parseFloat$1,\n        cy: parseFloat$1,\n        width: parseFloat$1,\n        height: parseFloat$1,\n        offset: parsePercent,\n        fill: transformColor,\n        opacity: parsePercent,\n        stroke: transformColor,\n        stopOpacity: parsePercent,\n        stopColor: transformColor,\n        transform: parseTransform(container),\n        gradientTransform: parseTransform(container),\n    }, props);\n    return Object.assign({}, node, { props });\n};\nconst mergeStyles$1 = (node) => {\n    const style = node.style || {};\n    const props = Object.assign({}, style, node.props);\n    return Object.assign({}, node, { props });\n};\nconst removeNoneValues = (node) => {\n    const removeNone = (value) => (value === 'none' ? null : value);\n    const props = mapValues(node.props, removeNone);\n    return Object.assign({}, node, { props });\n};\nconst pickStyleProps = (node) => {\n    const props = node.props || {};\n    const styleProps = pick(STYLE_PROPS, props);\n    const style = Object.assign({}, styleProps, node.style || {});\n    return Object.assign({}, node, { style });\n};\nconst parseSvgProps = (node) => {\n    const props = evolve({\n        width: parseFloat$1,\n        height: parseFloat$1,\n        viewBox: parseViewbox,\n        preserveAspectRatio: parseAspectRatio,\n    }, node.props);\n    return Object.assign({}, node, { props });\n};\nconst wrapBetweenTspan = (node) => ({\n    type: P.Tspan,\n    props: {},\n    style: {},\n    children: [node],\n});\nconst addMissingTspan = (node) => {\n    if (!isText$5(node))\n        return node;\n    if (!node.children)\n        return node;\n    const resolveChild = (child) => isTextInstance$3(child) ? wrapBetweenTspan(child) : child;\n    const children = node.children.map(resolveChild);\n    return Object.assign({}, node, { children });\n};\nconst parseText = (fontStore) => (node) => {\n    if (isText$5(node))\n        return layoutText$1(fontStore, node);\n    if (!node.children)\n        return node;\n    const children = node.children.map(parseText(fontStore));\n    return Object.assign({}, node, { children });\n};\nconst resolveSvgNode = (container) => compose(parseProps(container), addMissingTspan, removeNoneValues, mergeStyles$1);\nconst resolveChildren = (container) => (node) => {\n    if (!node.children)\n        return node;\n    const resolveChild = compose(resolveChildren(container), resolveSvgNode(container));\n    const children = node.children.map(resolveChild);\n    return Object.assign({}, node, { children });\n};\nconst buildXLinksIndex = (node) => {\n    const idIndex = {};\n    const listToExplore = node.children?.slice(0) || [];\n    while (listToExplore.length > 0) {\n        const child = listToExplore.shift();\n        if (child.props && 'id' in child.props) {\n            idIndex[child.props.id] = child;\n        }\n        if (child.children)\n            listToExplore.push(...child.children);\n    }\n    return idIndex;\n};\nconst replaceXLinks = (node, idIndex) => {\n    if (node.props && 'xlinkHref' in node.props) {\n        const linkedNode = idIndex[node.props.xlinkHref.replace(/^#/, '')];\n        // No node to extend from\n        if (!linkedNode)\n            return node;\n        const newProps = Object.assign({}, linkedNode.props, node.props);\n        delete newProps.xlinkHref;\n        return Object.assign({}, linkedNode, { props: newProps });\n    }\n    const children = node.children?.map((child) => replaceXLinks(child, idIndex));\n    return Object.assign({}, node, { children });\n};\nconst resolveXLinks = (node) => {\n    const idIndex = buildXLinksIndex(node);\n    return replaceXLinks(node, idIndex);\n};\nconst resolveSvgRoot = (node, fontStore) => {\n    const container = getContainer$1(node);\n    return compose(replaceDefs, parseText(fontStore), parseSvgProps, pickStyleProps, inheritProps, resolveChildren(container), resolveXLinks)(node);\n};\n/**\n * Pre-process SVG nodes so they can be rendered in the next steps\n *\n * @param node - Root node\n * @param fontStore - Font store\n * @returns Root node\n */\nconst resolveSvg = (node, fontStore) => {\n    if (!('children' in node))\n        return node;\n    const resolveChild = (child) => resolveSvg(child, fontStore);\n    const root = isSvg$3(node) ? resolveSvgRoot(node, fontStore) : node;\n    const children = root.children?.map(resolveChild);\n    return Object.assign({}, root, { children });\n};\n\nlet instancePromise;\nconst loadYoga = async () => {\n    // Yoga WASM binaries must be asynchronously compiled and loaded\n    // to prevent Event emitter memory leak warnings, Yoga must be loaded only once\n    const instance = await (instancePromise ??= loadYoga$1());\n    const config = instance.Config.create();\n    config.setPointScaleFactor(0);\n    const node = { create: () => instance.Node.createWithConfig(config) };\n    return { node };\n};\n\nconst resolveYoga = async (root) => {\n    const yoga = await loadYoga();\n    return Object.assign({}, root, { yoga });\n};\n\nconst getZIndex = (node) => node.style.zIndex;\nconst shouldSort = (node) => node.type !== P.Document && node.type !== P.Svg;\nconst sortZIndex = (a, b) => {\n    const za = getZIndex(a);\n    const zb = getZIndex(b);\n    if (!za && !zb)\n        return 0;\n    if (!za)\n        return 1;\n    if (!zb)\n        return -1;\n    return zb - za;\n};\n/**\n * Sort children by zIndex value\n *\n * @param node\n * @returns Node\n */\nconst resolveNodeZIndex = (node) => {\n    if (!node.children)\n        return node;\n    const sortedChildren = shouldSort(node)\n        ? node.children.sort(sortZIndex)\n        : node.children;\n    const children = sortedChildren.map(resolveNodeZIndex);\n    return Object.assign({}, node, { children });\n};\n/**\n * Sort children by zIndex value\n *\n * @param node\n * @returns Node\n */\nconst resolveZIndex = (root) => resolveNodeZIndex(root);\n\n// Caches emoji images data\nconst emojis = {};\nconst regex = emojiRegex();\n/**\n * When an emoji as no variations, it might still have 2 parts,\n * the canonical emoji and an empty string.\n * ex.\n *   (no color) Array.from('â¤ï¸') => [\"â¤\", \"ï¸\"]\n *   (w/ color) Array.from('ðŸ‘ðŸ¿') => [\"ðŸ‘\", \"ðŸ¿\"]\n *\n * The empty string needs to be removed otherwise the generated\n * url will be incorect.\n */\nconst removeVariationSelectors = (x) => x !== 'ï¸';\nconst getCodePoints = (string, withVariationSelectors = false) => Array.from(string)\n    .filter(withVariationSelectors ? () => true : removeVariationSelectors)\n    .map((char) => char.codePointAt(0).toString(16))\n    .join('-');\nconst buildEmojiUrl = (emoji, source) => {\n    if ('builder' in source) {\n        return source.builder(getCodePoints(emoji, source.withVariationSelectors));\n    }\n    const { url, format = 'png', withVariationSelectors } = source;\n    return `${url}${getCodePoints(emoji, withVariationSelectors)}.${format}`;\n};\nconst fetchEmojis = (string, source) => {\n    if (!source)\n        return [];\n    const promises = [];\n    Array.from(string.matchAll(regex)).forEach((match) => {\n        const emoji = match[0];\n        if (!emojis[emoji] || emojis[emoji].loading) {\n            const emojiUrl = buildEmojiUrl(emoji, source);\n            emojis[emoji] = { loading: true };\n            promises.push(resolveImage({ uri: emojiUrl }).then((image) => {\n                emojis[emoji].loading = false;\n                emojis[emoji].data = image.data;\n            }));\n        }\n    });\n    return promises;\n};\nconst embedEmojis = (fragments) => {\n    const result = [];\n    for (let i = 0; i < fragments.length; i += 1) {\n        const fragment = fragments[i];\n        let lastIndex = 0;\n        Array.from(fragment.string.matchAll(regex)).forEach((match) => {\n            const { index } = match;\n            const emoji = match[0];\n            const emojiSize = fragment.attributes.fontSize;\n            const chunk = fragment.string.slice(lastIndex, index + match[0].length);\n            // If emoji image was found, we create a new fragment with the\n            // correct attachment and object substitution character;\n            if (emojis[emoji] && emojis[emoji].data) {\n                result.push({\n                    string: chunk.replace(match[0], String.fromCharCode(0xfffc)),\n                    attributes: {\n                        ...fragment.attributes,\n                        attachment: {\n                            width: emojiSize,\n                            height: emojiSize,\n                            yOffset: Math.floor(emojiSize * 0.1),\n                            image: emojis[emoji].data,\n                        },\n                    },\n                });\n            }\n            else {\n                // If no emoji data, we try to use emojis in the font\n                result.push({\n                    string: chunk,\n                    attributes: fragment.attributes,\n                });\n            }\n            lastIndex = index + emoji.length;\n        });\n        if (lastIndex < fragment.string.length) {\n            result.push({\n                string: fragment.string.slice(lastIndex),\n                attributes: fragment.attributes,\n            });\n        }\n    }\n    return result;\n};\n\n/**\n * Get image source\n *\n * @param node - Image node\n * @returns Image src\n */\nconst getSource = (node) => {\n    if (node.props.src)\n        return node.props.src;\n    if (node.props.source)\n        return node.props.source;\n};\n\n/**\n * Resolves `src` to `@react-pdf/image` interface.\n *\n * Also it handles factories and async sources.\n *\n * @param src\n * @returns Resolved src\n */\nconst resolveSource = async (src) => {\n    const source = typeof src === 'function' ? await src() : await src;\n    return typeof source === 'string' ? { uri: source } : source;\n};\n\n/**\n * Fetches image and append data to node\n * Ideally this fn should be immutable.\n *\n * @param node\n */\nconst fetchImage = async (node) => {\n    const src = getSource(node);\n    const { cache } = node.props;\n    if (!src) {\n        console.warn(false, 'Image should receive either a \"src\" or \"source\" prop');\n        return;\n    }\n    try {\n        const source = await resolveSource(src);\n        if (!source) {\n            throw new Error(`Image's \"src\" or \"source\" prop returned ${source}`);\n        }\n        node.image = await resolveImage(source, { cache });\n        if (Buffer.isBuffer(source) || source instanceof Blob)\n            return;\n        node.image.key = 'data' in source ? source.data.toString() : source.uri;\n    }\n    catch (e) {\n        console.warn(e.message);\n    }\n};\n\nconst isImage$2 = (node) => node.type === P.Image;\n/**\n * Get all asset promises that need to be resolved\n *\n * @param fontStore - Font store\n * @param node - Root node\n * @returns Asset promises\n */\nconst fetchAssets = (fontStore, node) => {\n    const promises = [];\n    const listToExplore = node.children?.slice(0) || [];\n    const emojiSource = fontStore ? fontStore.getEmojiSource() : null;\n    while (listToExplore.length > 0) {\n        const n = listToExplore.shift();\n        if (isImage$2(n)) {\n            promises.push(fetchImage(n));\n        }\n        if (fontStore && n.style?.fontFamily) {\n            const fontFamilies = castArray(n.style.fontFamily);\n            promises.push(...fontFamilies.map((fontFamily) => fontStore.load({\n                fontFamily,\n                fontStyle: n.style.fontStyle,\n                fontWeight: n.style.fontWeight,\n            })));\n        }\n        if (typeof n === 'string') {\n            promises.push(...fetchEmojis(n, emojiSource));\n        }\n        if ('value' in n && typeof n.value === 'string') {\n            promises.push(...fetchEmojis(n.value, emojiSource));\n        }\n        if (n.children) {\n            n.children.forEach((childNode) => {\n                listToExplore.push(childNode);\n            });\n        }\n    }\n    return promises;\n};\n/**\n * Fetch image, font and emoji assets in parallel.\n * Layout process will not be resumed until promise resolves.\n *\n * @param node root node\n * @param fontStore font store\n * @returns Root node\n */\nconst resolveAssets = async (node, fontStore) => {\n    const promises = fetchAssets(fontStore, node);\n    await Promise.all(promises);\n    return node;\n};\n\nconst isLink$1 = (node) => node.type === P.Link;\nconst DEFAULT_LINK_STYLES = {\n    color: 'blue',\n    textDecoration: 'underline',\n};\n/**\n * Computes styles using stylesheet\n *\n * @param container\n * @param node - Document node\n * @returns Computed styles\n */\nconst computeStyle = (container, node) => {\n    let baseStyle = [node.style];\n    if (isLink$1(node)) {\n        baseStyle = Array.isArray(node.style)\n            ? [DEFAULT_LINK_STYLES, ...node.style]\n            : [DEFAULT_LINK_STYLES, node.style];\n    }\n    return resolveStyle(container, baseStyle);\n};\n/**\n * Resolves node styles\n *\n * @param container\n * @returns Resolve node styles\n */\nconst resolveNodeStyles = (container) => (node) => {\n    const style = computeStyle(container, node);\n    if (!node.children)\n        return Object.assign({}, node, { style });\n    const children = node.children.map(resolveNodeStyles(container));\n    return Object.assign({}, node, { style, children });\n};\n/**\n * Resolves page styles\n *\n * @param page Document page\n * @returns Document page with resolved styles\n */\nconst resolvePageStyles = (page) => {\n    const dpi = page.props?.dpi || 72;\n    const style = page.style;\n    const width = page.box?.width || style.width;\n    const height = page.box?.height || style.height;\n    const orientation = page.props?.orientation || 'portrait';\n    const remBase = style?.fontSize || 18;\n    const container = { width, height, orientation, dpi, remBase };\n    return resolveNodeStyles(container)(page);\n};\n/**\n * Resolves document styles\n *\n * @param root - Document root\n * @returns Document root with resolved styles\n */\nconst resolveStyles = (root) => {\n    if (!root.children)\n        return root;\n    const children = root.children.map(resolvePageStyles);\n    return Object.assign({}, root, { children });\n};\n\nconst getTransformStyle = (s) => (node) => isNil(node.style?.[s]) ? '50%' : node.style?.[s] ?? null;\n/**\n * Get node origin\n *\n * @param node\n * @returns {{ left?: number, top?: number }} node origin\n */\nconst getOrigin = (node) => {\n    if (!node.box)\n        return null;\n    const { left, top, width, height } = node.box;\n    const transformOriginX = getTransformStyle('transformOriginX')(node);\n    const transformOriginY = getTransformStyle('transformOriginY')(node);\n    const percentX = matchPercent(transformOriginX);\n    const percentY = matchPercent(transformOriginY);\n    const offsetX = percentX ? width * percentX.percent : transformOriginX;\n    const offsetY = percentY ? height * percentY.percent : transformOriginY;\n    if (isNil(offsetX) || typeof offsetX === 'string')\n        throw new Error(`Invalid origin offsetX: ${offsetX}`);\n    if (isNil(offsetY) || typeof offsetY === 'string')\n        throw new Error(`Invalid origin offsetY: ${offsetY}`);\n    return { left: left + offsetX, top: top + offsetY };\n};\n\n/**\n * Resolve node origin\n *\n * @param node\n * @returns Node with origin attribute\n */\nconst resolveNodeOrigin = (node) => {\n    const origin = getOrigin(node);\n    const newNode = Object.assign({}, node, { origin });\n    if (!node.children)\n        return newNode;\n    const children = node.children.map(resolveNodeOrigin);\n    return Object.assign({}, newNode, { children });\n};\n/**\n * Resolve document origins\n *\n * @param root - Document root\n * @returns Document root\n */\nconst resolveOrigin = (root) => {\n    if (!root.children)\n        return root;\n    const children = root.children.map(resolveNodeOrigin);\n    return Object.assign({}, root, { children });\n};\n\nconst getBookmarkValue = (bookmark) => {\n    return typeof bookmark === 'string'\n        ? { title: bookmark, fit: false, expanded: false }\n        : bookmark;\n};\nconst resolveBookmarks = (node) => {\n    let refs = 0;\n    const children = (node.children || []).slice(0);\n    const listToExplore = children.map((value) => ({\n        value,\n        parent: null,\n    }));\n    while (listToExplore.length > 0) {\n        const element = listToExplore.shift();\n        if (!element)\n            break;\n        const child = element.value;\n        let parent = element.parent;\n        if (child.props && 'bookmark' in child.props) {\n            const bookmark = getBookmarkValue(child.props.bookmark);\n            const ref = refs++;\n            const newHierarchy = { ref, parent: parent?.ref, ...bookmark };\n            child.props.bookmark = newHierarchy;\n            parent = newHierarchy;\n        }\n        if (child.children) {\n            child.children.forEach((childNode) => {\n                listToExplore.push({ value: childNode, parent });\n            });\n        }\n    }\n    return node;\n};\n\nconst VALID_ORIENTATIONS = ['portrait', 'landscape'];\n/**\n * Get page orientation. Defaults to portrait\n *\n * @param page - Page object\n * @returns Page orientation\n */\nconst getOrientation = (page) => {\n    const value = page.props?.orientation || 'portrait';\n    return VALID_ORIENTATIONS.includes(value) ? value : 'portrait';\n};\n\n/**\n * Return true if page is landscape\n *\n * @param page - Page instance\n * @returns Is page landscape\n */\nconst isLandscape = (page) => getOrientation(page) === 'landscape';\n\n// Page sizes for 72dpi. 72dpi is used internally by pdfkit.\nconst PAGE_SIZES = {\n    '4A0': [4767.87, 6740.79],\n    '2A0': [3370.39, 4767.87],\n    A0: [2383.94, 3370.39],\n    A1: [1683.78, 2383.94],\n    A2: [1190.55, 1683.78],\n    A3: [841.89, 1190.55],\n    A4: [595.28, 841.89],\n    A5: [419.53, 595.28],\n    A6: [297.64, 419.53],\n    A7: [209.76, 297.64],\n    A8: [147.4, 209.76],\n    A9: [104.88, 147.4],\n    A10: [73.7, 104.88],\n    B0: [2834.65, 4008.19],\n    B1: [2004.09, 2834.65],\n    B2: [1417.32, 2004.09],\n    B3: [1000.63, 1417.32],\n    B4: [708.66, 1000.63],\n    B5: [498.9, 708.66],\n    B6: [354.33, 498.9],\n    B7: [249.45, 354.33],\n    B8: [175.75, 249.45],\n    B9: [124.72, 175.75],\n    B10: [87.87, 124.72],\n    C0: [2599.37, 3676.54],\n    C1: [1836.85, 2599.37],\n    C2: [1298.27, 1836.85],\n    C3: [918.43, 1298.27],\n    C4: [649.13, 918.43],\n    C5: [459.21, 649.13],\n    C6: [323.15, 459.21],\n    C7: [229.61, 323.15],\n    C8: [161.57, 229.61],\n    C9: [113.39, 161.57],\n    C10: [79.37, 113.39],\n    RA0: [2437.8, 3458.27],\n    RA1: [1729.13, 2437.8],\n    RA2: [1218.9, 1729.13],\n    RA3: [864.57, 1218.9],\n    RA4: [609.45, 864.57],\n    SRA0: [2551.18, 3628.35],\n    SRA1: [1814.17, 2551.18],\n    SRA2: [1275.59, 1814.17],\n    SRA3: [907.09, 1275.59],\n    SRA4: [637.8, 907.09],\n    EXECUTIVE: [521.86, 756.0],\n    FOLIO: [612.0, 936.0],\n    LEGAL: [612.0, 1008.0],\n    LETTER: [612.0, 792.0],\n    TABLOID: [792.0, 1224.0],\n    ID1: [153, 243],\n};\n/**\n * Parses scalar value in value and unit pairs\n *\n * @param value - Scalar value\n * @returns Parsed value\n */\nconst parseValue = (value) => {\n    if (typeof value === 'number')\n        return { value, unit: undefined };\n    const match = /^(-?\\d*\\.?\\d+)(in|mm|cm|pt|px)?$/g.exec(value);\n    return match\n        ? { value: parseFloat(match[1]), unit: match[2] || 'pt' }\n        : { value, unit: undefined };\n};\n/**\n * Transform given scalar value to 72dpi equivalent of size\n *\n * @param value - Styles value\n * @param inputDpi - User defined dpi\n * @returns Transformed value\n */\nconst transformUnit = (value, inputDpi) => {\n    if (!value)\n        return 0;\n    const scalar = parseValue(value);\n    const outputDpi = 72;\n    const mmFactor = (1 / 25.4) * outputDpi;\n    const cmFactor = (1 / 2.54) * outputDpi;\n    if (typeof scalar.value === 'string')\n        throw new Error(`Invalid page size: ${value}`);\n    switch (scalar.unit) {\n        case 'in':\n            return scalar.value * outputDpi;\n        case 'mm':\n            return scalar.value * mmFactor;\n        case 'cm':\n            return scalar.value * cmFactor;\n        case 'px':\n            return Math.round(scalar.value * (outputDpi / inputDpi));\n        default:\n            return scalar.value;\n    }\n};\nconst transformUnits = ({ width, height }, dpi) => ({\n    width: transformUnit(width, dpi),\n    height: transformUnit(height, dpi),\n});\n/**\n * Transforms array into size object\n *\n * @param v - Values array\n * @returns Size object with width and height\n */\nconst toSizeObject = (v) => ({\n    width: v[0],\n    height: v[1],\n});\n/**\n * Flip size object\n *\n * @param v - Size object\n * @returns Flipped size object\n */\nconst flipSizeObject = (v) => ({\n    width: v.height,\n    height: v.width,\n});\n/**\n * Returns size object from a given string\n *\n * @param v - Page size string\n * @returns Size object with width and height\n */\nconst getStringSize = (v) => {\n    return toSizeObject(PAGE_SIZES[v.toUpperCase()]);\n};\n/**\n * Returns size object from a single number\n *\n * @param n - Page size number\n * @returns Size object with width and height\n */\nconst getNumberSize = (n) => toSizeObject([n, n]);\n/**\n * Return page size in an object { width, height }\n *\n * @param page - Page node\n * @returns Size object with width and height\n */\nconst getSize = (page) => {\n    const value = page.props?.size || 'A4';\n    const dpi = page.props?.dpi || 72;\n    let size;\n    if (typeof value === 'string') {\n        size = getStringSize(value);\n    }\n    else if (Array.isArray(value)) {\n        size = transformUnits(toSizeObject(value), dpi);\n    }\n    else if (typeof value === 'number') {\n        size = transformUnits(getNumberSize(value), dpi);\n    }\n    else {\n        size = transformUnits(value, dpi);\n    }\n    return isLandscape(page) ? flipSizeObject(size) : size;\n};\n\n/**\n * Resolves page size\n *\n * @param page\n * @returns Page with resolved size in style attribute\n */\nconst resolvePageSize = (page) => {\n    const size = getSize(page);\n    const style = flatten(page.style || {});\n    return { ...page, style: { ...style, ...size } };\n};\n/**\n * Resolves page sizes\n *\n * @param root  -Document root\n * @returns Document root with resolved page sizes\n */\nconst resolvePageSizes = (root) => {\n    if (!root.children)\n        return root;\n    const children = root.children.map(resolvePageSize);\n    return Object.assign({}, root, { children });\n};\n\nconst isFixed = (node) => {\n    if (!node.props)\n        return false;\n    return 'fixed' in node.props ? node.props.fixed === true : false;\n};\n\n/**\n * Get line index at given height\n *\n * @param node\n * @param height\n */\nconst lineIndexAtHeight = (node, height) => {\n    let y = 0;\n    if (!node.lines)\n        return 0;\n    for (let i = 0; i < node.lines.length; i += 1) {\n        const line = node.lines[i];\n        if (y + line.box.height > height)\n            return i;\n        y += line.box.height;\n    }\n    return node.lines.length;\n};\n\n/**\n * Get height for given text line index\n *\n * @param node\n * @param index\n */\nconst heightAtLineIndex = (node, index) => {\n    let counter = 0;\n    if (!node.lines)\n        return counter;\n    for (let i = 0; i < index; i += 1) {\n        const line = node.lines[i];\n        if (!line)\n            break;\n        counter += line.box.height;\n    }\n    return counter;\n};\n\nconst getLineBreak = (node, height) => {\n    const top = node.box?.top || 0;\n    const widows = node.props.widows || 2;\n    const orphans = node.props.orphans || 2;\n    const linesQuantity = node.lines.length;\n    const slicedLine = lineIndexAtHeight(node, height - top);\n    if (slicedLine === 0) {\n        return 0;\n    }\n    if (linesQuantity < orphans) {\n        return linesQuantity;\n    }\n    if (slicedLine < orphans || linesQuantity < orphans + widows) {\n        return 0;\n    }\n    if (linesQuantity === orphans + widows) {\n        return orphans;\n    }\n    if (linesQuantity - slicedLine < widows) {\n        return linesQuantity - widows;\n    }\n    return slicedLine;\n};\n// Also receives contentArea in case it's needed\nconst splitText = (node, height) => {\n    const slicedLineIndex = getLineBreak(node, height);\n    const currentHeight = heightAtLineIndex(node, slicedLineIndex);\n    const nextHeight = node.box.height - currentHeight;\n    const current = Object.assign({}, node, {\n        box: {\n            ...node.box,\n            height: currentHeight,\n            borderBottomWidth: 0,\n        },\n        style: {\n            ...node.style,\n            marginBottom: 0,\n            paddingBottom: 0,\n            borderBottomWidth: 0,\n            borderBottomLeftRadius: 0,\n            borderBottomRightRadius: 0,\n        },\n        lines: node.lines.slice(0, slicedLineIndex),\n    });\n    const next = Object.assign({}, node, {\n        box: {\n            ...node.box,\n            top: 0,\n            height: nextHeight,\n            borderTopWidth: 0,\n        },\n        style: {\n            ...node.style,\n            marginTop: 0,\n            paddingTop: 0,\n            borderTopWidth: 0,\n            borderTopLeftRadius: 0,\n            borderTopRightRadius: 0,\n        },\n        lines: node.lines.slice(slicedLineIndex),\n    });\n    return [current, next];\n};\n\nconst getTop$1 = (node) => node.box?.top || 0;\nconst hasFixedHeight = (node) => !isNil(node.style?.height);\nconst splitNode = (node, height) => {\n    if (!node)\n        return [null, null];\n    const nodeTop = getTop$1(node);\n    const current = Object.assign({}, node, {\n        box: {\n            ...node.box,\n            borderBottomWidth: 0,\n        },\n        style: {\n            ...node.style,\n            marginBottom: 0,\n            paddingBottom: 0,\n            borderBottomWidth: 0,\n            borderBottomLeftRadius: 0,\n            borderBottomRightRadius: 0,\n        },\n    });\n    current.style.height = height - nodeTop;\n    const nextHeight = hasFixedHeight(node)\n        ? node.box.height - (height - nodeTop)\n        : null;\n    const next = Object.assign({}, node, {\n        box: {\n            ...node.box,\n            top: 0,\n            borderTopWidth: 0,\n        },\n        style: {\n            ...node.style,\n            marginTop: 0,\n            paddingTop: 0,\n            borderTopWidth: 0,\n            borderTopLeftRadius: 0,\n            borderTopRightRadius: 0,\n        },\n    });\n    if (nextHeight) {\n        next.style.height = nextHeight;\n    }\n    return [current, next];\n};\n\nconst NON_WRAP_TYPES = [P.Svg, P.Note, P.Image, P.Canvas];\nconst getWrap = (node) => {\n    if (NON_WRAP_TYPES.includes(node.type))\n        return false;\n    if (!node.props)\n        return true;\n    return 'wrap' in node.props ? node.props.wrap : true;\n};\n\nconst getComputedPadding = (node, edge) => {\n    const { yogaNode } = node;\n    return yogaNode ? yogaNode.getComputedPadding(edge) : null;\n};\n/**\n * Get Yoga computed paddings. Zero otherwise\n *\n * @param  node\n * @returns paddings\n */\nconst getPadding = (node) => {\n    const { style, box } = node;\n    const paddingTop = getComputedPadding(node, Yoga.Edge.Top) ||\n        box?.paddingTop ||\n        style?.paddingTop ||\n        0;\n    const paddingRight = getComputedPadding(node, Yoga.Edge.Right) ||\n        box?.paddingRight ||\n        style?.paddingRight ||\n        0;\n    const paddingBottom = getComputedPadding(node, Yoga.Edge.Bottom) ||\n        box?.paddingBottom ||\n        style?.paddingBottom ||\n        0;\n    const paddingLeft = getComputedPadding(node, Yoga.Edge.Left) ||\n        box?.paddingLeft ||\n        style?.paddingLeft ||\n        0;\n    return { paddingTop, paddingRight, paddingBottom, paddingLeft };\n};\n\nconst getWrapArea = (page) => {\n    const height = page.style?.height;\n    const { paddingBottom } = getPadding(page);\n    return height - paddingBottom;\n};\n\nconst getContentArea = (page) => {\n    const height = page.style?.height;\n    const { paddingTop, paddingBottom } = getPadding(page);\n    return height - paddingBottom - paddingTop;\n};\n\nconst isString = (value) => typeof value === 'string';\nconst isNumber = (value) => typeof value === 'number';\nconst isBoolean = (value) => typeof value === 'boolean';\nconst isFragment = (value) => value && value.type === Symbol.for('react.fragment');\n/**\n * Transforms a react element instance to internal element format.\n *\n * Can return multiple instances in the case of arrays or fragments.\n *\n * @param element - React element\n * @returns Parsed React elements\n */\nconst createInstances = (element) => {\n    if (!element)\n        return [];\n    if (Array.isArray(element)) {\n        return element.reduce((acc, el) => acc.concat(createInstances(el)), []);\n    }\n    if (isBoolean(element)) {\n        return [];\n    }\n    if (isString(element) || isNumber(element)) {\n        return [{ type: P.TextInstance, value: `${element}` }];\n    }\n    if (isFragment(element)) {\n        // @ts-expect-error figure out why this is complains\n        return createInstances(element.props.children);\n    }\n    if (!isString(element.type)) {\n        // @ts-expect-error figure out why this is complains\n        return createInstances(element.type(element.props));\n    }\n    const { type, props: { style = {}, children, ...props }, } = element;\n    const nextChildren = castArray(children).reduce((acc, child) => acc.concat(createInstances(child)), []);\n    return [\n        {\n            type,\n            style,\n            props,\n            children: nextChildren,\n        },\n    ];\n};\n\nconst getBreak = (node) => 'break' in node.props ? node.props.break : false;\nconst getMinPresenceAhead = (node) => 'minPresenceAhead' in node.props ? node.props.minPresenceAhead : 0;\nconst getFurthestEnd = (elements) => Math.max(...elements.map((node) => node.box.top + node.box.height));\nconst getEndOfMinPresenceAhead = (child) => {\n    return (child.box.top +\n        child.box.height +\n        child.box.marginBottom +\n        getMinPresenceAhead(child));\n};\nconst getEndOfPresence = (child, futureElements) => {\n    const afterMinPresenceAhead = getEndOfMinPresenceAhead(child);\n    const endOfFurthestFutureElement = getFurthestEnd(futureElements.filter((node) => !('fixed' in node.props)));\n    return Math.min(afterMinPresenceAhead, endOfFurthestFutureElement);\n};\nconst shouldBreak = (child, futureElements, height) => {\n    if ('fixed' in child.props)\n        return false;\n    const shouldSplit = height < child.box.top + child.box.height;\n    const canWrap = getWrap(child);\n    // Calculate the y coordinate where the desired presence of the child ends\n    const endOfPresence = getEndOfPresence(child, futureElements);\n    // If the child is already at the top of the page, breaking won't improve its presence\n    // (as long as react-pdf does not support breaking into differently sized containers)\n    const breakingImprovesPresence = child.box.top > child.box.marginTop;\n    return (getBreak(child) ||\n        (shouldSplit && !canWrap) ||\n        (!shouldSplit && endOfPresence > height && breakingImprovesPresence));\n};\n\nconst IGNORABLE_CODEPOINTS = [\n    8232, // LINE_SEPARATOR\n    8233, // PARAGRAPH_SEPARATOR\n];\nconst buildSubsetForFont = (font) => IGNORABLE_CODEPOINTS.reduce((acc, codePoint) => {\n    if (font &&\n        font.hasGlyphForCodePoint &&\n        font.hasGlyphForCodePoint(codePoint)) {\n        return acc;\n    }\n    return [...acc, String.fromCharCode(codePoint)];\n}, []);\nconst ignoreChars = (fragments) => fragments.map((fragment) => {\n    const charSubset = buildSubsetForFont(fragment.attributes.font[0]);\n    const subsetRegex = new RegExp(charSubset.join('|'));\n    return {\n        string: fragment.string.replace(subsetRegex, ''),\n        attributes: fragment.attributes,\n    };\n});\n\nconst PREPROCESSORS = [ignoreChars, embedEmojis];\nconst isImage$1 = (node) => node.type === P.Image;\nconst isTextInstance$2 = (node) => node.type === P.TextInstance;\n/**\n * Get textkit fragments of given node object\n *\n * @param fontStore - Font store\n * @param instance - Node\n * @param parentLink - Parent link\n * @param level - Fragment level\n * @returns Text fragments\n */\nconst getFragments = (fontStore, instance, parentLink = null, level = 0) => {\n    if (!instance)\n        return [{ string: '' }];\n    let fragments = [];\n    const { color = 'black', direction = 'ltr', fontFamily = 'Helvetica', fontWeight, fontStyle, fontSize = 18, textAlign, lineHeight, textDecoration, textDecorationColor, textDecorationStyle, textTransform, letterSpacing, textIndent, opacity, verticalAlign, } = instance.style;\n    const fontFamilies = typeof fontFamily === 'string' ? [fontFamily] : [...(fontFamily || [])];\n    // Fallback font\n    fontFamilies.push('Helvetica');\n    const font = fontFamilies.map((fontFamilyName) => {\n        const opts = { fontFamily: fontFamilyName, fontWeight, fontStyle };\n        const obj = fontStore.getFont(opts);\n        return obj?.data;\n    });\n    // Don't pass main background color to textkit. Will be rendered by the render package instead\n    const backgroundColor = level === 0 ? null : instance.style.backgroundColor;\n    const attributes = {\n        font,\n        color,\n        opacity,\n        fontSize,\n        lineHeight,\n        direction,\n        verticalAlign,\n        backgroundColor,\n        indent: textIndent,\n        characterSpacing: letterSpacing,\n        strikeStyle: textDecorationStyle,\n        underlineStyle: textDecorationStyle,\n        underline: textDecoration === 'underline' ||\n            textDecoration === 'underline line-through' ||\n            textDecoration === 'line-through underline',\n        strike: textDecoration === 'line-through' ||\n            textDecoration === 'underline line-through' ||\n            textDecoration === 'line-through underline',\n        strikeColor: textDecorationColor || color,\n        underlineColor: textDecorationColor || color,\n        // @ts-expect-error allow this props access\n        link: parentLink || instance.props?.src || instance.props?.href,\n        align: textAlign || (direction === 'rtl' ? 'right' : 'left'),\n    };\n    for (let i = 0; i < instance.children.length; i += 1) {\n        const child = instance.children[i];\n        if (isImage$1(child)) {\n            fragments.push({\n                string: String.fromCharCode(0xfffc),\n                attributes: {\n                    ...attributes,\n                    attachment: {\n                        width: (child.style.width || fontSize),\n                        height: (child.style.height || fontSize),\n                        image: child.image.data,\n                    },\n                },\n            });\n        }\n        else if (isTextInstance$2(child)) {\n            fragments.push({\n                string: transformText(child.value, textTransform),\n                attributes,\n            });\n        }\n        else if (child) {\n            fragments.push(...getFragments(fontStore, child, attributes.link, level + 1));\n        }\n    }\n    for (let i = 0; i < PREPROCESSORS.length; i += 1) {\n        const preprocessor = PREPROCESSORS[i];\n        fragments = preprocessor(fragments);\n    }\n    return fragments;\n};\n/**\n * Get textkit attributed string from text node\n *\n * @param fontStore - Font store\n * @param instance Node\n * @returns Attributed string\n */\nconst getAttributedString = (fontStore, instance) => {\n    const fragments = getFragments(fontStore, instance);\n    return fromFragments(fragments);\n};\n\nconst engines = {\n    bidi,\n    linebreaker,\n    justification,\n    textDecoration,\n    scriptItemizer,\n    wordHyphenation,\n    fontSubstitution,\n};\nconst engine = layoutEngine(engines);\nconst getMaxLines = (node) => node.style?.maxLines;\nconst getTextOverflow = (node) => node.style?.textOverflow;\n/**\n * Get layout container for specific text node\n *\n * @param {number} width\n * @param {number} height\n * @param {Object} node\n * @returns {Object} layout container\n */\nconst getContainer = (width, height, node) => {\n    const maxLines = getMaxLines(node);\n    const textOverflow = getTextOverflow(node);\n    return {\n        x: 0,\n        y: 0,\n        width,\n        maxLines,\n        height: height || Infinity,\n        truncateMode: textOverflow,\n    };\n};\n/**\n * Get text layout options for specific text node\n *\n * @param {Object} node instance\n * @returns {Object} layout options\n */\nconst getLayoutOptions = (fontStore, node) => ({\n    hyphenationPenalty: node.props.hyphenationPenalty,\n    shrinkWhitespaceFactor: { before: -0.5, after: -0.5 },\n    hyphenationCallback: node.props.hyphenationCallback ||\n        fontStore?.getHyphenationCallback() ||\n        null,\n});\n/**\n * Get text lines for given node\n *\n * @param node - Node\n * @param width - Container width\n * @param height - Container height\n * @param fontStore - Font store\n * @returns Layout lines\n */\nconst layoutText = (node, width, height, fontStore) => {\n    const attributedString = getAttributedString(fontStore, node);\n    const container = getContainer(width, height, node);\n    const options = getLayoutOptions(fontStore, node);\n    const lines = engine(attributedString, container, options);\n    return lines.reduce((acc, line) => [...acc, ...line], []);\n};\n\nconst isSvg$2 = (node) => node.type === P.Svg;\nconst isText$4 = (node) => node.type === P.Text;\nconst shouldIterate = (node) => !isSvg$2(node) && !isText$4(node);\nconst shouldLayoutText = (node) => isText$4(node) && !node.lines;\n/**\n * Performs text layout on text node if wasn't calculated before.\n * Text layout is usually performed on Yoga's layout process (via setMeasureFunc),\n * but we need to layout those nodes with fixed width and height.\n *\n * @param node\n * @returns Layout node\n */\nconst resolveTextLayout = (node, fontStore) => {\n    if (shouldLayoutText(node)) {\n        const width = node.box.width - (node.box.paddingRight + node.box.paddingLeft);\n        const height = node.box.height - (node.box.paddingTop + node.box.paddingBottom);\n        node.lines = layoutText(node, width, height, fontStore);\n    }\n    if (shouldIterate(node)) {\n        if (!node.children)\n            return node;\n        const mapChild = (child) => resolveTextLayout(child, fontStore);\n        const children = node.children.map(mapChild);\n        return Object.assign({}, node, { children });\n    }\n    return node;\n};\n\nconst BASE_INHERITABLE_PROPERTIES = [\n    'color',\n    'fontFamily',\n    'fontSize',\n    'fontStyle',\n    'fontWeight',\n    'letterSpacing',\n    'opacity',\n    'textDecoration',\n    'textTransform',\n    'lineHeight',\n    'textAlign',\n    'visibility',\n    'wordSpacing',\n];\nconst TEXT_INHERITABLE_PROPERTIES = [\n    ...BASE_INHERITABLE_PROPERTIES,\n    'backgroundColor',\n];\nconst isType$2 = (type) => (node) => node.type === type;\nconst isSvg$1 = isType$2(P.Svg);\nconst isText$3 = isType$2(P.Text);\n// Merge style values\nconst mergeValues = (styleName, value, inheritedValue) => {\n    switch (styleName) {\n        case 'textDecoration': {\n            // merge not none and not false textDecoration values to one rule\n            return [inheritedValue, value].filter((v) => v && v !== 'none').join(' ');\n        }\n        default:\n            return value;\n    }\n};\n// Merge inherited and node styles\nconst merge = (inheritedStyles, style) => {\n    const mergedStyles = { ...inheritedStyles };\n    Object.entries(style).forEach(([styleName, value]) => {\n        mergedStyles[styleName] = mergeValues(styleName, value, inheritedStyles[styleName]);\n    });\n    return mergedStyles;\n};\n/**\n * Merges styles with node\n *\n * @param inheritedStyles - Style object\n * @returns Merge styles function\n */\nconst mergeStyles = (inheritedStyles) => (node) => {\n    const style = merge(inheritedStyles, node.style || {});\n    return Object.assign({}, node, { style });\n};\n/**\n * Inherit style values from the root to the leafs\n *\n * @param node - Document root\n * @returns Document root with inheritance\n *\n */\nconst resolveInheritance = (node) => {\n    if (isSvg$1(node))\n        return node;\n    if (!('children' in node))\n        return node;\n    const inheritableProperties = isText$3(node)\n        ? TEXT_INHERITABLE_PROPERTIES\n        : BASE_INHERITABLE_PROPERTIES;\n    const inheritStyles = pick(inheritableProperties, node.style || {});\n    const resolveChild = compose(resolveInheritance, mergeStyles(inheritStyles));\n    const children = node.children.map(resolveChild);\n    return Object.assign({}, node, { children });\n};\n\nconst getComputedMargin = (node, edge) => {\n    const { yogaNode } = node;\n    return yogaNode ? yogaNode.getComputedMargin(edge) : null;\n};\n/**\n * Get Yoga computed magins. Zero otherwise\n *\n * @param node\n * @returns Margins\n */\nconst getMargin = (node) => {\n    const { style, box } = node;\n    const marginTop = getComputedMargin(node, Yoga.Edge.Top) ||\n        box?.marginTop ||\n        style?.marginTop ||\n        0;\n    const marginRight = getComputedMargin(node, Yoga.Edge.Right) ||\n        box?.marginRight ||\n        style?.marginRight ||\n        0;\n    const marginBottom = getComputedMargin(node, Yoga.Edge.Bottom) ||\n        box?.marginBottom ||\n        style?.marginBottom ||\n        0;\n    const marginLeft = getComputedMargin(node, Yoga.Edge.Left) ||\n        box?.marginLeft ||\n        style?.marginLeft ||\n        0;\n    return { marginTop, marginRight, marginBottom, marginLeft };\n};\n\n/**\n * Get Yoga computed position. Zero otherwise\n *\n * @param node\n * @returns Position\n */\nconst getPosition = (node) => {\n    const { yogaNode } = node;\n    return {\n        top: yogaNode?.getComputedTop() || 0,\n        right: yogaNode?.getComputedRight() || 0,\n        bottom: yogaNode?.getComputedBottom() || 0,\n        left: yogaNode?.getComputedLeft() || 0,\n    };\n};\n\nconst DEFAULT_DIMENSION = {\n    width: 0,\n    height: 0,\n};\n/**\n * Get Yoga computed dimensions. Zero otherwise\n *\n * @param node\n * @returns Dimensions\n */\nconst getDimension = (node) => {\n    const { yogaNode } = node;\n    if (!yogaNode)\n        return DEFAULT_DIMENSION;\n    return {\n        width: yogaNode.getComputedWidth(),\n        height: yogaNode.getComputedHeight(),\n    };\n};\n\nconst getComputedBorder = (yogaNode, edge) => (yogaNode ? yogaNode.getComputedBorder(edge) : 0);\n/**\n * Get Yoga computed border width. Zero otherwise\n *\n * @param node\n * @returns Border widths\n */\nconst getBorderWidth = (node) => {\n    const { yogaNode } = node;\n    return {\n        borderTopWidth: getComputedBorder(yogaNode, Yoga.Edge.Top),\n        borderRightWidth: getComputedBorder(yogaNode, Yoga.Edge.Right),\n        borderBottomWidth: getComputedBorder(yogaNode, Yoga.Edge.Bottom),\n        borderLeftWidth: getComputedBorder(yogaNode, Yoga.Edge.Left),\n    };\n};\n\n/**\n * Set display attribute to node's Yoga instance\n *\n * @param value - Display\n * @returns Node instance wrapper\n */\nconst setDisplay = (value) => (node) => {\n    const { yogaNode } = node;\n    if (yogaNode) {\n        yogaNode.setDisplay(value === 'none' ? Yoga.Display.None : Yoga.Display.Flex);\n    }\n    return node;\n};\n\nconst OVERFLOW = {\n    hidden: Yoga.Overflow.Hidden,\n    scroll: Yoga.Overflow.Scroll,\n};\n/**\n * Set overflow attribute to node's Yoga instance\n *\n * @param value - Overflow value\n * @returns Node instance wrapper\n */\nconst setOverflow = (value) => (node) => {\n    const { yogaNode } = node;\n    if (!isNil(value) && yogaNode) {\n        const overflow = OVERFLOW[value] || Yoga.Overflow.Visible;\n        yogaNode.setOverflow(overflow);\n    }\n    return node;\n};\n\nconst FLEX_WRAP = {\n    wrap: Yoga.Wrap.Wrap,\n    'wrap-reverse': Yoga.Wrap.WrapReverse,\n};\n/**\n * Set flex wrap attribute to node's Yoga instance\n *\n * @param value - Flex wrap value\n * @returns Node instance wrapper\n */\nconst setFlexWrap = (value) => (node) => {\n    const { yogaNode } = node;\n    if (yogaNode) {\n        const flexWrap = FLEX_WRAP[value] || Yoga.Wrap.NoWrap;\n        yogaNode.setFlexWrap(flexWrap);\n    }\n    return node;\n};\n\n/**\n * Set generic yoga attribute to node's Yoga instance, handing `auto`, edges and percentage cases\n *\n * @param attr - Property\n * @param edge - Edge\n * @returns Node instance wrapper\n */\nconst setYogaValue = (attr, edge) => (value) => (node) => {\n    const { yogaNode } = node;\n    if (!isNil(value) && yogaNode) {\n        const hasEdge = !isNil(edge);\n        const fixedMethod = `set${upperFirst(attr)}`;\n        const autoMethod = `${fixedMethod}Auto`;\n        const percentMethod = `${fixedMethod}Percent`;\n        const percent = matchPercent(value);\n        if (percent && !yogaNode[percentMethod]) {\n            throw new Error(`You can't pass percentage values to ${attr} property`);\n        }\n        if (percent) {\n            if (hasEdge) {\n                yogaNode[percentMethod]?.(edge, percent.value);\n            }\n            else {\n                yogaNode[percentMethod]?.(percent.value);\n            }\n        }\n        else if (value === 'auto') {\n            if (hasEdge) {\n                yogaNode[autoMethod]?.(edge);\n            }\n            else {\n                yogaNode[autoMethod]?.();\n            }\n        }\n        else if (hasEdge) {\n            yogaNode[fixedMethod]?.(edge, value);\n        }\n        else {\n            yogaNode[fixedMethod]?.(value);\n        }\n    }\n    return node;\n};\n\n/**\n * Set flex grow attribute to node's Yoga instance\n *\n * @param  value - Flex grow value\n * @returns Node instance wrapper\n */\nconst setFlexGrow = (value) => (node) => {\n    return setYogaValue('flexGrow')(value || 0)(node);\n};\n\n/**\n * Set flex basis attribute to node's Yoga instance\n *\n * @param flex - Basis value\n * @param node - Node instance\n * @returns Node instance\n */\nconst setFlexBasis = setYogaValue('flexBasis');\n\nconst ALIGN = {\n    'flex-start': Yoga.Align.FlexStart,\n    center: Yoga.Align.Center,\n    'flex-end': Yoga.Align.FlexEnd,\n    stretch: Yoga.Align.Stretch,\n    baseline: Yoga.Align.Baseline,\n    'space-between': Yoga.Align.SpaceBetween,\n    'space-around': Yoga.Align.SpaceAround,\n    'space-evenly': Yoga.Align.SpaceEvenly,\n};\n/**\n * Set generic align attribute to node's Yoga instance\n *\n * @param attr - Specific align property\n * @param value - Specific align value\n * @param node - Node\n * @returns Node\n */\nconst setAlign = (attr) => (value) => (node) => {\n    const { yogaNode } = node;\n    const defaultValue = attr === 'items' ? Yoga.Align.Stretch : Yoga.Align.Auto;\n    if (yogaNode) {\n        const align = ALIGN[value] || defaultValue;\n        yogaNode[`setAlign${upperFirst(attr)}`](align);\n    }\n    return node;\n};\n\n/**\n * Set align self attribute to node's Yoga instance\n *\n * @param align - Value\n * @param node - Node instance\n * @returns Node instance\n */\nconst setAlignSelf = setAlign('self');\n\n/**\n * Set align items attribute to node's Yoga instance\n *\n * @param align - Value\n * @param node - Node instance\n * @returns Node instance\n */\nconst setAlignItems = setAlign('items');\n\n/**\n * Set flex shrink attribute to node's Yoga instance\n *\n * @param value - Flex shrink value\n * @returns Node instance wrapper\n */\nconst setFlexShrink = (value) => (node) => {\n    return setYogaValue('flexShrink')(value || 1)(node);\n};\n\n/**\n * Set aspect ratio attribute to node's Yoga instance\n *\n * @param value - Ratio\n * @returns Node instance\n */\nconst setAspectRatio = (value) => (node) => {\n    const { yogaNode } = node;\n    if (!isNil(value) && yogaNode) {\n        yogaNode.setAspectRatio(value);\n    }\n    return node;\n};\n\n/**\n * Set align content attribute to node's Yoga instance\n *\n * @param align - Value\n * @param node - Instance\n * @returns Node instance\n */\nconst setAlignContent = setAlign('content');\n\nconst POSITION = {\n    absolute: Yoga.PositionType.Absolute,\n    relative: Yoga.PositionType.Relative,\n    static: Yoga.PositionType.Static,\n};\n/**\n * Set position type attribute to node's Yoga instance\n *\n * @param value - Position position type\n * @returns Node instance\n */\nconst setPositionType = (value) => (node) => {\n    const { yogaNode } = node;\n    if (!isNil(value) && yogaNode) {\n        yogaNode.setPositionType(POSITION[value]);\n    }\n    return node;\n};\n\nconst FLEX_DIRECTIONS = {\n    row: Yoga.FlexDirection.Row,\n    'row-reverse': Yoga.FlexDirection.RowReverse,\n    'column-reverse': Yoga.FlexDirection.ColumnReverse,\n};\n/**\n * Set flex direction attribute to node's Yoga instance\n *\n * @param value - Flex direction value\n * @returns Node instance wrapper\n */\nconst setFlexDirection = (value) => (node) => {\n    const { yogaNode } = node;\n    if (yogaNode) {\n        const flexDirection = FLEX_DIRECTIONS[value] || Yoga.FlexDirection.Column;\n        yogaNode.setFlexDirection(flexDirection);\n    }\n    return node;\n};\n\nconst JUSTIFY_CONTENT = {\n    center: Yoga.Justify.Center,\n    'flex-end': Yoga.Justify.FlexEnd,\n    'space-between': Yoga.Justify.SpaceBetween,\n    'space-around': Yoga.Justify.SpaceAround,\n    'space-evenly': Yoga.Justify.SpaceEvenly,\n};\n/**\n * Set justify content attribute to node's Yoga instance\n *\n * @param value - Justify content value\n * @returns Node instance wrapper\n */\nconst setJustifyContent = (value) => (node) => {\n    const { yogaNode } = node;\n    if (!isNil(value) && yogaNode) {\n        const justifyContent = JUSTIFY_CONTENT[value] || Yoga.Justify.FlexStart;\n        yogaNode.setJustifyContent(justifyContent);\n    }\n    return node;\n};\n\n/**\n * Set margin top attribute to node's Yoga instance\n *\n * @param margin - Margin top\n * @param node - Node instance\n * @returns Node instance\n */\nconst setMarginTop = setYogaValue('margin', Yoga.Edge.Top);\n/**\n * Set margin right attribute to node's Yoga instance\n *\n * @param margin - Margin right\n * @param node - Node instance\n * @returns Node instance\n */\nconst setMarginRight = setYogaValue('margin', Yoga.Edge.Right);\n/**\n * Set margin bottom attribute to node's Yoga instance\n *\n * @param margin - Margin bottom\n * @param node - Node instance\n * @returns Node instance\n */\nconst setMarginBottom = setYogaValue('margin', Yoga.Edge.Bottom);\n/**\n * Set margin left attribute to node's Yoga instance\n *\n * @param margin - Margin left\n * @param node - Node instance\n * @returns Node instance\n */\nconst setMarginLeft = setYogaValue('margin', Yoga.Edge.Left);\n\n/**\n * Set padding top attribute to node's Yoga instance\n *\n * @param padding - Padding top\n * @param node - Node instance\n * @returns Node instance\n */\nconst setPaddingTop = setYogaValue('padding', Yoga.Edge.Top);\n/**\n * Set padding right attribute to node's Yoga instance\n *\n * @param padding - Padding right\n * @param node - Node instance\n * @returns Node instance\n */\nconst setPaddingRight = setYogaValue('padding', Yoga.Edge.Right);\n/**\n * Set padding bottom attribute to node's Yoga instance\n *\n * @param padding - Padding bottom\n * @param node Node instance\n * @returns Node instance\n */\nconst setPaddingBottom = setYogaValue('padding', Yoga.Edge.Bottom);\n/**\n * Set padding left attribute to node's Yoga instance\n *\n * @param padding - Padding left\n * @param node - Node instance\n * @returns Node instance\n */\nconst setPaddingLeft = setYogaValue('padding', Yoga.Edge.Left);\n\n/**\n * Set border top attribute to node's Yoga instance\n *\n * @param border - Border top width\n * @param node - Node instance\n * @returns Node instance\n */\nconst setBorderTop = setYogaValue('border', Yoga.Edge.Top);\n/**\n * Set border right attribute to node's Yoga instance\n *\n * @param border - Border right width\n * @param node - Node instance\n * @returns Node instance\n */\nconst setBorderRight = setYogaValue('border', Yoga.Edge.Right);\n/**\n * Set border bottom attribute to node's Yoga instance\n *\n * @param border - Border bottom width\n * @param node - Node instance\n * @returns Node instance\n */\nconst setBorderBottom = setYogaValue('border', Yoga.Edge.Bottom);\n/**\n * Set border left attribute to node's Yoga instance\n *\n * @param border - Border left width\n * @param node - Node instance\n * @returns Node instance\n */\nconst setBorderLeft = setYogaValue('border', Yoga.Edge.Left);\n\n/**\n * Set position top attribute to node's Yoga instance\n *\n * @param position - Position top\n * @param node - Node instance\n * @returns Node instance\n */\nconst setPositionTop = setYogaValue('position', Yoga.Edge.Top);\n/**\n * Set position right attribute to node's Yoga instance\n *\n * @param position - Position right\n * @param node - Node instance\n * @returns Node instance\n */\nconst setPositionRight = setYogaValue('position', Yoga.Edge.Right);\n/**\n * Set position bottom attribute to node's Yoga instance\n *\n * @param position - Position bottom\n * @param node - Node instance\n * @returns Node instance\n */\nconst setPositionBottom = setYogaValue('position', Yoga.Edge.Bottom);\n/**\n * Set position left attribute to node's Yoga instance\n *\n * @param position - Position left\n * @param node - Node instance\n * @returns Node instance\n */\nconst setPositionLeft = setYogaValue('position', Yoga.Edge.Left);\n\n/**\n * Set width to node's Yoga instance\n *\n * @param width - Width\n * @param node - Node instance\n * @returns Node instance\n */\nconst setWidth = setYogaValue('width');\n/**\n * Set min width to node's Yoga instance\n *\n * @param min - Width\n * @param node - Node instance\n * @returns Node instance\n */\nconst setMinWidth = setYogaValue('minWidth');\n/**\n * Set max width to node's Yoga instance\n *\n * @param max - Width\n * @param node - Node instance\n * @returns Node instance\n */\nconst setMaxWidth = setYogaValue('maxWidth');\n/**\n * Set height to node's Yoga instance\n *\n * @param height - Height\n * @param node - Node instance\n * @returns Node instance\n */\nconst setHeight = setYogaValue('height');\n/**\n * Set min height to node's Yoga instance\n *\n * @param min - Height\n * @param node - Node instance\n * @returns Node instance\n */\nconst setMinHeight = setYogaValue('minHeight');\n/**\n * Set max height to node's Yoga instance\n *\n * @param max - Height\n * @param node - Node instance\n * @returns Node instance\n */\nconst setMaxHeight = setYogaValue('maxHeight');\n\n/**\n * Set rowGap value to node's Yoga instance\n *\n * @param value - Gap value\n * @returns Node instance wrapper\n */\nconst setRowGap = setYogaValue('gap', Yoga.Gutter.Row);\n/**\n * Set columnGap value to node's Yoga instance\n *\n * @param value - Gap value\n * @returns Node instance wrapper\n */\nconst setColumnGap = setYogaValue('gap', Yoga.Gutter.Column);\n\nconst getAspectRatio = (viewbox) => {\n    if (!viewbox)\n        return null;\n    if (typeof viewbox === 'string')\n        return null;\n    return (viewbox.maxX - viewbox.minX) / (viewbox.maxY - viewbox.minY);\n};\n/**\n * Yoga svg measure function\n *\n * @param page\n * @param node\n * @returns Measure svg\n */\nconst measureCanvas$1 = (page, node) => (width, widthMode, height, heightMode) => {\n    const aspectRatio = getAspectRatio(node.props.viewBox) || 1;\n    if (widthMode === Yoga.MeasureMode.Exactly ||\n        widthMode === Yoga.MeasureMode.AtMost) {\n        return { width, height: width / aspectRatio };\n    }\n    if (heightMode === Yoga.MeasureMode.Exactly) {\n        return { width: height * aspectRatio };\n    }\n    return {};\n};\n\n/**\n * Get lines width (if any)\n *\n * @param node\n * @returns Lines width\n */\nconst linesWidth = (node) => {\n    if (!node.lines)\n        return 0;\n    return Math.max(0, ...node.lines.map((line) => line.xAdvance));\n};\n\n/**\n * Get lines height (if any)\n *\n * @param node\n * @returns Lines height\n */\nconst linesHeight = (node) => {\n    if (!node.lines)\n        return -1;\n    return node.lines.reduce((acc, line) => acc + line.box.height, 0);\n};\n\nconst ALIGNMENT_FACTORS = { center: 0.5, right: 1 };\n/**\n * Yoga text measure function\n *\n * @param page\n * @param node\n * @param fontStore\n * @returns {MeasureText} measure text function\n */\nconst measureText = (page, node, fontStore) => (width, widthMode, height) => {\n    if (widthMode === Yoga.MeasureMode.Exactly) {\n        if (!node.lines)\n            node.lines = layoutText(node, width, height, fontStore);\n        return { height: linesHeight(node) };\n    }\n    if (widthMode === Yoga.MeasureMode.AtMost) {\n        const alignFactor = ALIGNMENT_FACTORS[node.style?.textAlign] || 0;\n        if (!node.lines) {\n            node.lines = layoutText(node, width, height, fontStore);\n            node.alignOffset = (width - linesWidth(node)) * alignFactor; // Compensate align in variable width containers\n        }\n        return {\n            height: linesHeight(node),\n            width: Math.min(width, linesWidth(node)),\n        };\n    }\n    return {};\n};\n\n/**\n * Get image ratio\n *\n * @param node - Image node\n * @returns Image ratio\n */\nconst getRatio = (node) => {\n    return node.image?.data ? node.image.width / node.image.height : 1;\n};\n\n/**\n * Checks if page has auto height\n *\n * @param page\n * @returns Is page height auto\n */\nconst isHeightAuto = (page) => isNil(page.box?.height);\n\nconst SAFETY_HEIGHT$1 = 10;\n/**\n * Yoga image measure function\n *\n * @param page - Page\n * @param node - Node\n * @returns Measure image\n */\nconst measureImage = (page, node) => (width, widthMode, height, heightMode) => {\n    const imageRatio = getRatio(node);\n    const imageMargin = getMargin(node);\n    const pagePadding = getPadding(page);\n    // TODO: Check image percentage margins\n    const pageArea = isHeightAuto(page)\n        ? Infinity\n        : (page.box?.height || 0) -\n            pagePadding.paddingTop -\n            pagePadding.paddingBottom -\n            imageMargin.marginTop -\n            imageMargin.marginBottom -\n            SAFETY_HEIGHT$1;\n    // Skip measure if image data not present yet\n    if (!node.image)\n        return { width: 0, height: 0 };\n    if (widthMode === Yoga.MeasureMode.Exactly &&\n        heightMode === Yoga.MeasureMode.Undefined) {\n        const scaledHeight = width / imageRatio;\n        return { height: Math.min(pageArea, scaledHeight) };\n    }\n    if (heightMode === Yoga.MeasureMode.Exactly &&\n        (widthMode === Yoga.MeasureMode.AtMost ||\n            widthMode === Yoga.MeasureMode.Undefined)) {\n        return { width: Math.min(height * imageRatio, width) };\n    }\n    if (widthMode === Yoga.MeasureMode.Exactly &&\n        heightMode === Yoga.MeasureMode.AtMost) {\n        const scaledHeight = width / imageRatio;\n        return { height: Math.min(height, pageArea, scaledHeight) };\n    }\n    if (widthMode === Yoga.MeasureMode.AtMost &&\n        heightMode === Yoga.MeasureMode.AtMost) {\n        if (imageRatio > 1) {\n            return {\n                width,\n                height: Math.min(width / imageRatio, height),\n            };\n        }\n        return {\n            height,\n            width: Math.min(height * imageRatio, width),\n        };\n    }\n    return { height, width };\n};\n\nconst SAFETY_HEIGHT = 10;\nconst getMax = (values) => Math.max(-Infinity, ...values);\n/**\n * Helper object to predict canvas size\n * TODO: Implement remaining functions (as close as possible);\n */\nconst measureCtx = () => {\n    const ctx = {};\n    const points = [];\n    const nil = () => ctx;\n    const addPoint = (x, y) => points.push([x, y]);\n    const moveTo = (x, y) => {\n        addPoint(x, y);\n        return ctx;\n    };\n    const rect = (x, y, w, h) => {\n        addPoint(x, y);\n        addPoint(x + w, y);\n        addPoint(x, y + h);\n        addPoint(x + w, y + h);\n        return ctx;\n    };\n    const ellipse = (x, y, rx, ry) => {\n        ry = ry || rx;\n        addPoint(x - rx, y - ry);\n        addPoint(x + rx, y - ry);\n        addPoint(x + rx, y + ry);\n        addPoint(x - rx, y + ry);\n        return ctx;\n    };\n    const polygon = (...pts) => {\n        points.push(...pts);\n        return ctx;\n    };\n    // Change dimensions\n    ctx.rect = rect;\n    ctx.moveTo = moveTo;\n    ctx.lineTo = moveTo;\n    ctx.circle = ellipse;\n    ctx.polygon = polygon;\n    ctx.ellipse = ellipse;\n    ctx.roundedRect = rect;\n    // To be implemented\n    ctx.text = nil;\n    ctx.path = nil;\n    ctx.lineWidth = nil;\n    ctx.bezierCurveTo = nil;\n    ctx.quadraticCurveTo = nil;\n    ctx.scale = nil;\n    ctx.rotate = nil;\n    ctx.translate = nil;\n    // These don't change dimensions\n    ctx.dash = nil;\n    ctx.clip = nil;\n    ctx.save = nil;\n    ctx.fill = nil;\n    ctx.font = nil;\n    ctx.stroke = nil;\n    ctx.lineCap = nil;\n    ctx.opacity = nil;\n    ctx.restore = nil;\n    ctx.lineJoin = nil;\n    ctx.fontSize = nil;\n    ctx.fillColor = nil;\n    ctx.miterLimit = nil;\n    ctx.strokeColor = nil;\n    ctx.fillOpacity = nil;\n    ctx.strokeOpacity = nil;\n    ctx.linearGradient = nil;\n    ctx.radialGradient = nil;\n    ctx.getWidth = () => getMax(points.map((p) => p[0]));\n    ctx.getHeight = () => getMax(points.map((p) => p[1]));\n    return ctx;\n};\n/**\n * @typedef {Function} MeasureCanvas\n * @returns {{ width: number, height: number }} canvas width and height\n */\n/**\n * Yoga canvas measure function\n *\n * @param {Object} page\n * @param {Object} node\n * @returns {MeasureCanvas} measure canvas\n */\nconst measureCanvas = (page, node) => () => {\n    const imageMargin = getMargin(node);\n    const pagePadding = getPadding(page);\n    // TODO: Check image percentage margins\n    const pageArea = isHeightAuto(page)\n        ? Infinity\n        : (page.box?.height || 0) -\n            pagePadding.paddingTop -\n            pagePadding.paddingBottom -\n            imageMargin.marginTop -\n            imageMargin.marginBottom -\n            SAFETY_HEIGHT;\n    const ctx = measureCtx();\n    node.props.paint(ctx);\n    const width = ctx.getWidth();\n    const height = Math.min(pageArea, ctx.getHeight());\n    return { width, height };\n};\n\nconst isType$1 = (type) => (node) => node.type === type;\nconst isSvg = isType$1(P.Svg);\nconst isText$2 = isType$1(P.Text);\nconst isNote = isType$1(P.Note);\nconst isPage = isType$1(P.Page);\nconst isImage = isType$1(P.Image);\nconst isCanvas = isType$1(P.Canvas);\nconst isTextInstance$1 = isType$1(P.TextInstance);\nconst setNodeHeight = (node) => {\n    const value = isPage(node) ? node.box?.height : node.style?.height;\n    return setHeight(value);\n};\n/**\n * Set styles valeus into yoga node before layout calculation\n *\n * @param node\n */\nconst setYogaValues = (node) => {\n    compose(setNodeHeight(node), setWidth(node.style.width), setMinWidth(node.style.minWidth), setMaxWidth(node.style.maxWidth), setMinHeight(node.style.minHeight), setMaxHeight(node.style.maxHeight), setMarginTop(node.style.marginTop), setMarginRight(node.style.marginRight), setMarginBottom(node.style.marginBottom), setMarginLeft(node.style.marginLeft), setPaddingTop(node.style.paddingTop), setPaddingRight(node.style.paddingRight), setPaddingBottom(node.style.paddingBottom), setPaddingLeft(node.style.paddingLeft), setPositionType(node.style.position), setPositionTop(node.style.top), setPositionRight(node.style.right), setPositionBottom(node.style.bottom), setPositionLeft(node.style.left), setBorderTop(node.style.borderTopWidth), setBorderRight(node.style.borderRightWidth), setBorderBottom(node.style.borderBottomWidth), setBorderLeft(node.style.borderLeftWidth), setDisplay(node.style.display), setFlexDirection(node.style.flexDirection), setAlignSelf(node.style.alignSelf), setAlignContent(node.style.alignContent), setAlignItems(node.style.alignItems), setJustifyContent(node.style.justifyContent), setFlexWrap(node.style.flexWrap), setOverflow(node.style.overflow), setAspectRatio(node.style.aspectRatio), setFlexBasis(node.style.flexBasis), setFlexGrow(node.style.flexGrow), setFlexShrink(node.style.flexShrink), setRowGap(node.style.rowGap), setColumnGap(node.style.columnGap))(node);\n};\n/**\n * Inserts child into parent' yoga node\n *\n * @param parent parent\n * @returns Insert yoga nodes\n */\nconst insertYogaNodes = (parent) => (child) => {\n    parent.insertChild(child.yogaNode, parent.getChildCount());\n    return child;\n};\nconst setMeasureFunc = (node, page, fontStore) => {\n    const { yogaNode } = node;\n    if (isText$2(node)) {\n        yogaNode.setMeasureFunc(measureText(page, node, fontStore));\n    }\n    if (isImage(node)) {\n        yogaNode.setMeasureFunc(measureImage(page, node));\n    }\n    if (isCanvas(node)) {\n        yogaNode.setMeasureFunc(measureCanvas(page, node));\n    }\n    if (isSvg(node)) {\n        yogaNode.setMeasureFunc(measureCanvas$1(page, node));\n    }\n    return node;\n};\nconst isLayoutElement = (node) => !isText$2(node) && !isNote(node) && !isSvg(node);\n/**\n * @typedef {Function} CreateYogaNodes\n * @param {Object} node\n * @returns {Object} node with appended yoga node\n */\n/**\n * Creates and add yoga node to document tree\n * Handles measure function for text and image nodes\n *\n * @returns Create yoga nodes\n */\nconst createYogaNodes = (page, fontStore, yoga) => (node) => {\n    const yogaNode = yoga.node.create();\n    const result = Object.assign({}, node, { yogaNode });\n    setYogaValues(result);\n    if (isLayoutElement(node) && node.children) {\n        const resolveChild = compose(insertYogaNodes(yogaNode), createYogaNodes(page, fontStore, yoga));\n        result.children = node.children.map(resolveChild);\n    }\n    setMeasureFunc(result, page, fontStore);\n    return result;\n};\n/**\n * Performs yoga calculation\n *\n * @param page - Page node\n * @returns Page node\n */\nconst calculateLayout = (page) => {\n    page.yogaNode.calculateLayout();\n    return page;\n};\n/**\n * Saves Yoga layout result into 'box' attribute of node\n *\n * @param node\n * @returns Node with box data\n */\nconst persistDimensions = (node) => {\n    if (isTextInstance$1(node))\n        return node;\n    const box = Object.assign(getPadding(node), getMargin(node), getBorderWidth(node), getPosition(node), getDimension(node));\n    const newNode = Object.assign({}, node, { box });\n    if (!node.children)\n        return newNode;\n    const children = node.children.map(persistDimensions);\n    return Object.assign({}, newNode, { children });\n};\n/**\n * Removes yoga node from document tree\n *\n * @param node\n * @returns Node without yoga node\n */\nconst destroyYogaNodes = (node) => {\n    const newNode = Object.assign({}, node);\n    delete newNode.yogaNode;\n    if (!node.children)\n        return newNode;\n    const children = node.children.map(destroyYogaNodes);\n    return Object.assign({}, newNode, { children });\n};\n/**\n * Free yoga node from document tree\n *\n * @param node\n * @returns Node without yoga node\n */\nconst freeYogaNodes = (node) => {\n    if (node.yogaNode)\n        node.yogaNode.freeRecursive();\n    return node;\n};\n/**\n * Calculates page object layout using Yoga.\n * Takes node values from 'box' and 'style' attributes, and persist them back into 'box'\n * Destroy yoga values at the end.\n *\n * @param page - Object\n * @returns Page object with correct 'box' layout attributes\n */\nconst resolvePageDimensions = (page, fontStore, yoga) => {\n    if (isNil(page))\n        return null;\n    return compose(destroyYogaNodes, freeYogaNodes, persistDimensions, calculateLayout, createYogaNodes(page, fontStore, yoga))(page);\n};\n/**\n * Calculates root object layout using Yoga.\n *\n * @param node - Root object\n * @param fontStore - Font store\n * @returns Root object with correct 'box' layout attributes\n */\nconst resolveDimensions = (node, fontStore) => {\n    if (!node.children)\n        return node;\n    const resolveChild = (child) => resolvePageDimensions(child, fontStore, node.yoga);\n    const children = node.children.map(resolveChild);\n    return Object.assign({}, node, { children });\n};\n\nconst isText$1 = (node) => node.type === P.Text;\n// Prevent splitting elements by low decimal numbers\nconst SAFETY_THRESHOLD = 0.001;\nconst assingChildren = (children, node) => Object.assign({}, node, { children });\nconst getTop = (node) => node.box?.top || 0;\nconst allFixed = (nodes) => nodes.every(isFixed);\nconst isDynamic = (node) => node.props && 'render' in node.props;\nconst relayoutPage = compose(resolveTextLayout, resolvePageDimensions, resolveInheritance, resolvePageStyles);\nconst warnUnavailableSpace = (node) => {\n    console.warn(`Node of type ${node.type} can't wrap between pages and it's bigger than available page height`);\n};\nconst splitNodes = (height, contentArea, nodes) => {\n    const currentChildren = [];\n    const nextChildren = [];\n    for (let i = 0; i < nodes.length; i += 1) {\n        const child = nodes[i];\n        const futureNodes = nodes.slice(i + 1);\n        const futureFixedNodes = futureNodes.filter(isFixed);\n        const nodeTop = getTop(child);\n        const nodeHeight = child.box.height;\n        const isOutside = height <= nodeTop;\n        const shouldBreak$1 = shouldBreak(child, futureNodes, height);\n        const shouldSplit = height + SAFETY_THRESHOLD < nodeTop + nodeHeight;\n        const canWrap = getWrap(child);\n        const fitsInsidePage = nodeHeight <= contentArea;\n        if (isFixed(child)) {\n            nextChildren.push(child);\n            currentChildren.push(child);\n            continue;\n        }\n        if (isOutside) {\n            const box = Object.assign({}, child.box, { top: child.box.top - height });\n            const next = Object.assign({}, child, { box });\n            nextChildren.push(next);\n            continue;\n        }\n        if (!fitsInsidePage && !canWrap) {\n            currentChildren.push(child);\n            nextChildren.push(...futureNodes);\n            warnUnavailableSpace(child);\n            break;\n        }\n        if (shouldBreak$1) {\n            const box = Object.assign({}, child.box, { top: child.box.top - height });\n            const props = Object.assign({}, child.props, {\n                wrap: true,\n                break: false,\n            });\n            const next = Object.assign({}, child, { box, props });\n            currentChildren.push(...futureFixedNodes);\n            nextChildren.push(next, ...futureNodes);\n            break;\n        }\n        if (shouldSplit) {\n            const [currentChild, nextChild] = split(child, height, contentArea);\n            // All children are moved to the next page, it doesn't make sense to show the parent on the current page\n            if (child.children.length > 0 && currentChild.children.length === 0) {\n                // But if the current page is empty then we can just include the parent on the current page\n                if (currentChildren.length === 0) {\n                    currentChildren.push(child, ...futureFixedNodes);\n                    nextChildren.push(...futureNodes);\n                }\n                else {\n                    const box = Object.assign({}, child.box, {\n                        top: child.box.top - height,\n                    });\n                    const next = Object.assign({}, child, { box });\n                    currentChildren.push(...futureFixedNodes);\n                    nextChildren.push(next, ...futureNodes);\n                }\n                break;\n            }\n            if (currentChild)\n                currentChildren.push(currentChild);\n            if (nextChild)\n                nextChildren.push(nextChild);\n            continue;\n        }\n        currentChildren.push(child);\n    }\n    return [currentChildren, nextChildren];\n};\nconst splitChildren = (height, contentArea, node) => {\n    const children = node.children || [];\n    const availableHeight = height - getTop(node);\n    return splitNodes(availableHeight, contentArea, children);\n};\nconst splitView = (node, height, contentArea) => {\n    const [currentNode, nextNode] = splitNode(node, height);\n    const [currentChilds, nextChildren] = splitChildren(height, contentArea, node);\n    return [\n        assingChildren(currentChilds, currentNode),\n        assingChildren(nextChildren, nextNode),\n    ];\n};\nconst split = (node, height, contentArea) => isText$1(node) ? splitText(node, height) : splitView(node, height, contentArea);\nconst shouldResolveDynamicNodes = (node) => {\n    const children = node.children || [];\n    return isDynamic(node) || children.some(shouldResolveDynamicNodes);\n};\nconst resolveDynamicNodes = (props, node) => {\n    const isNodeDynamic = isDynamic(node);\n    // Call render prop on dynamic nodes and append result to children\n    const resolveChildren = (children = []) => {\n        if (isNodeDynamic) {\n            const res = node.props.render(props);\n            return (createInstances(res)\n                .filter(Boolean)\n                // @ts-expect-error rework dynamic nodes. conflicting types\n                .map((n) => resolveDynamicNodes(props, n)));\n        }\n        return children.map((c) => resolveDynamicNodes(props, c));\n    };\n    // We reset dynamic text box so it can be computed again later on\n    const resetHeight = isNodeDynamic && isText$1(node);\n    const box = resetHeight ? { ...node.box, height: 0 } : node.box;\n    const children = resolveChildren(node.children);\n    // @ts-expect-error handle text here specifically\n    const lines = isNodeDynamic ? null : node.lines;\n    return Object.assign({}, node, { box, lines, children });\n};\nconst resolveDynamicPage = (props, page, fontStore, yoga) => {\n    if (shouldResolveDynamicNodes(page)) {\n        const resolvedPage = resolveDynamicNodes(props, page);\n        return relayoutPage(resolvedPage, fontStore, yoga);\n    }\n    return page;\n};\nconst splitPage = (page, pageNumber, fontStore, yoga) => {\n    const wrapArea = getWrapArea(page);\n    const contentArea = getContentArea(page);\n    const dynamicPage = resolveDynamicPage({ pageNumber }, page, fontStore, yoga);\n    const height = page.style.height;\n    const [currentChilds, nextChilds] = splitNodes(wrapArea, contentArea, dynamicPage.children);\n    const relayout = (node) => \n    // @ts-expect-error rework pagination\n    relayoutPage(node, fontStore, yoga);\n    const currentBox = { ...page.box, height };\n    const currentPage = relayout(Object.assign({}, page, { box: currentBox, children: currentChilds }));\n    if (nextChilds.length === 0 || allFixed(nextChilds))\n        return [currentPage, null];\n    const nextBox = omit('height', page.box);\n    const nextProps = omit('bookmark', page.props);\n    const nextPage = relayout(Object.assign({}, page, {\n        props: nextProps,\n        box: nextBox,\n        children: nextChilds,\n    }));\n    return [currentPage, nextPage];\n};\nconst resolvePageIndices = (fontStore, yoga, page, pageNumber, pages) => {\n    const totalPages = pages.length;\n    const props = {\n        totalPages,\n        pageNumber: pageNumber + 1,\n        subPageNumber: page.subPageNumber + 1,\n        subPageTotalPages: page.subPageTotalPages,\n    };\n    return resolveDynamicPage(props, page, fontStore, yoga);\n};\nconst assocSubPageData = (subpages) => {\n    return subpages.map((page, i) => ({\n        ...page,\n        subPageNumber: i,\n        subPageTotalPages: subpages.length,\n    }));\n};\nconst dissocSubPageData = (page) => {\n    return omit(['subPageNumber', 'subPageTotalPages'], page);\n};\nconst paginate = (page, pageNumber, fontStore, yoga) => {\n    if (!page)\n        return [];\n    if (page.props?.wrap === false)\n        return [page];\n    let splittedPage = splitPage(page, pageNumber, fontStore, yoga);\n    const pages = [splittedPage[0]];\n    let nextPage = splittedPage[1];\n    while (nextPage !== null) {\n        splittedPage = splitPage(nextPage, pageNumber + pages.length, fontStore, yoga);\n        pages.push(splittedPage[0]);\n        nextPage = splittedPage[1];\n    }\n    return pages;\n};\n/**\n * Performs pagination. This is the step responsible of breaking the whole document\n * into pages following pagiation rules, such as `fixed`, `break` and dynamic nodes.\n *\n * @param root - Document node\n * @param fontStore - Font store\n * @returns Layout node\n */\nconst resolvePagination = (root, fontStore) => {\n    let pages = [];\n    let pageNumber = 1;\n    for (let i = 0; i < root.children.length; i += 1) {\n        const page = root.children[i];\n        let subpages = paginate(page, pageNumber, fontStore, root.yoga);\n        subpages = assocSubPageData(subpages);\n        pageNumber += subpages.length;\n        pages = pages.concat(subpages);\n    }\n    pages = pages.map((...args) => dissocSubPageData(resolvePageIndices(fontStore, root.yoga, ...args)));\n    return assingChildren(pages, root);\n};\n\n/**\n * Translates page percentage horizontal paddings in fixed ones\n *\n * @param container - Page container\n * @returns Resolve page horizontal padding\n */\nconst resolvePageHorizontalPadding = (container) => (value) => {\n    const match = matchPercent(value);\n    const width = container.width;\n    return match ? match.percent * width : value;\n};\n/**\n * Translates page percentage vertical paddings in fixed ones\n *\n * @param container - Page container\n * @returns Resolve page vertical padding\n */\nconst resolvePageVerticalPadding = (container) => (value) => {\n    const match = matchPercent(value);\n    const height = container.height;\n    return match ? match.percent * height : value;\n};\n/**\n * Translates page percentage paddings in fixed ones\n *\n * @param page\n * @returns Page with fixed paddings\n */\nconst resolvePagePaddings = (page) => {\n    const container = page.style;\n    const style = evolve({\n        paddingTop: resolvePageVerticalPadding(container),\n        paddingLeft: resolvePageHorizontalPadding(container),\n        paddingRight: resolvePageHorizontalPadding(container),\n        paddingBottom: resolvePageVerticalPadding(container),\n    }, page.style);\n    return Object.assign({}, page, { style });\n};\n/**\n * Translates all pages percentage paddings in fixed ones\n * This has to be computed from pages calculated size and not by Yoga\n * because at this point we didn't performed pagination yet.\n *\n * @param root - Document root\n * @returns Document root with translated page paddings\n */\nconst resolvePagesPaddings = (root) => {\n    if (!root.children)\n        return root;\n    const children = root.children.map(resolvePagePaddings);\n    return Object.assign({}, root, { children });\n};\n\nconst resolveRadius = (box) => (value) => {\n    if (!value)\n        return undefined;\n    const match = matchPercent(value);\n    return match ? match.percent * Math.min(box.width, box.height) : value;\n};\n/**\n * Transforms percent border radius into fixed values\n *\n * @param node\n * @returns Node\n */\nconst resolvePercentRadius = (node) => {\n    const style = evolve({\n        borderTopLeftRadius: resolveRadius(node.box),\n        borderTopRightRadius: resolveRadius(node.box),\n        borderBottomRightRadius: resolveRadius(node.box),\n        borderBottomLeftRadius: resolveRadius(node.box),\n    }, node.style || {});\n    const newNode = Object.assign({}, node, { style });\n    if (!node.children)\n        return newNode;\n    const children = node.children.map(resolvePercentRadius);\n    return Object.assign({}, newNode, { children });\n};\n\n/**\n * Transform percent height into fixed\n *\n * @param height\n * @returns Height\n */\nconst transformHeight = (pageArea, height) => {\n    const match = matchPercent(height);\n    return match ? match.percent * pageArea : height;\n};\n/**\n * Get page area (height minus paddings)\n *\n * @param page\n * @returns Page area\n */\nconst getPageArea = (page) => {\n    const pageHeight = page.style.height;\n    const pagePaddingTop = (page.style?.paddingTop || 0);\n    const pagePaddingBottom = (page.style?.paddingBottom || 0);\n    return pageHeight - pagePaddingTop - pagePaddingBottom;\n};\n/**\n * Transform node percent height to fixed\n *\n * @param page\n * @param node\n * @returns Transformed node\n */\nconst resolveNodePercentHeight = (page, node) => {\n    if (isNil(page.style?.height))\n        return node;\n    if (isNil(node.style?.height))\n        return node;\n    const pageArea = getPageArea(page);\n    const height = transformHeight(pageArea, node.style.height);\n    const style = Object.assign({}, node.style, { height });\n    return Object.assign({}, node, { style });\n};\n/**\n * Transform page immediate children with percent height to fixed\n *\n * @param page\n * @returns Transformed page\n */\nconst resolvePagePercentHeight = (page) => {\n    if (!page.children)\n        return page;\n    const resolveChild = (child) => resolveNodePercentHeight(page, child);\n    const children = page.children.map(resolveChild);\n    return Object.assign({}, page, { children });\n};\n/**\n * Transform all page immediate children with percent height to fixed.\n * This is needed for computing correct dimensions on pre-pagination layout.\n *\n * @param root - Document root\n * @returns Transformed document root\n */\nconst resolvePercentHeight = (root) => {\n    if (!root.children)\n        return root;\n    const children = root.children.map(resolvePagePercentHeight);\n    return Object.assign({}, root, { children });\n};\n\nconst isType = (type) => (node) => node.type === type;\nconst isLink = isType(P.Link);\nconst isText = isType(P.Text);\nconst isTextInstance = isType(P.TextInstance);\n/**\n * Checks if node has render prop\n *\n * @param node\n * @returns Has render prop?\n */\nconst hasRenderProp = (node) => 'render' in node.props;\n/**\n * Checks if node is text type (Text or TextInstance)\n *\n * @param node\n * @returns Are all children text instances?\n */\nconst isTextType = (node) => isText(node) || isTextInstance(node);\n/**\n * Checks if is tet link that needs to be wrapped in Text\n *\n * @param node\n * @returns Are all children text instances?\n */\nconst isTextLink = (node) => {\n    const children = node.children || [];\n    // Text string inside a Link\n    if (children.every(isTextInstance))\n        return true;\n    // Text node inside a Link\n    if (children.every(isText))\n        return false;\n    return children.every(isTextType);\n};\n/**\n * Wraps node children inside Text node\n *\n * @param node\n * @returns Node with intermediate Text child\n */\nconst wrapText = (node) => {\n    const textElement = {\n        type: P.Text,\n        props: {},\n        style: {},\n        box: {},\n        children: node.children,\n    };\n    return Object.assign({}, node, { children: [textElement] });\n};\nconst transformLink = (node) => {\n    if (!isLink(node))\n        return node;\n    // If has render prop substitute the instance by a Text, that will\n    // ultimately render the inline Link via the textkit PDF renderer.\n    if (hasRenderProp(node))\n        return Object.assign({}, node, { type: P.Text });\n    // If is a text link (either contains Text or TextInstance), wrap it\n    // inside a Text element so styles are applied correctly\n    if (isTextLink(node))\n        return wrapText(node);\n    return node;\n};\n/**\n * Transforms Link layout to correctly render text and dynamic rendered links\n *\n * @param node\n * @returns Node with link substitution\n */\nconst resolveLinkSubstitution = (node) => {\n    if (!node.children)\n        return node;\n    const resolveChild = compose(transformLink, resolveLinkSubstitution);\n    const children = node.children.map(resolveChild);\n    return Object.assign({}, node, { children });\n};\n\nconst layout = asyncCompose(resolveZIndex, resolveOrigin, resolveAssets, resolvePagination, resolveTextLayout, resolvePercentRadius, resolveDimensions, resolveSvg, resolveAssets, resolveInheritance, resolvePercentHeight, resolvePagesPaddings, resolveStyles, resolveLinkSubstitution, resolveBookmarks, resolvePageSizes, resolveYoga);\n\nexport { layout as default };\n"]},"metadata":{},"sourceType":"module"}