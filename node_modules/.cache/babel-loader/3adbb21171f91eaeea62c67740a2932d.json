{"ast":null,"code":"import _classCallCheck from \"C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Base } from './Base.js';\nimport * as utils from './utils.js';\nexport var Struct = /*#__PURE__*/function (_Base) {\n  _inherits(Struct, _Base);\n\n  var _super = _createSuper(Struct);\n\n  function Struct() {\n    var _this;\n\n    var fields = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Struct);\n\n    _this = _super.call(this);\n    _this.fields = fields;\n    return _this;\n  }\n\n  _createClass(Struct, [{\n    key: \"decode\",\n    value: function decode(stream, parent) {\n      var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n      var res = this._setup(stream, parent, length);\n\n      this._parseFields(stream, res, this.fields);\n\n      if (this.process != null) {\n        this.process.call(res, stream);\n      }\n\n      return res;\n    }\n  }, {\n    key: \"_setup\",\n    value: function _setup(stream, parent, length) {\n      var res = {}; // define hidden properties\n\n      Object.defineProperties(res, {\n        parent: {\n          value: parent\n        },\n        _startOffset: {\n          value: stream.pos\n        },\n        _currentOffset: {\n          value: 0,\n          writable: true\n        },\n        _length: {\n          value: length\n        }\n      });\n      return res;\n    }\n  }, {\n    key: \"_parseFields\",\n    value: function _parseFields(stream, res, fields) {\n      for (var key in fields) {\n        var val;\n        var type = fields[key];\n\n        if (typeof type === 'function') {\n          val = type.call(res, res);\n        } else {\n          val = type.decode(stream, res);\n        }\n\n        if (val !== undefined) {\n          if (val instanceof utils.PropertyDescriptor) {\n            Object.defineProperty(res, key, val);\n          } else {\n            res[key] = val;\n          }\n        }\n\n        res._currentOffset = stream.pos - res._startOffset;\n      }\n    }\n  }, {\n    key: \"size\",\n    value: function size(val, parent) {\n      var includePointers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n      if (val == null) {\n        val = {};\n      }\n\n      var ctx = {\n        parent: parent,\n        val: val,\n        pointerSize: 0\n      };\n\n      if (this.preEncode != null) {\n        this.preEncode.call(val);\n      }\n\n      var size = 0;\n\n      for (var key in this.fields) {\n        var type = this.fields[key];\n\n        if (type.size != null) {\n          size += type.size(val[key], ctx);\n        }\n      }\n\n      if (includePointers) {\n        size += ctx.pointerSize;\n      }\n\n      return size;\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(stream, val, parent) {\n      var type;\n\n      if (this.preEncode != null) {\n        this.preEncode.call(val, stream);\n      }\n\n      var ctx = {\n        pointers: [],\n        startOffset: stream.pos,\n        parent: parent,\n        val: val,\n        pointerSize: 0\n      };\n      ctx.pointerOffset = stream.pos + this.size(val, ctx, false);\n\n      for (var key in this.fields) {\n        type = this.fields[key];\n\n        if (type.encode != null) {\n          type.encode(stream, val[key], ctx);\n        }\n      }\n\n      var i = 0;\n\n      while (i < ctx.pointers.length) {\n        var ptr = ctx.pointers[i++];\n        ptr.type.encode(stream, ptr.val, ptr.parent);\n      }\n    }\n  }]);\n\n  return Struct;\n}(Base);","map":{"version":3,"sources":["C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/restructure/src/Struct.js"],"names":["Base","utils","Struct","fields","stream","parent","length","res","_setup","_parseFields","process","call","Object","defineProperties","value","_startOffset","pos","_currentOffset","writable","_length","key","val","type","decode","undefined","PropertyDescriptor","defineProperty","includePointers","ctx","pointerSize","preEncode","size","pointers","startOffset","pointerOffset","encode","i","ptr"],"mappings":"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","sourcesContent":["import {Base} from './Base.js';\nimport * as utils from './utils.js';\n\nexport class Struct extends Base {\n  constructor(fields = {}) {\n    super();\n    this.fields = fields;\n  }\n\n  decode(stream, parent, length = 0) {\n    const res = this._setup(stream, parent, length);\n    this._parseFields(stream, res, this.fields);\n\n    if (this.process != null) {\n      this.process.call(res, stream);\n    }\n    return res;\n  }\n\n  _setup(stream, parent, length) {\n    const res = {};\n\n    // define hidden properties\n    Object.defineProperties(res, {\n      parent:         { value: parent },\n      _startOffset:   { value: stream.pos },\n      _currentOffset: { value: 0, writable: true },\n      _length:        { value: length }\n    });\n\n    return res;\n  }\n\n  _parseFields(stream, res, fields) {\n    for (let key in fields) {\n      var val;\n      const type = fields[key];\n      if (typeof type === 'function') {\n        val = type.call(res, res);\n      } else {\n        val = type.decode(stream, res);\n      }\n\n      if (val !== undefined) {\n        if (val instanceof utils.PropertyDescriptor) {\n          Object.defineProperty(res, key, val);\n        } else {\n          res[key] = val;\n        }\n      }\n\n      res._currentOffset = stream.pos - res._startOffset;\n    }\n\n  }\n\n  size(val, parent, includePointers = true) {\n    if (val == null) { val = {}; }\n    const ctx = {\n      parent,\n      val,\n      pointerSize: 0\n    };\n\n    if (this.preEncode != null) {\n      this.preEncode.call(val);\n    }\n\n    let size = 0;\n    for (let key in this.fields) {\n      const type = this.fields[key];\n      if (type.size != null) {\n        size += type.size(val[key], ctx);\n      }\n    }\n\n    if (includePointers) {\n      size += ctx.pointerSize;\n    }\n\n    return size;\n  }\n\n  encode(stream, val, parent) {\n    let type;\n    if (this.preEncode != null) {\n      this.preEncode.call(val, stream);\n    }\n\n    const ctx = {\n      pointers: [],\n      startOffset: stream.pos,\n      parent,\n      val,\n      pointerSize: 0\n    };\n\n    ctx.pointerOffset = stream.pos + this.size(val, ctx, false);\n\n    for (let key in this.fields) {\n      type = this.fields[key];\n      if (type.encode != null) {\n        type.encode(stream, val[key], ctx);\n      }\n    }\n\n    let i = 0;\n    while (i < ctx.pointers.length) {\n      const ptr = ctx.pointers[i++];\n      ptr.type.encode(stream, ptr.val, ptr.parent);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}