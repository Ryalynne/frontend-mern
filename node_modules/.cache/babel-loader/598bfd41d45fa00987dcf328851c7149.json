{"ast":null,"code":"import * as P from '@react-pdf/primitives';\nimport { isNil, matchPercent } from '@react-pdf/fns';\nimport absPath from 'abs-svg-path';\nimport parsePath from 'parse-svg-path';\nimport normalizePath from 'normalize-svg-path';\nimport colorString from 'color-string';\n\nconst renderPath = (ctx, node) => {\n  const d = node.props?.d;\n  if (d) ctx.path(node.props.d);\n};\n\nconst KAPPA$3 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\n\nconst renderRect = (ctx, node) => {\n  const x = node.props?.x || 0;\n  const y = node.props?.y || 0;\n  const rx = node.props?.rx || 0;\n  const ry = node.props?.ry || 0;\n  const width = node.props?.width || 0;\n  const height = node.props?.height || 0;\n  if (!width || !height) return;\n\n  if (rx && ry) {\n    const krx = rx * KAPPA$3;\n    const kry = ry * KAPPA$3;\n    ctx.moveTo(x + rx, y);\n    ctx.lineTo(x - rx + width, y);\n    ctx.bezierCurveTo(x - rx + width + krx, y, x + width, y + ry - kry, x + width, y + ry);\n    ctx.lineTo(x + width, y + height - ry);\n    ctx.bezierCurveTo(x + width, y + height - ry + kry, x - rx + width + krx, y + height, x - rx + width, y + height);\n    ctx.lineTo(x + rx, y + height);\n    ctx.bezierCurveTo(x + rx - krx, y + height, x, y + height - ry + kry, x, y + height - ry);\n    ctx.lineTo(x, y + ry);\n    ctx.bezierCurveTo(x, y + ry - kry, x + rx - krx, y, x + rx, y);\n  } else {\n    ctx.moveTo(x, y);\n    ctx.lineTo(x + width, y);\n    ctx.lineTo(x + width, y + height);\n    ctx.lineTo(x, y + height);\n  }\n\n  ctx.closePath();\n};\n\nconst renderLine$1 = (ctx, node) => {\n  const {\n    x1,\n    x2,\n    y1,\n    y2\n  } = node.props || {};\n  ctx.moveTo(x1, y1);\n  ctx.lineTo(x2, y2);\n};\n\nconst renderGroup = () => {// noop\n};\n\nconst KAPPA$2 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\n\nconst drawEllipse = function (ctx, rx, ry) {\n  let cx = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  let cy = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  const x = cx - rx;\n  const y = cy - ry;\n  const ox = rx * KAPPA$2;\n  const oy = ry * KAPPA$2;\n  const xe = x + rx * 2;\n  const ye = y + ry * 2;\n  const xm = x + rx;\n  const ym = y + ry;\n  ctx.moveTo(x, ym);\n  ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n  ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n  ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n  ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n  ctx.closePath();\n};\n\nconst renderEllipse = (ctx, node) => {\n  const {\n    cx,\n    cy,\n    rx,\n    ry\n  } = node.props || {};\n  drawEllipse(ctx, rx, ry, cx, cy);\n};\n\nconst renderCircle = (ctx, node) => {\n  const cx = node.props?.cx;\n  const cy = node.props?.cy;\n  const r = node.props?.r;\n  drawEllipse(ctx, r, r, cx, cy);\n};\n/* eslint-disable no-return-assign */\n\n\nconst number = n => {\n  if (n > -1e21 && n < 1e21) {\n    return Math.round(n * 1e6) / 1e6;\n  }\n\n  throw new Error(`unsupported number: ${n}`);\n};\n\nconst _renderGlyphs = (ctx, encoded, positions, x, y) => {\n  const commands = [];\n  const scale = ctx._fontSize / 1000;\n  let i;\n  let last = 0;\n  let hadOffset = false;\n  ctx.save(); // flip coordinate system\n\n  ctx.transform(1, 0, 0, -1, 0, ctx.page.height);\n  y = ctx.page.height - y; // add current font to page if necessary\n\n  if (ctx.page.fonts[ctx._font.id] == null) {\n    ctx.page.fonts[ctx._font.id] = ctx._font.ref();\n  } // begin the text object\n\n\n  ctx.addContent('BT'); // text position\n\n  ctx.addContent(`1 0 0 1 ${number(x)} ${number(y)} Tm`); // font and font size\n\n  ctx.addContent(`/${ctx._font.id} ${number(ctx._fontSize)} Tf`); // Adds a segment of text to the TJ command buffer\n\n  const addSegment = cur => {\n    if (last < cur) {\n      const hex = encoded.slice(last, cur).join('');\n      const advance = positions[cur - 1].xAdvance - positions[cur - 1].advanceWidth;\n      commands.push(`<${hex}> ${number(-advance)}`);\n    }\n\n    return last = cur;\n  }; // Flushes the current TJ commands to the output stream\n\n\n  const flush = s => {\n    addSegment(s);\n\n    if (commands.length > 0) {\n      ctx.addContent(`[${commands.join(' ')}] TJ`);\n      return commands.length = 0;\n    }\n  };\n\n  for (i = 0; i < positions.length; i += 1) {\n    // If we have an x or y offset, we have to break out of the current TJ command\n    // so we can move the text position.\n    const pos = positions[i];\n\n    if (pos.xOffset || pos.yOffset) {\n      // Flush the current buffer\n      flush(i); // Move the text position and flush just the current character\n\n      ctx.addContent(`1 0 0 1 ${number(x + pos.xOffset * scale)} ${number(y + pos.yOffset * scale)} Tm`);\n      flush(i + 1);\n      hadOffset = true;\n    } else {\n      // If the last character had an offset, reset the text position\n      if (hadOffset) {\n        ctx.addContent(`1 0 0 1 ${number(x)} ${number(y)} Tm`);\n        hadOffset = false;\n      } // Group segments that don't have any advance adjustments\n\n\n      if (pos.xAdvance - pos.advanceWidth !== 0) {\n        addSegment(i + 1);\n      }\n    }\n\n    x += pos.xAdvance * scale;\n  } // Flush any remaining commands\n\n\n  flush(i); // end the text object\n\n  ctx.addContent('ET'); // restore flipped coordinate system\n\n  return ctx.restore();\n};\n\nconst renderGlyphs = (ctx, glyphs, positions, x, y) => {\n  const scale = 1000 / ctx._fontSize;\n  const unitsPerEm = ctx._font.font.unitsPerEm || 1000;\n  const advanceWidthScale = 1000 / unitsPerEm; // Glyph encoding and positioning\n\n  const encodedGlyphs = ctx._font.encodeGlyphs(glyphs);\n\n  const encodedPositions = positions.map((pos, i) => ({\n    xAdvance: pos.xAdvance * scale,\n    yAdvance: pos.yAdvance * scale,\n    xOffset: pos.xOffset,\n    yOffset: pos.yOffset,\n    advanceWidth: glyphs[i].advanceWidth * advanceWidthScale\n  }));\n  return _renderGlyphs(ctx, encodedGlyphs, encodedPositions, x, y);\n};\n\nconst renderRun$1 = (ctx, run) => {\n  if (!run.glyphs) return;\n  if (!run.positions) return;\n  const runAdvanceWidth = run.xAdvance;\n  const font = run.attributes.font?.[0];\n  const {\n    fontSize,\n    color,\n    opacity\n  } = run.attributes;\n  if (color) ctx.fillColor(color);\n  ctx.fillOpacity(opacity);\n\n  if (font) {\n    ctx.font(font.type === 'STANDARD' ? font.fullName : font, fontSize);\n  }\n\n  try {\n    renderGlyphs(ctx, run.glyphs, run.positions, 0, 0);\n  } catch (error) {\n    console.log(error);\n  }\n\n  ctx.translate(runAdvanceWidth, 0);\n};\n\nconst renderSpan = (ctx, line, textAnchor, dominantBaseline) => {\n  ctx.save();\n  const x = line.box?.x || 0;\n  const y = line.box?.y || 0;\n  const font = line.runs[0]?.attributes.font?.[0];\n  const scale = line.runs[0]?.attributes?.scale || 1;\n  const width = line.xAdvance;\n  if (!font) return;\n  const ascent = font.ascent * scale;\n  const xHeight = font.xHeight * scale;\n  const descent = font.descent * scale;\n  const capHeight = font.capHeight * scale;\n  let xTranslate = x;\n  let yTranslate = y;\n\n  switch (textAnchor) {\n    case 'middle':\n      xTranslate = x - width / 2;\n      break;\n\n    case 'end':\n      xTranslate = x - width;\n      break;\n\n    default:\n      xTranslate = x;\n      break;\n  }\n\n  switch (dominantBaseline) {\n    case 'middle':\n    case 'central':\n      yTranslate = y + capHeight / 2;\n      break;\n\n    case 'hanging':\n      yTranslate = y + capHeight;\n      break;\n\n    case 'mathematical':\n      yTranslate = y + xHeight;\n      break;\n\n    case 'text-after-edge':\n      yTranslate = y + descent;\n      break;\n\n    case 'text-before-edge':\n      yTranslate = y + ascent;\n      break;\n\n    default:\n      yTranslate = y;\n      break;\n  }\n\n  ctx.translate(xTranslate, yTranslate);\n  line.runs.forEach(run => renderRun$1(ctx, run));\n  ctx.restore();\n};\n\nconst renderSvgText = (ctx, node) => {\n  const children = node.children;\n  children.forEach(span => renderSpan(ctx, span.lines[0], span.props.textAnchor, span.props.dominantBaseline));\n};\n\nconst pairs = values => {\n  const result = [];\n\n  for (let i = 0; i < values.length; i += 2) {\n    result.push([values[i], values[i + 1]]);\n  }\n\n  return result;\n};\n/**\n * Parse svg-like points into number arrays\n *\n * @param points string ex. \"20,30 50,60\"\n * @returns points array ex. [[20, 30], [50, 60]]\n */\n\n\nconst parsePoints = points => {\n  let values = (points || '').trim().replace(/,/g, ' ').replace(/(\\d)-(\\d)/g, '$1 -$2').split(/\\s+/);\n\n  if (values.length % 2 !== 0) {\n    values = values.slice(0, -1);\n  }\n\n  const mappedValues = values.map(parseFloat);\n  return pairs(mappedValues);\n};\n\nconst drawPolyline = (ctx, points) => {\n  if (points.length > 0) {\n    ctx.moveTo(points[0][0], points[0][1]);\n    points.slice(1).forEach(p => ctx.lineTo(p[0], p[1]));\n  }\n};\n\nconst renderPolyline = (ctx, node) => {\n  const points = parsePoints(node.props.points || '');\n  drawPolyline(ctx, points);\n};\n\nconst renderPolygon = (ctx, node) => {\n  const points = parsePoints(node.props.points || '');\n  drawPolyline(ctx, points);\n  ctx.closePath();\n};\n\nconst renderImage$1 = (ctx, node) => {\n  if (!node.box) return;\n  if (!node.image?.data) return;\n  const {\n    x = 0,\n    y = 0\n  } = node.props;\n  const {\n    width,\n    height,\n    opacity\n  } = node.style;\n  const paddingTop = node.box.paddingLeft || 0;\n  const paddingLeft = node.box.paddingLeft || 0;\n\n  if (width === 0 || height === 0) {\n    console.warn(`Image with src '${node.props.href}' skipped due to invalid dimensions`);\n    return;\n  }\n\n  if (typeof width === 'string' || typeof height === 'string') {\n    console.warn(`Image with src '${node.props.href}' skipped due to percentage width or height`);\n    return;\n  }\n\n  ctx.save();\n  ctx.fillOpacity(opacity || 1).image(node.image.data, x + paddingLeft, y + paddingTop, {\n    width,\n    height\n  });\n  ctx.restore();\n}; // This constant is used to approximate a symmetrical arc using a cubic\n// Bezier curve.\n\n\nconst KAPPA$1 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\n\nconst clipNode = (ctx, node) => {\n  if (!node.box) return;\n  if (!node.style) return;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  const {\n    borderTopLeftRadius = 0,\n    borderTopRightRadius = 0,\n    borderBottomRightRadius = 0,\n    borderBottomLeftRadius = 0\n  } = node.style; // Border top\n  // @ts-expect-error this is always a number due to resolve border radius step\n\n  const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n  const ctr = rtr * (1.0 - KAPPA$1);\n  ctx.moveTo(left + rtr, top);\n  ctx.lineTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - ctr, top, left + width, top + ctr, left + width, top + rtr); // Border right\n  // @ts-expect-error this is always a number due to resolve border radius step\n\n  const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n  const cbr = rbr * (1.0 - KAPPA$1);\n  ctx.lineTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - cbr, left + width - cbr, top + height, left + width - rbr, top + height); // Border bottom\n  // @ts-expect-error this is always a number due to resolve border radius step\n\n  const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n  const cbl = rbl * (1.0 - KAPPA$1);\n  ctx.lineTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + cbl, top + height, left, top + height - cbl, left, top + height - rbl); // Border left\n  // @ts-expect-error this is always a number due to resolve border radius step\n\n  const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n  const ctl = rtl * (1.0 - KAPPA$1);\n  ctx.lineTo(left, top + rtl);\n  ctx.bezierCurveTo(left, top + ctl, left + ctl, top, left + rtl, top);\n  ctx.closePath();\n  ctx.clip();\n};\n\nconst applySingleTransformation = (ctx, transform, origin) => {\n  const {\n    operation,\n    value\n  } = transform;\n\n  switch (operation) {\n    case 'scale':\n      {\n        const [scaleX, scaleY] = value;\n        ctx.scale(scaleX, scaleY, {\n          origin\n        });\n        break;\n      }\n\n    case 'rotate':\n      {\n        const [angle] = value;\n        ctx.rotate(angle, {\n          origin\n        });\n        break;\n      }\n\n    case 'translate':\n      {\n        const [x, y = 0] = value;\n        ctx.translate(x, y, {\n          origin\n        });\n        break;\n      }\n\n    case 'skew':\n      {\n        const [xAngle = 0, yAngle = 0] = value;\n        const radx = xAngle * Math.PI / 180;\n        const rady = yAngle * Math.PI / 180;\n        const tanx = Math.tan(radx);\n        const tany = Math.tan(rady);\n        let x = 0;\n        let y = 0;\n\n        if (origin != null) {\n          [x, y] = Array.from(origin);\n          const x1 = x + tanx * y;\n          const y1 = y + tany * x;\n          x -= x1;\n          y -= y1;\n        }\n\n        ctx.transform(1, tany, tanx, 1, x, y);\n        break;\n      }\n\n    case 'matrix':\n      {\n        ctx.transform(...value);\n        break;\n      }\n\n    default:\n      {\n        console.error(`Transform operation: '${operation}' doesn't supported`);\n      }\n  }\n};\n\nconst applyTransformations = (ctx, node) => {\n  if (!node.origin) return;\n  const {\n    props,\n    style\n  } = node;\n  const origin = [node.origin.left, node.origin.top];\n  const propsTransform = 'transform' in props ? props.transform : undefined;\n  const operations = style?.transform || propsTransform || [];\n  operations.forEach(operation => {\n    applySingleTransformation(ctx, operation, origin);\n  });\n}; // From https://github.com/dy/svg-path-bounds/blob/master/index.js\n\n\nconst getPathBoundingBox = node => {\n  const path = normalizePath(absPath(parsePath(node.props?.d || '')));\n  if (!path.length) return [0, 0, 0, 0];\n  const bounds = [Infinity, Infinity, -Infinity, -Infinity];\n\n  for (let i = 0, l = path.length; i < l; i += 1) {\n    const points = path[i].slice(1);\n\n    for (let j = 0; j < points.length; j += 2) {\n      if (points[j + 0] < bounds[0]) bounds[0] = points[j + 0];\n      if (points[j + 1] < bounds[1]) bounds[1] = points[j + 1];\n      if (points[j + 0] > bounds[2]) bounds[2] = points[j + 0];\n      if (points[j + 1] > bounds[3]) bounds[3] = points[j + 1];\n    }\n  }\n\n  return bounds;\n};\n\nconst getCircleBoundingBox = node => {\n  const r = node.props?.r || 0;\n  const cx = node.props?.cx || 0;\n  const cy = node.props?.cy || 0;\n  return [cx - r, cy - r, cx + r, cy + r];\n};\n\nconst getEllipseBoundingBox = node => {\n  const cx = node.props?.cx || 0;\n  const cy = node.props?.cy || 0;\n  const rx = node.props?.rx || 0;\n  const ry = node.props?.ry || 0;\n  return [cx - rx, cy - ry, cx + rx, cy + ry];\n};\n\nconst getLineBoundingBox = node => {\n  const x1 = node.props?.x1 || 0;\n  const y1 = node.props?.y1 || 0;\n  const x2 = node.props?.x2 || 0;\n  const y2 = node.props?.y2 || 0;\n  return [Math.min(x1, x2), Math.min(y1, y2), Math.max(x1, x2), Math.max(y1, y2)];\n};\n\nconst getRectBoundingBox = node => {\n  const x = node.props?.x || 0;\n  const y = node.props?.y || 0;\n  const width = node.props?.width || 0;\n  const height = node.props?.height || 0;\n  return [x, y, x + width, y + height];\n};\n\nconst max = values => Math.max(-Infinity, ...values);\n\nconst min = values => Math.min(Infinity, ...values);\n\nconst getPolylineBoundingBox = node => {\n  const points = parsePoints(node.props?.points);\n  const xValues = points.map(p => p[0]);\n  const yValues = points.map(p => p[1]);\n  return [min(xValues), min(yValues), max(xValues), max(yValues)];\n};\n\nconst boundingBoxFns = {\n  [P.Rect]: getRectBoundingBox,\n  [P.Line]: getLineBoundingBox,\n  [P.Path]: getPathBoundingBox,\n  [P.Circle]: getCircleBoundingBox,\n  [P.Ellipse]: getEllipseBoundingBox,\n  [P.Polygon]: getPolylineBoundingBox,\n  [P.Polyline]: getPolylineBoundingBox\n};\n\nconst getBoundingBox = node => {\n  const boundingBoxFn = boundingBoxFns[node.type];\n  return boundingBoxFn ? boundingBoxFn(node) : [0, 0, 0, 0];\n};\n\nconst setStrokeWidth = (ctx, node) => {\n  if (!node.props) return;\n  if (!('strokeWidth' in node.props)) return;\n  const lineWidth = node.props.strokeWidth;\n  if (lineWidth) ctx.lineWidth(lineWidth);\n};\n\nconst setStrokeColor = (ctx, node) => {\n  if (!node.props) return;\n  if (!('stroke' in node.props)) return;\n  const strokeColor = node.props.stroke;\n  if (strokeColor) ctx.strokeColor(strokeColor);\n};\n\nconst setOpacity = (ctx, node) => {\n  if (!node.props) return;\n  if (!('opacity' in node.props)) return;\n  const opacity = node.props.opacity;\n  if (!isNil(opacity)) ctx.opacity(opacity);\n};\n\nconst setFillOpacity = (ctx, node) => {\n  if (!node.props) return;\n  if (!('fillOpacity' in node.props)) return;\n  const fillOpacity = node.props.fillOpacity || null;\n  if (!isNil(fillOpacity)) ctx.fillOpacity(fillOpacity);\n};\n\nconst setStrokeOpacity = (ctx, node) => {\n  if (!node.props) return;\n  if (!('strokeOpacity' in node.props)) return;\n  const strokeOpacity = node.props?.strokeOpacity;\n  if (!isNil(strokeOpacity)) ctx.strokeOpacity(strokeOpacity);\n};\n\nconst setLineJoin = (ctx, node) => {\n  if (!node.props) return;\n  if (!('strokeLinejoin' in node.props)) return;\n  const lineJoin = node.props.strokeLinejoin;\n  if (lineJoin) ctx.lineJoin(lineJoin);\n};\n\nconst setLineCap = (ctx, node) => {\n  if (!node.props) return;\n  if (!('strokeLinecap' in node.props)) return;\n  const lineCap = node.props?.strokeLinecap;\n  if (lineCap) ctx.lineCap(lineCap);\n};\n\nconst setLineDash = (ctx, node) => {\n  if (!node.props) return;\n  if (!('strokeDasharray' in node.props)) return;\n  const value = node.props?.strokeDasharray || null; // @ts-expect-error check this works as expected\n\n  if (value) ctx.dash(value.split(/[\\s,]+/).map(Number));\n};\n\nconst hasLinearGradientFill = node => {\n  if (!node.props) return false;\n  if (!('fill' in node.props)) return false;\n  if (typeof node.props.fill === 'string') return false;\n  return node.props.fill?.type === P.LinearGradient;\n};\n\nconst hasRadialGradientFill = node => {\n  if (!node.props) return false;\n  if (!('fill' in node.props)) return false;\n  if (typeof node.props.fill === 'string') return false;\n  return node.props.fill?.type === P.RadialGradient;\n};\n\nfunction multiplyMatrices(m1, m2) {\n  const a = m1[0] * m2[0] + m1[2] * m2[1];\n  const b = m1[1] * m2[0] + m1[3] * m2[1];\n  const c = m1[0] * m2[2] + m1[2] * m2[3];\n  const d = m1[1] * m2[2] + m1[3] * m2[3];\n  const e = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n  const f = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n  return [a, b, c, d, e, f];\n}\n\nconst transformGradient = (grad, transforms, bbox, units) => {\n  const matrices = transforms.map(transform => {\n    switch (transform.operation) {\n      case 'scale':\n        {\n          const value = transform.value;\n          return [value[0], 0, 0, value[1], 0, 0];\n        }\n\n      case 'translate':\n        {\n          const value = transform.value;\n          let x = value[0] || 0;\n          let y = value[1] || 0;\n\n          if (units === 'objectBoundingBox') {\n            x = (bbox[2] - bbox[0]) * x;\n            y = (bbox[3] - bbox[1]) * y;\n          }\n\n          return [1, 0, 0, 1, x, y];\n        }\n\n      case 'rotate':\n        {\n          const value = transform.value;\n          const cos = Math.cos(value[0]);\n          const sin = Math.sin(value[0]);\n          return [cos, sin, -sin, cos, 0, 0];\n        }\n\n      case 'skew':\n        {\n          const value = transform.value;\n          return [1, Math.tan(value[0]), Math.tan(value[1]), 1, 0, 0];\n        }\n\n      case 'matrix':\n        {\n          const value = transform.value;\n          let x = value[4] || 0;\n          let y = value[5] || 0;\n\n          if (units === 'objectBoundingBox') {\n            x = (bbox[2] - bbox[0]) * x;\n            y = (bbox[3] - bbox[1]) * y;\n          }\n\n          return [value[0], value[1], value[2], value[3], x, y];\n        }\n\n      default:\n        return [1, 0, 0, 1, 0, 0];\n    }\n  });\n  const matrix = matrices.reduce(multiplyMatrices, [1, 0, 0, 1, 0, 0]);\n  grad.setTransform(...matrix);\n}; // Math simplified from https://github.com/devongovett/svgkit/blob/master/src/elements/SVGGradient.js#L104\n\n\nconst setLinearGradientFill = (ctx, node) => {\n  if (!node.props) return;\n  if (!('fill' in node.props)) return;\n  const bbox = getBoundingBox(node);\n  const gradient = node.props?.fill;\n  if (!gradient) return;\n  const units = gradient.props.gradientUnits || 'objectBoundingBox';\n  const transforms = gradient.props.gradientTransform || [];\n  let x1 = gradient.props.x1 || 0;\n  let y1 = gradient.props.y1 || 0;\n  let x2 = gradient.props.x2 || 1;\n  let y2 = gradient.props.y2 || 0;\n\n  if (units === 'objectBoundingBox') {\n    const m0 = bbox[2] - bbox[0];\n    const m3 = bbox[3] - bbox[1];\n    const m4 = bbox[0];\n    const m5 = bbox[1];\n    x1 = m0 * x1 + m4;\n    y1 = m3 * y1 + m5;\n    x2 = m0 * x2 + m4;\n    y2 = m3 * y2 + m5;\n  }\n\n  const grad = ctx.linearGradient(x1, y1, x2, y2);\n  transformGradient(grad, transforms, bbox, units);\n  gradient.children?.forEach(stop => {\n    grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);\n  });\n  ctx.fill(grad);\n}; // Math simplified from https://github.com/devongovett/svgkit/blob/master/src/elements/SVGGradient.js#L155\n\n\nconst setRadialGradientFill = (ctx, node) => {\n  if (!node.props) return;\n  if (!('fill' in node.props)) return;\n  const bbox = getBoundingBox(node);\n  const gradient = node.props?.fill;\n  if (!gradient) return;\n  const units = gradient.props.gradientUnits || 'objectBoundingBox';\n  const transforms = gradient.props.gradientTransform || [];\n  let r = gradient.props.r || 0.5;\n  let cx = gradient.props.cx || 0.5;\n  let cy = gradient.props.cy || 0.5;\n  let fx = gradient.props.fx || cx;\n  let fy = gradient.props.fy || cy;\n\n  if (units === 'objectBoundingBox') {\n    const m0 = bbox[2] - bbox[0];\n    const m3 = bbox[3] - bbox[1];\n    const m4 = bbox[0];\n    const m5 = bbox[1];\n    r = r * m0;\n    cx = m0 * cx + m4;\n    cy = m3 * cy + m5;\n    fx = m0 * fx + m4;\n    fy = m3 * fy + m5;\n  }\n\n  const grad = ctx.radialGradient(cx, cy, 0, fx, fy, r);\n  transformGradient(grad, transforms, bbox, units);\n  gradient.children?.forEach(stop => {\n    grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);\n  });\n  ctx.fill(grad);\n};\n\nconst setFillColor = (ctx, node) => {\n  if (!node.props) return;\n  if (!('fill' in node.props)) return;\n  const fillColor = node.props?.fill;\n  if (fillColor) ctx.fillColor(fillColor);\n};\n\nconst setFill = (ctx, node) => {\n  if (hasLinearGradientFill(node)) return setLinearGradientFill(ctx, node);\n  if (hasRadialGradientFill(node)) return setRadialGradientFill(ctx, node);\n  return setFillColor(ctx, node);\n};\n\nconst draw = (ctx, node) => {\n  const props = node.props || {};\n\n  if ('fill' in props && 'stroke' in props && props.fill && props.stroke) {\n    ctx.fillAndStroke(props.fillRule);\n  } else if ('fill' in props && props.fill) {\n    ctx.fill(props.fillRule);\n  } else if ('stroke' in props && props.stroke) {\n    ctx.stroke();\n  } else {\n    ctx.save();\n    ctx.opacity(0);\n    ctx.fill(null);\n    ctx.restore();\n  }\n};\n\nconst noop = () => {};\n\nconst renderFns$1 = {\n  [P.Tspan]: noop,\n  [P.TextInstance]: noop,\n  [P.Path]: renderPath,\n  [P.Rect]: renderRect,\n  [P.Line]: renderLine$1,\n  [P.G]: renderGroup,\n  [P.Text]: renderSvgText,\n  [P.Circle]: renderCircle,\n  [P.Image]: renderImage$1,\n  [P.Ellipse]: renderEllipse,\n  [P.Polygon]: renderPolygon,\n  [P.Polyline]: renderPolyline\n};\n\nconst renderNode$1 = (ctx, node) => {\n  const renderFn = renderFns$1[node.type];\n\n  if (renderFn) {\n    renderFn(ctx, node);\n  } else {\n    console.warn(`SVG node of type ${node.type} is not currently supported`);\n  }\n};\n\nconst drawNode = (ctx, node) => {\n  setLineCap(ctx, node);\n  setLineDash(ctx, node);\n  setLineJoin(ctx, node);\n  setStrokeWidth(ctx, node);\n  setStrokeColor(ctx, node);\n  setFill(ctx, node);\n  setStrokeOpacity(ctx, node);\n  setFillOpacity(ctx, node);\n  setOpacity(ctx, node);\n  applyTransformations(ctx, node);\n  renderNode$1(ctx, node);\n  draw(ctx, node);\n};\n\nconst clipPath = (ctx, node) => {\n  if (!node.props) return;\n  if (!('clipPath' in node.props)) return;\n  const value = node.props.clipPath;\n\n  if (value) {\n    const children = value.children || [];\n    children.forEach(child => renderNode$1(ctx, child));\n    ctx.clip();\n  }\n};\n\nconst drawChildren = (ctx, node) => {\n  const children = node.children || [];\n  children.forEach(child => {\n    ctx.save();\n    clipPath(ctx, child);\n    drawNode(ctx, child);\n    drawChildren(ctx, child);\n    ctx.restore();\n  });\n};\n\nconst resolveAspectRatio = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    width,\n    height\n  } = node.box;\n  const {\n    viewBox,\n    preserveAspectRatio\n  } = node.props;\n  const {\n    meetOrSlice = 'meet',\n    align = 'xMidYMid'\n  } = preserveAspectRatio || {};\n  if (viewBox == null || width == null || height == null) return;\n  const x = viewBox?.minX || 0;\n  const y = viewBox?.minY || 0;\n  const logicalWidth = viewBox?.maxX || width;\n  const logicalHeight = viewBox?.maxY || height;\n  const logicalRatio = logicalWidth / logicalHeight;\n  const physicalRatio = width / height;\n  const scaleX = width / logicalWidth;\n  const scaleY = height / logicalHeight;\n\n  if (align === 'none') {\n    ctx.scale(scaleX, scaleY);\n    ctx.translate(-x, -y);\n    return;\n  }\n\n  if (logicalRatio < physicalRatio && meetOrSlice === 'meet' || logicalRatio >= physicalRatio && meetOrSlice === 'slice') {\n    ctx.scale(scaleY, scaleY);\n\n    switch (align) {\n      case 'xMinYMin':\n      case 'xMinYMid':\n      case 'xMinYMax':\n        ctx.translate(-x, -y);\n        break;\n\n      case 'xMidYMin':\n      case 'xMidYMid':\n      case 'xMidYMax':\n        ctx.translate(-x - (logicalWidth - width * logicalHeight / height) / 2, -y);\n        break;\n\n      default:\n        ctx.translate(-x - (logicalWidth - width * logicalHeight / height), -y);\n    }\n  } else {\n    ctx.scale(scaleX, scaleX);\n\n    switch (align) {\n      case 'xMinYMin':\n      case 'xMidYMin':\n      case 'xMaxYMin':\n        ctx.translate(-x, -y);\n        break;\n\n      case 'xMinYMid':\n      case 'xMidYMid':\n      case 'xMaxYMid':\n        ctx.translate(-x, -y - (logicalHeight - height * logicalWidth / width) / 2);\n        break;\n\n      default:\n        ctx.translate(-x, -y - (logicalHeight - height * logicalWidth / width));\n    }\n  }\n};\n\nconst moveToOrigin = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    top,\n    left\n  } = node.box;\n  const paddingLeft = node.box.paddingLeft || 0;\n  const paddingTop = node.box.paddingTop || 0;\n  ctx.translate(left + paddingLeft, top + paddingTop);\n};\n\nconst renderSvg = (ctx, node) => {\n  ctx.save();\n  clipNode(ctx, node);\n  moveToOrigin(ctx, node);\n  resolveAspectRatio(ctx, node);\n  drawChildren(ctx, node);\n  ctx.restore();\n};\n\nconst black = {\n  value: '#000',\n  opacity: 1\n}; // TODO: parse to number[] in layout to avoid this step\n\nconst parseColor = hex => {\n  if (!hex) return black;\n  const parsed = colorString.get(hex);\n  if (!parsed) return black;\n  const value = colorString.to.hex(parsed.value.slice(0, 3));\n  const opacity = parsed.value[3];\n  return {\n    value,\n    opacity\n  };\n};\n\nconst DEST_REGEXP = /^#.+/;\n\nconst isSrcId$1 = src => src.match(DEST_REGEXP);\n\nconst renderAttachment = (ctx, attachment) => {\n  const {\n    xOffset = 0,\n    yOffset = 0,\n    width,\n    height,\n    image\n  } = attachment;\n  ctx.translate(-width + xOffset, -height + yOffset);\n  ctx.image(image, 0, 0, {\n    fit: [width, height],\n    align: 'center',\n    valign: 'bottom'\n  });\n};\n\nconst renderAttachments = (ctx, run) => {\n  if (!run.glyphs) return;\n  if (!run.positions) return;\n  const font = run.attributes.font?.[0];\n  if (!font) return;\n  ctx.save();\n  const space = font.glyphForCodePoint(0x20);\n  const objectReplacement = font.glyphForCodePoint(0xfffc);\n  let attachmentAdvance = 0;\n\n  for (let i = 0; i < run.glyphs.length; i += 1) {\n    const position = run.positions[i];\n    const glyph = run.glyphs[i];\n    attachmentAdvance += position.xAdvance || 0;\n\n    if (glyph.id === objectReplacement.id && run.attributes.attachment) {\n      ctx.translate(attachmentAdvance, position.yOffset || 0);\n      renderAttachment(ctx, run.attributes.attachment);\n      run.glyphs[i] = space;\n      attachmentAdvance = 0;\n    }\n  }\n\n  ctx.restore();\n};\n\nconst renderRun = (ctx, run) => {\n  if (!run.glyphs) return;\n  if (!run.positions) return;\n  const font = run.attributes.font?.[0];\n  if (!font) return;\n  const {\n    fontSize,\n    link\n  } = run.attributes;\n  const color = parseColor(run.attributes.color);\n  const opacity = isNil(run.attributes.opacity) ? color.opacity : run.attributes.opacity;\n  const {\n    height = 0,\n    descent = 0,\n    xAdvance = 0\n  } = run;\n  ctx.fillColor(color.value);\n  ctx.fillOpacity(opacity);\n\n  if (link) {\n    if (isSrcId$1(link)) {\n      ctx.goTo(0, -height - descent, xAdvance, height, link.slice(1));\n    } else {\n      ctx.link(0, -height - descent, xAdvance, height, link);\n    }\n  }\n\n  renderAttachments(ctx, run);\n  ctx.font(font.type === 'STANDARD' ? font.fullName : font, fontSize);\n\n  try {\n    renderGlyphs(ctx, run.glyphs, run.positions, 0, 0);\n  } catch (error) {\n    console.log(error);\n  }\n\n  ctx.translate(xAdvance, 0);\n};\n\nconst renderBackground$1 = (ctx, rect, backgroundColor) => {\n  const color = parseColor(backgroundColor);\n  ctx.save();\n  ctx.fillOpacity(color.opacity);\n  ctx.rect(rect.x, rect.y, rect.width, rect.height);\n  ctx.fill(color.value);\n  ctx.restore();\n};\n\nconst renderDecorationLine = (ctx, decorationLine) => {\n  ctx.save();\n  ctx.lineWidth(decorationLine.rect.height);\n  ctx.strokeOpacity(decorationLine.opacity);\n\n  if (/dashed/.test(decorationLine.style)) {\n    ctx.dash(3 * decorationLine.rect.height, {});\n  } else if (/dotted/.test(decorationLine.style)) {\n    ctx.dash(decorationLine.rect.height, {});\n  }\n\n  if (/wavy/.test(decorationLine.style)) {\n    const dist = Math.max(2, decorationLine.rect.height);\n    let step = 1.1 * dist;\n    const stepCount = Math.floor(decorationLine.rect.width / (2 * step)); // Adjust step to fill entire width\n\n    const remainingWidth = decorationLine.rect.width - stepCount * 2 * step;\n    const adjustment = remainingWidth / stepCount / 2;\n    step += adjustment;\n    const cp1y = decorationLine.rect.y + dist;\n    const cp2y = decorationLine.rect.y - dist;\n    let {\n      x\n    } = decorationLine.rect;\n    ctx.moveTo(decorationLine.rect.x, decorationLine.rect.y);\n\n    for (let i = 0; i < stepCount; i += 1) {\n      ctx.bezierCurveTo(x + step, cp1y, x + step, cp2y, x + 2 * step, decorationLine.rect.y);\n      x += 2 * step;\n    }\n  } else {\n    ctx.moveTo(decorationLine.rect.x, decorationLine.rect.y);\n    ctx.lineTo(decorationLine.rect.x + decorationLine.rect.width, decorationLine.rect.y);\n\n    if (/double/.test(decorationLine.style)) {\n      ctx.moveTo(decorationLine.rect.x, decorationLine.rect.y + decorationLine.rect.height * 2);\n      ctx.lineTo(decorationLine.rect.x + decorationLine.rect.width, decorationLine.rect.y + decorationLine.rect.height * 2);\n    }\n  }\n\n  ctx.stroke(decorationLine.color);\n  ctx.restore();\n};\n\nconst renderLine = (ctx, line) => {\n  if (!line.box) return;\n  const lineAscent = line.ascent || 0;\n  ctx.save();\n  ctx.translate(line.box.x, line.box.y + lineAscent);\n\n  for (let i = 0; i < line.runs.length; i += 1) {\n    const run = line.runs[i];\n    const isLastRun = i === line.runs.length - 1;\n\n    if (run.attributes.backgroundColor) {\n      const xAdvance = run.xAdvance ?? 0;\n      const overflowRight = isLastRun ? line.overflowRight ?? 0 : 0;\n      const backgroundRect = {\n        x: 0,\n        y: -lineAscent,\n        height: line.box.height,\n        width: xAdvance - overflowRight\n      };\n      renderBackground$1(ctx, backgroundRect, run.attributes.backgroundColor);\n    }\n\n    renderRun(ctx, run);\n  }\n\n  ctx.restore();\n  ctx.save();\n  ctx.translate(line.box.x, line.box.y);\n\n  if (line.decorationLines) {\n    for (let i = 0; i < line.decorationLines.length; i += 1) {\n      const decorationLine = line.decorationLines[i];\n      renderDecorationLine(ctx, decorationLine);\n    }\n  }\n\n  ctx.restore();\n};\n\nconst renderBlock = (ctx, block) => {\n  block.forEach(line => {\n    renderLine(ctx, line);\n  });\n};\n\nconst renderText = (ctx, node) => {\n  if (!node.box) return;\n  if (!node.lines) return;\n  const {\n    top,\n    left\n  } = node.box;\n  const blocks = [node.lines];\n  const paddingTop = node.box?.paddingTop || 0;\n  const paddingLeft = node.box?.paddingLeft || 0;\n  const initialY = node.lines[0] ? node.lines[0].box.y : 0;\n  const offsetX = node.alignOffset || 0;\n  ctx.save();\n  ctx.translate(left + paddingLeft - offsetX, top + paddingTop - initialY);\n  blocks.forEach(block => {\n    renderBlock(ctx, block);\n  });\n  ctx.restore();\n};\n\nconst renderPage = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    width,\n    height\n  } = node.box;\n  const dpi = node.props?.dpi || 72;\n  const userUnit = dpi / 72;\n  ctx.addPage({\n    size: [width, height],\n    margin: 0,\n    userUnit\n  });\n};\n\nconst renderNote = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    top,\n    left\n  } = node.box;\n  const value = node?.children?.[0].value || '';\n  const color = node.style?.backgroundColor;\n  ctx.note(left, top, 0, 0, value, {\n    color\n  });\n};\n\nconst embedImage = (ctx, node) => {\n  const src = node.image.data;\n  let image;\n\n  if (typeof src === 'string') {\n    image = ctx._imageRegistry[src];\n  }\n\n  if (!image) {\n    image = ctx.openImage(src);\n  }\n\n  if (!image.obj) {\n    image.embed(ctx);\n  }\n\n  return image;\n};\n\nconst isNumeric = n => {\n  return !Number.isNaN(parseFloat(n)) && Number.isFinite(n);\n};\n\nconst applyContainObjectFit = (cw, ch, iw, ih, px, py) => {\n  const cr = cw / ch;\n  const ir = iw / ih;\n  const pxp = matchPercent(px ?? null);\n  const pyp = matchPercent(py ?? null);\n  const pxv = pxp ? pxp.percent : 0.5;\n  const pyv = pyp ? pyp.percent : 0.5;\n\n  if (cr > ir) {\n    const height = ch;\n    const width = height * ir;\n    const yOffset = isNumeric(py) ? py : 0;\n    const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n    return {\n      width,\n      height,\n      xOffset,\n      yOffset\n    };\n  }\n\n  const width = cw;\n  const height = width / ir;\n  const xOffset = isNumeric(px) ? px : 0;\n  const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n  return {\n    width,\n    height,\n    yOffset,\n    xOffset\n  };\n};\n\nconst applyNoneObjectFit = (cw, ch, iw, ih, px, py) => {\n  const width = iw;\n  const height = ih;\n  const pxp = matchPercent(px ?? null);\n  const pyp = matchPercent(py ?? null);\n  const pxv = pxp ? pxp.percent : 0.5;\n  const pyv = pyp ? pyp.percent : 0.5;\n  const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n  const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n  return {\n    width,\n    height,\n    xOffset,\n    yOffset\n  };\n};\n\nconst applyCoverObjectFit = (cw, ch, iw, ih, px, py) => {\n  const ir = iw / ih;\n  const cr = cw / ch;\n  const pxp = matchPercent(px ?? null);\n  const pyp = matchPercent(py ?? null);\n  const pxv = pxp ? pxp.percent : 0.5;\n  const pyv = pyp ? pyp.percent : 0.5;\n\n  if (cr > ir) {\n    const width = cw;\n    const height = width / ir;\n    const xOffset = isNumeric(px) ? px : 0;\n    const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n    return {\n      width,\n      height,\n      yOffset,\n      xOffset\n    };\n  }\n\n  const height = ch;\n  const width = height * ir;\n  const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n  const yOffset = isNumeric(py) ? py : 0;\n  return {\n    width,\n    height,\n    xOffset,\n    yOffset\n  };\n};\n\nconst applyScaleDownObjectFit = (cw, ch, iw, ih, px, py) => {\n  const containDimension = applyContainObjectFit(cw, ch, iw, ih, px, py);\n  const noneDimension = applyNoneObjectFit(cw, ch, iw, ih, px, py);\n  return containDimension.width < noneDimension.width ? containDimension : noneDimension;\n};\n\nconst applyFillObjectFit = (cw, ch, px, py) => {\n  return {\n    width: cw,\n    height: ch,\n    xOffset: matchPercent(px ?? null) ? 0 : px || 0,\n    yOffset: matchPercent(py ?? null) ? 0 : py || 0\n  };\n};\n\nconst resolveObjectFit = function () {\n  let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'fill';\n  let cw = arguments.length > 1 ? arguments[1] : undefined;\n  let ch = arguments.length > 2 ? arguments[2] : undefined;\n  let iw = arguments.length > 3 ? arguments[3] : undefined;\n  let ih = arguments.length > 4 ? arguments[4] : undefined;\n  let px = arguments.length > 5 ? arguments[5] : undefined;\n  let py = arguments.length > 6 ? arguments[6] : undefined;\n\n  switch (type) {\n    case 'contain':\n      return applyContainObjectFit(cw, ch, iw, ih, px, py);\n\n    case 'cover':\n      return applyCoverObjectFit(cw, ch, iw, ih, px, py);\n\n    case 'none':\n      return applyNoneObjectFit(cw, ch, iw, ih, px, py);\n\n    case 'scale-down':\n      return applyScaleDownObjectFit(cw, ch, iw, ih, px, py);\n\n    default:\n      return applyFillObjectFit(cw, ch, px, py);\n  }\n};\n\nconst drawImage = (ctx, node, options) => {\n  if (!node.box) return;\n  if (!node.image) return;\n  const {\n    left,\n    top\n  } = node.box;\n  const opacity = node.style?.opacity;\n  const objectFit = node.style?.objectFit;\n  const objectPositionX = node.style?.objectPositionX;\n  const objectPositionY = node.style?.objectPositionY;\n  const paddingTop = node.box.paddingTop || 0;\n  const paddingRight = node.box.paddingRight || 0;\n  const paddingBottom = node.box.paddingBottom || 0;\n  const paddingLeft = node.box.paddingLeft || 0;\n  const imageCache = options.imageCache || new Map();\n  const {\n    width,\n    height,\n    xOffset,\n    yOffset\n  } = resolveObjectFit(objectFit, node.box.width - paddingLeft - paddingRight, node.box.height - paddingTop - paddingBottom, node.image.width, node.image.height, objectPositionX, objectPositionY);\n\n  if (node.image.data) {\n    if (width !== 0 && height !== 0) {\n      const cacheKey = node.image.key;\n      const image = imageCache.get(cacheKey) || embedImage(ctx, node);\n      if (cacheKey) imageCache.set(cacheKey, image);\n      const imageOpacity = isNil(opacity) ? 1 : opacity;\n      ctx.fillOpacity(imageOpacity).image(image, left + paddingLeft + xOffset, top + paddingTop + yOffset, {\n        width,\n        height\n      });\n    } else {\n      console.warn(`Image with src '${JSON.stringify(node.props.src || node.props.source)}' skipped due to invalid dimensions`);\n    }\n  }\n};\n\nconst renderImage = (ctx, node, options) => {\n  ctx.save();\n  clipNode(ctx, node);\n  drawImage(ctx, node, options);\n  ctx.restore();\n};\n\nconst CONTENT_COLOR = '#a1c6e7';\nconst PADDING_COLOR = '#c4deb9';\nconst MARGIN_COLOR = '#f8cca1'; // TODO: Draw debug boxes using clipping to enhance quality\n\nconst debugContent = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    left,\n    top,\n    width,\n    height,\n    paddingLeft = 0,\n    paddingTop = 0,\n    paddingRight = 0,\n    paddingBottom = 0,\n    borderLeftWidth = 0,\n    borderTopWidth = 0,\n    borderRightWidth = 0,\n    borderBottomWidth = 0\n  } = node.box;\n  ctx.fillColor(CONTENT_COLOR).opacity(0.5).rect(left + paddingLeft + borderLeftWidth, top + paddingTop + borderTopWidth, width - paddingLeft - paddingRight - borderRightWidth - borderLeftWidth, height - paddingTop - paddingBottom - borderTopWidth - borderBottomWidth).fill();\n};\n\nconst debugPadding = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    left,\n    top,\n    width,\n    height,\n    paddingLeft = 0,\n    paddingTop = 0,\n    paddingRight = 0,\n    paddingBottom = 0,\n    borderLeftWidth = 0,\n    borderTopWidth = 0,\n    borderRightWidth = 0,\n    borderBottomWidth = 0\n  } = node.box;\n  ctx.fillColor(PADDING_COLOR).opacity(0.5); // Padding top\n\n  ctx.rect(left + paddingLeft + borderLeftWidth, top + borderTopWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingTop).fill(); // Padding left\n\n  ctx.rect(left + borderLeftWidth, top + borderTopWidth, paddingLeft, height - borderTopWidth - borderBottomWidth).fill(); // Padding right\n\n  ctx.rect(left + width - paddingRight - borderRightWidth, top + borderTopWidth, paddingRight, height - borderTopWidth - borderBottomWidth).fill(); // Padding bottom\n\n  ctx.rect(left + paddingLeft + borderLeftWidth, top + height - paddingBottom - borderBottomWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingBottom).fill();\n};\n\nconst debugMargin = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    left,\n    top,\n    width,\n    height\n  } = node.box;\n  const {\n    marginLeft = 0,\n    marginTop = 0,\n    marginRight = 0,\n    marginBottom = 0\n  } = node.box;\n  ctx.fillColor(MARGIN_COLOR).opacity(0.5); // Margin top\n\n  ctx.rect(left, top - marginTop, width, marginTop).fill(); // Margin left\n\n  ctx.rect(left - marginLeft, top - marginTop, marginLeft, height + marginTop + marginBottom).fill(); // Margin right\n\n  ctx.rect(left + width, top - marginTop, marginRight, height + marginTop + marginBottom).fill(); // Margin bottom\n\n  ctx.rect(left, top + height, width, marginBottom).fill();\n};\n\nconst debugText = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    left,\n    top,\n    width,\n    height\n  } = node.box;\n  const {\n    marginLeft = 0,\n    marginTop = 0,\n    marginRight = 0,\n    marginBottom = 0\n  } = node.box;\n  const roundedWidth = Math.round(width + marginLeft + marginRight);\n  const roundedHeight = Math.round(height + marginTop + marginBottom);\n  ctx.fontSize(6).opacity(1).fillColor('black').text(`${roundedWidth} x ${roundedHeight}`, left - marginLeft, Math.max(top - marginTop - 4, 1), {\n    width: Infinity\n  });\n};\n\nconst debugOrigin = (ctx, node) => {\n  if (node.origin) {\n    ctx.circle(node.origin.left, node.origin.top, 3).fill('red').circle(node.origin.left, node.origin.top, 5).stroke('red');\n  }\n};\n\nconst renderDebug = (ctx, node) => {\n  if (!node.props) return;\n  if (!('debug' in node.props) || !node.props.debug) return;\n  ctx.save();\n  debugContent(ctx, node);\n  debugPadding(ctx, node);\n  debugMargin(ctx, node);\n  debugText(ctx, node);\n  debugOrigin(ctx, node);\n  ctx.restore();\n};\n\nconst availableMethods = ['dash', 'clip', 'save', 'path', 'fill', 'font', 'text', 'rect', 'scale', 'moveTo', 'lineTo', 'stroke', 'rotate', 'circle', 'lineCap', 'opacity', 'ellipse', 'polygon', 'restore', 'lineJoin', 'fontSize', 'fillColor', 'lineWidth', 'translate', 'miterLimit', 'strokeColor', 'fillOpacity', 'roundedRect', 'fillAndStroke', 'strokeOpacity', 'bezierCurveTo', 'quadraticCurveTo', 'linearGradient', 'radialGradient'];\n\nconst painter = ctx => {\n  const p = availableMethods.reduce((acc, prop) => ({ ...acc,\n    [prop]: function () {\n      // @ts-expect-error ctx[prop] is a function\n      ctx[prop](...arguments);\n      return p;\n    }\n  }), {});\n  return p;\n};\n\nconst renderCanvas = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  const paddingTop = node.box.paddingTop || 0;\n  const paddingLeft = node.box.paddingLeft || 0;\n  const paddingRight = node.box.paddingRight || 0;\n  const paddingBottom = node.box.paddingBottom || 0;\n  const availableWidth = width - paddingLeft - paddingRight;\n  const availableHeight = height - paddingTop - paddingBottom;\n\n  if (!availableWidth || !availableHeight) {\n    console.warn('Canvas element has null width or height. Please provide valid values via the `style` prop in order to correctly render it.');\n  }\n\n  ctx.save().translate(left + paddingLeft, top + paddingTop);\n\n  if (node.props.paint) {\n    node.props.paint(painter(ctx), availableWidth, availableHeight);\n  }\n\n  ctx.restore();\n}; // Ref: https://www.w3.org/TR/css-backgrounds-3/#borders\n// This constant is used to approximate a symmetrical arc using a cubic Bezier curve.\n\n\nconst KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\n\nconst clipBorderTop = (ctx, layout, style, rtr, rtl) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderTopWidth,\n    borderRightWidth,\n    borderLeftWidth\n  } = style; // Clip outer top border edge\n\n  ctx.moveTo(left + rtl, top);\n  ctx.lineTo(left + width - rtr, top); // Ellipse coefficients outer top right cap\n\n  const c0 = rtr * (1.0 - KAPPA); // Clip outer top right cap\n\n  ctx.bezierCurveTo(left + width - c0, top, left + width, top + c0, left + width, top + rtr); // Move down in case the margin exceedes the radius\n\n  const topRightYCoord = top + Math.max(borderTopWidth, rtr);\n  ctx.lineTo(left + width, topRightYCoord); // Clip inner top right cap\n\n  ctx.lineTo(left + width - borderRightWidth, topRightYCoord); // Ellipse coefficients inner top right cap\n\n  const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n  const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n  const c1 = innerTopRightRadiusX * (1.0 - KAPPA);\n  const c2 = innerTopRightRadiusY * (1.0 - KAPPA); // Clip inner top right cap\n\n  ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c2, left + width - borderRightWidth - c1, top + borderTopWidth, left + width - borderRightWidth - innerTopRightRadiusX, top + borderTopWidth); // Clip inner top border edge\n\n  ctx.lineTo(left + Math.max(rtl, borderLeftWidth), top + borderTopWidth); // Ellipse coefficients inner top left cap\n\n  const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n  const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n  const c3 = innerTopLeftRadiusX * (1.0 - KAPPA);\n  const c4 = innerTopLeftRadiusY * (1.0 - KAPPA);\n  const topLeftYCoord = top + Math.max(borderTopWidth, rtl); // Clip inner top left cap\n\n  ctx.bezierCurveTo(left + borderLeftWidth + c3, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c4, left + borderLeftWidth, topLeftYCoord);\n  ctx.lineTo(left, topLeftYCoord); // Move down in case the margin exceedes the radius\n\n  ctx.lineTo(left, top + rtl); // Ellipse coefficients outer top left cap\n\n  const c5 = rtl * (1.0 - KAPPA); // Clip outer top left cap\n\n  ctx.bezierCurveTo(left, top + c5, left + c5, top, left + rtl, top);\n  ctx.closePath();\n  ctx.clip(); // Clip border top cap joins\n\n  if (borderRightWidth) {\n    const trSlope = -borderTopWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n\n  if (borderLeftWidth) {\n    const trSlope = -borderTopWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left + width, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\n\nconst fillBorderTop = (ctx, layout, style, rtr, rtl) => {\n  const {\n    top,\n    left,\n    width\n  } = layout;\n  const {\n    borderTopColor,\n    borderTopWidth,\n    borderTopStyle,\n    borderRightWidth,\n    borderLeftWidth\n  } = style;\n  const c0 = rtl * (1.0 - KAPPA);\n  const c1 = rtr * (1.0 - KAPPA);\n  ctx.moveTo(left, top + Math.max(rtl, borderTopWidth));\n  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);\n  ctx.lineTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);\n  ctx.strokeColor(borderTopColor);\n  ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderLeftWidth) * 2);\n\n  if (borderTopStyle === 'dashed') {\n    ctx.dash(borderTopWidth * 2, {\n      space: borderTopWidth * 1.2\n    });\n  } else if (borderTopStyle === 'dotted') {\n    ctx.dash(borderTopWidth, {\n      space: borderTopWidth * 1.2\n    });\n  }\n\n  ctx.stroke();\n  ctx.undash();\n};\n\nconst clipBorderRight = (ctx, layout, style, rtr, rbr) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderTopWidth,\n    borderRightWidth,\n    borderBottomWidth\n  } = style; // Clip outer right border edge\n\n  ctx.moveTo(left + width, top + rtr);\n  ctx.lineTo(left + width, top + height - rbr); // Ellipse coefficients outer bottom right cap\n\n  const c0 = rbr * (1.0 - KAPPA); // Clip outer top right cap\n\n  ctx.bezierCurveTo(left + width, top + height - c0, left + width - c0, top + height, left + width - rbr, top + height); // Move left in case the margin exceedes the radius\n\n  const topBottomXCoord = left + width - Math.max(borderRightWidth, rbr);\n  ctx.lineTo(topBottomXCoord, top + height); // Clip inner bottom right cap\n\n  ctx.lineTo(topBottomXCoord, top + height - borderBottomWidth); // Ellipse coefficients inner bottom right cap\n\n  const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n  const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n  const c1 = innerBottomRightRadiusX * (1.0 - KAPPA);\n  const c2 = innerBottomRightRadiusY * (1.0 - KAPPA); // Clip inner top right cap\n\n  ctx.bezierCurveTo(left + width - borderRightWidth - c1, top + height - borderBottomWidth, left + width - borderRightWidth, top + height - borderBottomWidth - c2, left + width - borderRightWidth, top + height - Math.max(rbr, borderBottomWidth)); // Clip inner right border edge\n\n  ctx.lineTo(left + width - borderRightWidth, top + Math.max(rtr, borderTopWidth)); // Ellipse coefficients inner top right cap\n\n  const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n  const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n  const c3 = innerTopRightRadiusX * (1.0 - KAPPA);\n  const c4 = innerTopRightRadiusY * (1.0 - KAPPA);\n  const topRightXCoord = left + width - Math.max(rtr, borderRightWidth); // Clip inner top left cap\n\n  ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c4, left + width - borderRightWidth - c3, top + borderTopWidth, topRightXCoord, top + borderTopWidth);\n  ctx.lineTo(topRightXCoord, top); // Move right in case the margin exceedes the radius\n\n  ctx.lineTo(left + width - rtr, top); // Ellipse coefficients outer top right cap\n\n  const c5 = rtr * (1.0 - KAPPA); // Clip outer top right cap\n\n  ctx.bezierCurveTo(left + width - c5, top, left + width, top + c5, left + width, top + rtr);\n  ctx.closePath();\n  ctx.clip(); // Clip border right cap joins\n\n  if (borderTopWidth) {\n    const trSlope = -borderTopWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n\n  if (borderBottomWidth) {\n    const brSlope = borderBottomWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\n\nconst fillBorderRight = (ctx, layout, style, rtr, rbr) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderRightColor,\n    borderRightStyle,\n    borderRightWidth,\n    borderTopWidth,\n    borderBottomWidth\n  } = style;\n  const c0 = rbr * (1.0 - KAPPA);\n  const c1 = rtr * (1.0 - KAPPA);\n  ctx.moveTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);\n  ctx.lineTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - c0, left + width - c0, top + height, left + width - rbr, top + height);\n  ctx.strokeColor(borderRightColor);\n  ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderBottomWidth) * 2);\n\n  if (borderRightStyle === 'dashed') {\n    ctx.dash(borderRightWidth * 2, {\n      space: borderRightWidth * 1.2\n    });\n  } else if (borderRightStyle === 'dotted') {\n    ctx.dash(borderRightWidth, {\n      space: borderRightWidth * 1.2\n    });\n  }\n\n  ctx.stroke();\n  ctx.undash();\n};\n\nconst clipBorderBottom = (ctx, layout, style, rbl, rbr) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderBottomWidth,\n    borderRightWidth,\n    borderLeftWidth\n  } = style; // Clip outer top border edge\n\n  ctx.moveTo(left + width - rbr, top + height);\n  ctx.lineTo(left + rbl, top + height); // Ellipse coefficients outer top right cap\n\n  const c0 = rbl * (1.0 - KAPPA); // Clip outer top right cap\n\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl); // Move up in case the margin exceedes the radius\n\n  const bottomLeftYCoord = top + height - Math.max(borderBottomWidth, rbl);\n  ctx.lineTo(left, bottomLeftYCoord); // Clip inner bottom left cap\n\n  ctx.lineTo(left + borderLeftWidth, bottomLeftYCoord); // Ellipse coefficients inner top right cap\n\n  const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n  const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n  const c1 = innerBottomLeftRadiusX * (1.0 - KAPPA);\n  const c2 = innerBottomLeftRadiusY * (1.0 - KAPPA); // Clip inner bottom left cap\n\n  ctx.bezierCurveTo(left + borderLeftWidth, top + height - borderBottomWidth - c2, left + borderLeftWidth + c1, top + height - borderBottomWidth, left + borderLeftWidth + innerBottomLeftRadiusX, top + height - borderBottomWidth); // Clip inner bottom border edge\n\n  ctx.lineTo(left + width - Math.max(rbr, borderRightWidth), top + height - borderBottomWidth); // Ellipse coefficients inner top left cap\n\n  const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n  const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n  const c3 = innerBottomRightRadiusX * (1.0 - KAPPA);\n  const c4 = innerBottomRightRadiusY * (1.0 - KAPPA);\n  const bottomRightYCoord = top + height - Math.max(borderBottomWidth, rbr); // Clip inner top left cap\n\n  ctx.bezierCurveTo(left + width - borderRightWidth - c3, top + height - borderBottomWidth, left + width - borderRightWidth, top + height - borderBottomWidth - c4, left + width - borderRightWidth, bottomRightYCoord);\n  ctx.lineTo(left + width, bottomRightYCoord); // Move down in case the margin exceedes the radius\n\n  ctx.lineTo(left + width, top + height - rbr); // Ellipse coefficients outer top left cap\n\n  const c5 = rbr * (1.0 - KAPPA); // Clip outer top left cap\n\n  ctx.bezierCurveTo(left + width, top + height - c5, left + width - c5, top + height, left + width - rbr, top + height);\n  ctx.closePath();\n  ctx.clip(); // Clip border bottom cap joins\n\n  if (borderRightWidth) {\n    const brSlope = borderBottomWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n\n  if (borderLeftWidth) {\n    const trSlope = -borderBottomWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left + width, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\n\nconst fillBorderBottom = (ctx, layout, style, rbl, rbr) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderBottomColor,\n    borderBottomStyle,\n    borderBottomWidth,\n    borderRightWidth,\n    borderLeftWidth\n  } = style;\n  const c0 = rbl * (1.0 - KAPPA);\n  const c1 = rbr * (1.0 - KAPPA);\n  ctx.moveTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - c1, left + width - c1, top + height, left + width - rbr, top + height);\n  ctx.lineTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n  ctx.strokeColor(borderBottomColor);\n  ctx.lineWidth(Math.max(borderBottomWidth, borderRightWidth, borderLeftWidth) * 2);\n\n  if (borderBottomStyle === 'dashed') {\n    ctx.dash(borderBottomWidth * 2, {\n      space: borderBottomWidth * 1.2\n    });\n  } else if (borderBottomStyle === 'dotted') {\n    ctx.dash(borderBottomWidth, {\n      space: borderBottomWidth * 1.2\n    });\n  }\n\n  ctx.stroke();\n  ctx.undash();\n};\n\nconst clipBorderLeft = (ctx, layout, style, rbl, rtl) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderTopWidth,\n    borderLeftWidth,\n    borderBottomWidth\n  } = style; // Clip outer left border edge\n\n  ctx.moveTo(left, top + height - rbl);\n  ctx.lineTo(left, top + rtl); // Ellipse coefficients outer top left cap\n\n  const c0 = rtl * (1.0 - KAPPA); // Clip outer top left cap\n\n  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top); // Move right in case the margin exceedes the radius\n\n  const topLeftCoordX = left + Math.max(borderLeftWidth, rtl);\n  ctx.lineTo(topLeftCoordX, top); // Clip inner top left cap\n\n  ctx.lineTo(topLeftCoordX, top + borderTopWidth); // Ellipse coefficients inner top left cap\n\n  const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n  const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n  const c1 = innerTopLeftRadiusX * (1.0 - KAPPA);\n  const c2 = innerTopLeftRadiusY * (1.0 - KAPPA); // Clip inner top right cap\n\n  ctx.bezierCurveTo(left + borderLeftWidth + c1, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c2, left + borderLeftWidth, top + Math.max(rtl, borderTopWidth)); // Clip inner left border edge\n\n  ctx.lineTo(left + borderLeftWidth, top + height - Math.max(rbl, borderBottomWidth)); // Ellipse coefficients inner bottom left cap\n\n  const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n  const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n  const c3 = innerBottomLeftRadiusX * (1.0 - KAPPA);\n  const c4 = innerBottomLeftRadiusY * (1.0 - KAPPA);\n  const bottomLeftXCoord = left + Math.max(rbl, borderLeftWidth); // Clip inner top left cap\n\n  ctx.bezierCurveTo(left + borderLeftWidth, top + height - borderBottomWidth - c4, left + borderLeftWidth + c3, top + height - borderBottomWidth, bottomLeftXCoord, top + height - borderBottomWidth);\n  ctx.lineTo(bottomLeftXCoord, top + height); // Move left in case the margin exceedes the radius\n\n  ctx.lineTo(left + rbl, top + height); // Ellipse coefficients outer top right cap\n\n  const c5 = rbl * (1.0 - KAPPA); // Clip outer top right cap\n\n  ctx.bezierCurveTo(left + c5, top + height, left, top + height - c5, left, top + height - rbl);\n  ctx.closePath();\n  ctx.clip(); // Clip border right cap joins\n\n  if (borderBottomWidth) {\n    const trSlope = -borderBottomWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left + width, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n\n  if (borderBottomWidth) {\n    const trSlope = -borderTopWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\n\nconst fillBorderLeft = (ctx, layout, style, rbl, rtl) => {\n  const {\n    top,\n    left,\n    height\n  } = layout;\n  const {\n    borderLeftColor,\n    borderLeftStyle,\n    borderLeftWidth,\n    borderTopWidth,\n    borderBottomWidth\n  } = style;\n  const c0 = rbl * (1.0 - KAPPA);\n  const c1 = rtl * (1.0 - KAPPA);\n  ctx.moveTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n  ctx.lineTo(left, top + rtl);\n  ctx.bezierCurveTo(left, top + c1, left + c1, top, left + rtl, top);\n  ctx.strokeColor(borderLeftColor);\n  ctx.lineWidth(Math.max(borderLeftWidth, borderTopWidth, borderBottomWidth) * 2);\n\n  if (borderLeftStyle === 'dashed') {\n    ctx.dash(borderLeftWidth * 2, {\n      space: borderLeftWidth * 1.2\n    });\n  } else if (borderLeftStyle === 'dotted') {\n    ctx.dash(borderLeftWidth, {\n      space: borderLeftWidth * 1.2\n    });\n  }\n\n  ctx.stroke();\n  ctx.undash();\n};\n\nconst shouldRenderBorders = node => node.box && (node.box.borderTopWidth || node.box.borderRightWidth || node.box.borderBottomWidth || node.box.borderLeftWidth);\n\nconst renderBorders = (ctx, node) => {\n  if (!node.box) return;\n  if (!shouldRenderBorders(node)) return;\n  const {\n    width,\n    height,\n    borderTopWidth = 0,\n    borderLeftWidth = 0,\n    borderRightWidth = 0,\n    borderBottomWidth = 0\n  } = node.box;\n  const {\n    opacity = 1,\n    borderTopColor = 'black',\n    borderTopStyle = 'solid',\n    borderLeftColor = 'black',\n    borderLeftStyle = 'solid',\n    borderRightColor = 'black',\n    borderRightStyle = 'solid',\n    borderBottomColor = 'black',\n    borderBottomStyle = 'solid'\n  } = node.style; // @ts-expect-error this is always a number due to resolve border radius step\n\n  const borderTopLeftRadius = node.style.borderTopLeftRadius || 0; // @ts-expect-error this is always a number due to resolve border radius step\n\n  const borderTopRightRadius = node.style.borderTopRightRadius || 0; // @ts-expect-error this is always a number due to resolve border radius step\n\n  const borderBottomLeftRadius = node.style.borderBottomLeftRadius || 0; // @ts-expect-error this is always a number due to resolve border radius step\n\n  const borderBottomRightRadius = node.style.borderBottomRightRadius || 0;\n  const style = {\n    borderTopColor,\n    borderTopWidth,\n    borderTopStyle,\n    borderLeftColor,\n    borderLeftWidth,\n    borderLeftStyle,\n    borderRightColor,\n    borderRightWidth,\n    borderRightStyle,\n    borderBottomColor,\n    borderBottomWidth,\n    borderBottomStyle\n  };\n  const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n  const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n  const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n  const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n  ctx.save();\n  ctx.strokeOpacity(opacity);\n\n  if (borderTopWidth) {\n    ctx.save();\n    clipBorderTop(ctx, node.box, style, rtr, rtl);\n    fillBorderTop(ctx, node.box, style, rtr, rtl);\n    ctx.restore();\n  }\n\n  if (borderRightWidth) {\n    ctx.save();\n    clipBorderRight(ctx, node.box, style, rtr, rbr);\n    fillBorderRight(ctx, node.box, style, rtr, rbr);\n    ctx.restore();\n  }\n\n  if (borderBottomWidth) {\n    ctx.save();\n    clipBorderBottom(ctx, node.box, style, rbl, rbr);\n    fillBorderBottom(ctx, node.box, style, rbl, rbr);\n    ctx.restore();\n  }\n\n  if (borderLeftWidth) {\n    ctx.save();\n    clipBorderLeft(ctx, node.box, style, rbl, rtl);\n    fillBorderLeft(ctx, node.box, style, rbl, rtl);\n    ctx.restore();\n  }\n\n  ctx.restore();\n};\n\nconst drawBackground = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  const color = parseColor(node.style.backgroundColor);\n  const nodeOpacity = isNil(node.style?.opacity) ? 1 : node.style.opacity;\n  const opacity = Math.min(color.opacity, nodeOpacity);\n  ctx.fillOpacity(opacity).fillColor(color.value).rect(left, top, width, height).fill();\n};\n\nconst renderBackground = (ctx, node) => {\n  const hasBackground = !!node.box && !!node.style?.backgroundColor;\n\n  if (hasBackground) {\n    ctx.save();\n    clipNode(ctx, node);\n    drawBackground(ctx, node);\n    ctx.restore();\n  }\n};\n\nconst isString = value => typeof value === 'string';\n\nconst isSrcId = value => /^#.+/.test(value);\n\nconst renderLink = (ctx, node, src) => {\n  if (!src || !node.box) return;\n  const isId = isSrcId(src);\n  const method = isId ? 'goTo' : 'link';\n  const value = isId ? src.slice(1) : src;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  ctx[method](left, top, width, height, value);\n};\n\nconst setLink = (ctx, node) => {\n  const props = node.props || {};\n  if ('src' in props && isString(props.src)) return renderLink(ctx, node, props.src);\n  if ('href' in props && isString(props.href)) return renderLink(ctx, node, props.href);\n};\n\nconst setDestination = (ctx, node) => {\n  if (!node.box) return;\n  if (!node.props) return;\n\n  if ('id' in node.props) {\n    ctx.addNamedDestination(node.props.id, 'XYZ', null, node.box.top, null);\n  }\n};\n\nconst clean = options => {\n  const opt = { ...options\n  }; // We need to ensure the elements are no present if not true\n\n  Object.entries(opt).forEach(pair => {\n    if (!pair[1]) {\n      delete opt[pair[0]];\n    }\n  });\n  return opt;\n};\n\nconst parseCommonFormOptions = node => {\n  // Common Options\n  return {\n    required: node.props?.required || false,\n    noExport: node.props?.noExport || false,\n    readOnly: node.props?.readOnly || false,\n    value: node.props?.value || undefined,\n    defaultValue: node.props?.defaultValue || undefined\n  };\n};\n\nconst parseTextInputOptions = (node, fieldSet) => {\n  return clean({ ...parseCommonFormOptions(node),\n    parent: fieldSet || undefined,\n    align: node.props?.align || 'left',\n    multiline: node.props?.multiline || undefined,\n    password: node.props?.password || false,\n    noSpell: node.props?.noSpell || false,\n    format: node.props?.format || undefined,\n    fontSize: node.props?.fontSize || undefined,\n    MaxLen: node.props?.maxLength || undefined\n  });\n};\n\nconst parseSelectAndListFieldOptions = node => {\n  return clean({ ...parseCommonFormOptions(node),\n    sort: node.props?.sort || false,\n    edit: node.props?.edit || false,\n    multiSelect: node.props?.multiSelect || false,\n    noSpell: node.props?.noSpell || false,\n    select: node.props?.select || ['']\n  });\n};\n\nconst getAppearance = (ctx, codepoint, width, height) => {\n  const appearance = ctx.ref({\n    Type: 'XObject',\n    Subtype: 'Form',\n    BBox: [0, 0, width, height],\n    Resources: {\n      ProcSet: ['PDF', 'Text', 'ImageB', 'ImageC', 'ImageI'],\n      Font: {\n        ZaDi: ctx._acroform.fonts.ZaDi\n      }\n    }\n  });\n  appearance.initDeflate();\n  appearance.write(`/Tx BMC\\nq\\n/ZaDi ${height * 0.8} Tf\\nBT\\n${width * 0.45} ${height / 4} Td (${codepoint}) Tj\\nET\\nQ\\nEMC`);\n  appearance.end(null);\n  return appearance;\n};\n\nconst parseCheckboxOptions = (ctx, node, fieldSet) => {\n  const {\n    width,\n    height\n  } = node.box || {};\n  const onOption = node.props?.onState || 'Yes';\n  const offOption = node.props?.offState || 'Off';\n  const xMark = node.props?.xMark || false;\n\n  if (!Object.prototype.hasOwnProperty.call(ctx._acroform.fonts, 'ZaDi')) {\n    const ref = ctx.ref({\n      Type: 'Font',\n      Subtype: 'Type1',\n      BaseFont: 'ZapfDingbats'\n    });\n    ctx._acroform.fonts.ZaDi = ref;\n    ref.end(null);\n  }\n\n  const normalAppearance = {\n    [onOption]: getAppearance(ctx, xMark ? '8' : '4', width, height),\n    [offOption]: getAppearance(ctx, xMark ? ' ' : '8', width, height)\n  };\n  return clean({ ...parseCommonFormOptions(node),\n    backgroundColor: node.props?.backgroundColor || undefined,\n    borderColor: node.props?.borderColor || undefined,\n    parent: fieldSet || undefined,\n    value: `/${node.props?.checked === true ? onOption : offOption}`,\n    defaultValue: `/${node.props?.checked === true ? onOption : offOption}`,\n    AS: node.props?.checked === true ? onOption : offOption,\n    AP: {\n      N: normalAppearance,\n      D: normalAppearance\n    }\n  });\n};\n\nconst renderTextInput = (ctx, node, options) => {\n  if (!node.box) return;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box; // Element's name\n\n  const name = node.props?.name || '';\n  const fieldSetOptions = options.fieldSets?.at(0);\n\n  if (!ctx._root.data.AcroForm) {\n    ctx.initForm();\n  }\n\n  ctx.formText(name, left, top, width, height, parseTextInputOptions(node, fieldSetOptions));\n};\n\nconst renderSelect = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box; // Element's name\n\n  const name = node.props?.name || '';\n\n  if (!ctx._root.data.AcroForm) {\n    ctx.initForm();\n  }\n\n  ctx.formCombo(name, left, top, width, height, parseSelectAndListFieldOptions(node));\n};\n\nconst renderFieldSet = (ctx, node, options) => {\n  const name = node.props?.name || '';\n\n  if (!ctx._root.data.AcroForm) {\n    ctx.initForm();\n  }\n\n  const formField = ctx.formField(name);\n  const option = options;\n\n  if (!option.fieldSets) {\n    option.fieldSets = [formField];\n  } else {\n    option.fieldSets.push(formField);\n  }\n};\n\nconst cleanUpFieldSet = (_ctx, _node, options) => {\n  options.fieldSets.pop();\n};\n\nconst renderList = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box || {}; // Element's name\n\n  const name = 'name' in node.props ? node.props.name || '' : '';\n\n  if (!ctx._root.data.AcroForm) {\n    ctx.initForm();\n  }\n\n  ctx.formList(name, left, top, width, height, parseSelectAndListFieldOptions(node));\n};\n\nconst renderCheckbox = (ctx, node, options) => {\n  if (!node.box) return;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box; // Element's name\n\n  const name = node.props?.name || '';\n  const fieldSetOptions = options.fieldSets?.at(0);\n\n  if (!ctx._root.data.AcroForm) {\n    ctx.initForm();\n  }\n\n  ctx.formCheckbox(name, left, top, width, height, parseCheckboxOptions(ctx, node, fieldSetOptions));\n};\n\nconst isRecursiveNode = node => node.type !== P.Text && node.type !== P.Svg;\n\nconst renderChildren = (ctx, node, options) => {\n  ctx.save();\n\n  if (node.box) {\n    ctx.translate(node.box.left, node.box.top);\n  }\n\n  const children = node.children || [];\n\n  const renderChild = child => renderNode(ctx, child, options);\n\n  children.forEach(renderChild);\n  ctx.restore();\n};\n\nconst renderFns = {\n  [P.Text]: renderText,\n  [P.Note]: renderNote,\n  [P.Image]: renderImage,\n  [P.FieldSet]: renderFieldSet,\n  [P.TextInput]: renderTextInput,\n  [P.Select]: renderSelect,\n  [P.Checkbox]: renderCheckbox,\n  [P.List]: renderList,\n  [P.Canvas]: renderCanvas,\n  [P.Svg]: renderSvg,\n  [P.Link]: setLink\n};\nconst cleanUpFns = {\n  [P.FieldSet]: cleanUpFieldSet\n};\n\nconst renderNode = (ctx, node, options) => {\n  const overflowHidden = node.style?.overflow === 'hidden';\n  const shouldRenderChildren = isRecursiveNode(node);\n  if (node.type === P.Page) renderPage(ctx, node);\n  ctx.save();\n  if (overflowHidden) clipNode(ctx, node);\n  applyTransformations(ctx, node);\n  renderBackground(ctx, node);\n  renderBorders(ctx, node);\n  const renderFn = renderFns[node.type];\n  if (renderFn) renderFn(ctx, node, options);\n  if (shouldRenderChildren) renderChildren(ctx, node, options);\n  const cleanUpFn = cleanUpFns[node.type];\n  if (cleanUpFn) cleanUpFn(ctx, node, options);\n  setDestination(ctx, node);\n  renderDebug(ctx, node);\n  ctx.restore();\n};\n\nconst addNodeBookmark = (ctx, node, pageNumber, registry) => {\n  if (!node.box) return;\n  if (!node.props) return;\n\n  if ('bookmark' in node.props && node.props.bookmark) {\n    const bookmark = node.props.bookmark;\n    const {\n      title,\n      parent,\n      expanded,\n      zoom,\n      fit\n    } = bookmark;\n    const outline = registry[parent] || ctx.outline;\n    const top = bookmark.top || node.box.top;\n    const left = bookmark.left || node.box.left;\n    const instance = outline.addItem(title, {\n      pageNumber,\n      expanded,\n      top,\n      left,\n      zoom,\n      fit\n    });\n    registry[bookmark.ref] = instance;\n  }\n\n  if (!node.children) return;\n  node.children.forEach(child => addNodeBookmark(ctx, child, pageNumber, registry));\n};\n\nconst addBookmarks = (ctx, root) => {\n  const registry = {};\n  const pages = root.children || [];\n  pages.forEach((page, i) => {\n    addNodeBookmark(ctx, page, i, registry);\n  });\n};\n\nconst render = (ctx, doc) => {\n  const pages = doc.children || [];\n  const options = {\n    imageCache: new Map(),\n    fieldSets: []\n  };\n  pages.forEach(page => renderNode(ctx, page, options));\n  addBookmarks(ctx, doc);\n  ctx.end();\n  return ctx;\n};\n\nexport { render as default };","map":{"version":3,"sources":["C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/@react-pdf/render/lib/index.js"],"names":["P","isNil","matchPercent","absPath","parsePath","normalizePath","colorString","renderPath","ctx","node","d","props","path","KAPPA$3","Math","sqrt","renderRect","x","y","rx","ry","width","height","krx","kry","moveTo","lineTo","bezierCurveTo","closePath","renderLine$1","x1","x2","y1","y2","renderGroup","KAPPA$2","drawEllipse","cx","cy","ox","oy","xe","ye","xm","ym","renderEllipse","renderCircle","r","number","n","round","Error","_renderGlyphs","encoded","positions","commands","scale","_fontSize","i","last","hadOffset","save","transform","page","fonts","_font","id","ref","addContent","addSegment","cur","hex","slice","join","advance","xAdvance","advanceWidth","push","flush","s","length","pos","xOffset","yOffset","restore","renderGlyphs","glyphs","unitsPerEm","font","advanceWidthScale","encodedGlyphs","encodeGlyphs","encodedPositions","map","yAdvance","renderRun$1","run","runAdvanceWidth","attributes","fontSize","color","opacity","fillColor","fillOpacity","type","fullName","error","console","log","translate","renderSpan","line","textAnchor","dominantBaseline","box","runs","ascent","xHeight","descent","capHeight","xTranslate","yTranslate","forEach","renderSvgText","children","span","lines","pairs","values","result","parsePoints","points","trim","replace","split","mappedValues","parseFloat","drawPolyline","p","renderPolyline","renderPolygon","renderImage$1","image","data","style","paddingTop","paddingLeft","warn","href","KAPPA$1","clipNode","top","left","borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius","rtr","min","ctr","rbr","cbr","rbl","cbl","rtl","ctl","clip","applySingleTransformation","origin","operation","value","scaleX","scaleY","angle","rotate","xAngle","yAngle","radx","PI","rady","tanx","tan","tany","Array","from","applyTransformations","propsTransform","undefined","operations","getPathBoundingBox","bounds","Infinity","l","j","getCircleBoundingBox","getEllipseBoundingBox","getLineBoundingBox","max","getRectBoundingBox","getPolylineBoundingBox","xValues","yValues","boundingBoxFns","Rect","Line","Path","Circle","Ellipse","Polygon","Polyline","getBoundingBox","boundingBoxFn","setStrokeWidth","lineWidth","strokeWidth","setStrokeColor","strokeColor","stroke","setOpacity","setFillOpacity","setStrokeOpacity","strokeOpacity","setLineJoin","lineJoin","strokeLinejoin","setLineCap","lineCap","strokeLinecap","setLineDash","strokeDasharray","dash","Number","hasLinearGradientFill","fill","LinearGradient","hasRadialGradientFill","RadialGradient","multiplyMatrices","m1","m2","a","b","c","e","f","transformGradient","grad","transforms","bbox","units","matrices","cos","sin","matrix","reduce","setTransform","setLinearGradientFill","gradient","gradientUnits","gradientTransform","m0","m3","m4","m5","linearGradient","stop","offset","stopColor","stopOpacity","setRadialGradientFill","fx","fy","radialGradient","setFillColor","setFill","draw","fillAndStroke","fillRule","noop","renderFns$1","Tspan","TextInstance","G","Text","Image","renderNode$1","renderFn","drawNode","clipPath","child","drawChildren","resolveAspectRatio","viewBox","preserveAspectRatio","meetOrSlice","align","minX","minY","logicalWidth","maxX","logicalHeight","maxY","logicalRatio","physicalRatio","moveToOrigin","renderSvg","black","parseColor","parsed","get","to","DEST_REGEXP","isSrcId$1","src","match","renderAttachment","attachment","fit","valign","renderAttachments","space","glyphForCodePoint","objectReplacement","attachmentAdvance","position","glyph","renderRun","link","goTo","renderBackground$1","rect","backgroundColor","renderDecorationLine","decorationLine","test","dist","step","stepCount","floor","remainingWidth","adjustment","cp1y","cp2y","renderLine","lineAscent","isLastRun","overflowRight","backgroundRect","decorationLines","renderBlock","block","renderText","blocks","initialY","offsetX","alignOffset","renderPage","dpi","userUnit","addPage","size","margin","renderNote","note","embedImage","_imageRegistry","openImage","obj","embed","isNumeric","isNaN","isFinite","applyContainObjectFit","cw","ch","iw","ih","px","py","cr","ir","pxp","pyp","pxv","percent","pyv","applyNoneObjectFit","applyCoverObjectFit","applyScaleDownObjectFit","containDimension","noneDimension","applyFillObjectFit","resolveObjectFit","drawImage","options","objectFit","objectPositionX","objectPositionY","paddingRight","paddingBottom","imageCache","Map","cacheKey","key","set","imageOpacity","JSON","stringify","source","renderImage","CONTENT_COLOR","PADDING_COLOR","MARGIN_COLOR","debugContent","borderLeftWidth","borderTopWidth","borderRightWidth","borderBottomWidth","debugPadding","debugMargin","marginLeft","marginTop","marginRight","marginBottom","debugText","roundedWidth","roundedHeight","text","debugOrigin","circle","renderDebug","debug","availableMethods","painter","acc","prop","renderCanvas","availableWidth","availableHeight","paint","KAPPA","clipBorderTop","layout","c0","topRightYCoord","innerTopRightRadiusX","innerTopRightRadiusY","c1","c2","innerTopLeftRadiusX","innerTopLeftRadiusY","c3","c4","topLeftYCoord","c5","trSlope","fillBorderTop","borderTopColor","borderTopStyle","undash","clipBorderRight","topBottomXCoord","innerBottomRightRadiusX","innerBottomRightRadiusY","topRightXCoord","brSlope","fillBorderRight","borderRightColor","borderRightStyle","clipBorderBottom","bottomLeftYCoord","innerBottomLeftRadiusX","innerBottomLeftRadiusY","bottomRightYCoord","fillBorderBottom","borderBottomColor","borderBottomStyle","clipBorderLeft","topLeftCoordX","bottomLeftXCoord","fillBorderLeft","borderLeftColor","borderLeftStyle","shouldRenderBorders","renderBorders","drawBackground","nodeOpacity","renderBackground","hasBackground","isString","isSrcId","renderLink","isId","method","setLink","setDestination","addNamedDestination","clean","opt","Object","entries","pair","parseCommonFormOptions","required","noExport","readOnly","defaultValue","parseTextInputOptions","fieldSet","parent","multiline","password","noSpell","format","MaxLen","maxLength","parseSelectAndListFieldOptions","sort","edit","multiSelect","select","getAppearance","codepoint","appearance","Type","Subtype","BBox","Resources","ProcSet","Font","ZaDi","_acroform","initDeflate","write","end","parseCheckboxOptions","onOption","onState","offOption","offState","xMark","prototype","hasOwnProperty","call","BaseFont","normalAppearance","borderColor","checked","AS","AP","N","D","renderTextInput","name","fieldSetOptions","fieldSets","at","_root","AcroForm","initForm","formText","renderSelect","formCombo","renderFieldSet","formField","option","cleanUpFieldSet","_ctx","_node","pop","renderList","formList","renderCheckbox","formCheckbox","isRecursiveNode","Svg","renderChildren","renderChild","renderNode","renderFns","Note","FieldSet","TextInput","Select","Checkbox","List","Canvas","Link","cleanUpFns","overflowHidden","overflow","shouldRenderChildren","Page","cleanUpFn","addNodeBookmark","pageNumber","registry","bookmark","title","expanded","zoom","outline","instance","addItem","addBookmarks","root","pages","render","doc","default"],"mappings":"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","sourcesContent":["import * as P from '@react-pdf/primitives';\nimport { isNil, matchPercent } from '@react-pdf/fns';\nimport absPath from 'abs-svg-path';\nimport parsePath from 'parse-svg-path';\nimport normalizePath from 'normalize-svg-path';\nimport colorString from 'color-string';\n\nconst renderPath = (ctx, node) => {\n    const d = node.props?.d;\n    if (d)\n        ctx.path(node.props.d);\n};\n\nconst KAPPA$3 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst renderRect = (ctx, node) => {\n    const x = node.props?.x || 0;\n    const y = node.props?.y || 0;\n    const rx = node.props?.rx || 0;\n    const ry = node.props?.ry || 0;\n    const width = node.props?.width || 0;\n    const height = node.props?.height || 0;\n    if (!width || !height)\n        return;\n    if (rx && ry) {\n        const krx = rx * KAPPA$3;\n        const kry = ry * KAPPA$3;\n        ctx.moveTo(x + rx, y);\n        ctx.lineTo(x - rx + width, y);\n        ctx.bezierCurveTo(x - rx + width + krx, y, x + width, y + ry - kry, x + width, y + ry);\n        ctx.lineTo(x + width, y + height - ry);\n        ctx.bezierCurveTo(x + width, y + height - ry + kry, x - rx + width + krx, y + height, x - rx + width, y + height);\n        ctx.lineTo(x + rx, y + height);\n        ctx.bezierCurveTo(x + rx - krx, y + height, x, y + height - ry + kry, x, y + height - ry);\n        ctx.lineTo(x, y + ry);\n        ctx.bezierCurveTo(x, y + ry - kry, x + rx - krx, y, x + rx, y);\n    }\n    else {\n        ctx.moveTo(x, y);\n        ctx.lineTo(x + width, y);\n        ctx.lineTo(x + width, y + height);\n        ctx.lineTo(x, y + height);\n    }\n    ctx.closePath();\n};\n\nconst renderLine$1 = (ctx, node) => {\n    const { x1, x2, y1, y2 } = node.props || {};\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n};\n\nconst renderGroup = () => {\n    // noop\n};\n\nconst KAPPA$2 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst drawEllipse = (ctx, rx, ry, cx = 0, cy = 0) => {\n    const x = cx - rx;\n    const y = cy - ry;\n    const ox = rx * KAPPA$2;\n    const oy = ry * KAPPA$2;\n    const xe = x + rx * 2;\n    const ye = y + ry * 2;\n    const xm = x + rx;\n    const ym = y + ry;\n    ctx.moveTo(x, ym);\n    ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n    ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n    ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n    ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n    ctx.closePath();\n};\nconst renderEllipse = (ctx, node) => {\n    const { cx, cy, rx, ry } = node.props || {};\n    drawEllipse(ctx, rx, ry, cx, cy);\n};\n\nconst renderCircle = (ctx, node) => {\n    const cx = node.props?.cx;\n    const cy = node.props?.cy;\n    const r = node.props?.r;\n    drawEllipse(ctx, r, r, cx, cy);\n};\n\n/* eslint-disable no-return-assign */\nconst number = (n) => {\n    if (n > -1e21 && n < 1e21) {\n        return Math.round(n * 1e6) / 1e6;\n    }\n    throw new Error(`unsupported number: ${n}`);\n};\nconst _renderGlyphs = (ctx, encoded, positions, x, y) => {\n    const commands = [];\n    const scale = ctx._fontSize / 1000;\n    let i;\n    let last = 0;\n    let hadOffset = false;\n    ctx.save();\n    // flip coordinate system\n    ctx.transform(1, 0, 0, -1, 0, ctx.page.height);\n    y = ctx.page.height - y;\n    // add current font to page if necessary\n    if (ctx.page.fonts[ctx._font.id] == null) {\n        ctx.page.fonts[ctx._font.id] = ctx._font.ref();\n    }\n    // begin the text object\n    ctx.addContent('BT');\n    // text position\n    ctx.addContent(`1 0 0 1 ${number(x)} ${number(y)} Tm`);\n    // font and font size\n    ctx.addContent(`/${ctx._font.id} ${number(ctx._fontSize)} Tf`);\n    // Adds a segment of text to the TJ command buffer\n    const addSegment = (cur) => {\n        if (last < cur) {\n            const hex = encoded.slice(last, cur).join('');\n            const advance = positions[cur - 1].xAdvance - positions[cur - 1].advanceWidth;\n            commands.push(`<${hex}> ${number(-advance)}`);\n        }\n        return (last = cur);\n    };\n    // Flushes the current TJ commands to the output stream\n    const flush = (s) => {\n        addSegment(s);\n        if (commands.length > 0) {\n            ctx.addContent(`[${commands.join(' ')}] TJ`);\n            return (commands.length = 0);\n        }\n    };\n    for (i = 0; i < positions.length; i += 1) {\n        // If we have an x or y offset, we have to break out of the current TJ command\n        // so we can move the text position.\n        const pos = positions[i];\n        if (pos.xOffset || pos.yOffset) {\n            // Flush the current buffer\n            flush(i);\n            // Move the text position and flush just the current character\n            ctx.addContent(`1 0 0 1 ${number(x + pos.xOffset * scale)} ${number(y + pos.yOffset * scale)} Tm`);\n            flush(i + 1);\n            hadOffset = true;\n        }\n        else {\n            // If the last character had an offset, reset the text position\n            if (hadOffset) {\n                ctx.addContent(`1 0 0 1 ${number(x)} ${number(y)} Tm`);\n                hadOffset = false;\n            }\n            // Group segments that don't have any advance adjustments\n            if (pos.xAdvance - pos.advanceWidth !== 0) {\n                addSegment(i + 1);\n            }\n        }\n        x += pos.xAdvance * scale;\n    }\n    // Flush any remaining commands\n    flush(i);\n    // end the text object\n    ctx.addContent('ET');\n    // restore flipped coordinate system\n    return ctx.restore();\n};\nconst renderGlyphs = (ctx, glyphs, positions, x, y) => {\n    const scale = 1000 / ctx._fontSize;\n    const unitsPerEm = ctx._font.font.unitsPerEm || 1000;\n    const advanceWidthScale = 1000 / unitsPerEm;\n    // Glyph encoding and positioning\n    const encodedGlyphs = ctx._font.encodeGlyphs(glyphs);\n    const encodedPositions = positions.map((pos, i) => ({\n        xAdvance: pos.xAdvance * scale,\n        yAdvance: pos.yAdvance * scale,\n        xOffset: pos.xOffset,\n        yOffset: pos.yOffset,\n        advanceWidth: glyphs[i].advanceWidth * advanceWidthScale,\n    }));\n    return _renderGlyphs(ctx, encodedGlyphs, encodedPositions, x, y);\n};\n\nconst renderRun$1 = (ctx, run) => {\n    if (!run.glyphs)\n        return;\n    if (!run.positions)\n        return;\n    const runAdvanceWidth = run.xAdvance;\n    const font = run.attributes.font?.[0];\n    const { fontSize, color, opacity } = run.attributes;\n    if (color)\n        ctx.fillColor(color);\n    ctx.fillOpacity(opacity);\n    if (font) {\n        ctx.font(font.type === 'STANDARD' ? font.fullName : font, fontSize);\n    }\n    try {\n        renderGlyphs(ctx, run.glyphs, run.positions, 0, 0);\n    }\n    catch (error) {\n        console.log(error);\n    }\n    ctx.translate(runAdvanceWidth, 0);\n};\nconst renderSpan = (ctx, line, textAnchor, dominantBaseline) => {\n    ctx.save();\n    const x = line.box?.x || 0;\n    const y = line.box?.y || 0;\n    const font = line.runs[0]?.attributes.font?.[0];\n    const scale = line.runs[0]?.attributes?.scale || 1;\n    const width = line.xAdvance;\n    if (!font)\n        return;\n    const ascent = font.ascent * scale;\n    const xHeight = font.xHeight * scale;\n    const descent = font.descent * scale;\n    const capHeight = font.capHeight * scale;\n    let xTranslate = x;\n    let yTranslate = y;\n    switch (textAnchor) {\n        case 'middle':\n            xTranslate = x - width / 2;\n            break;\n        case 'end':\n            xTranslate = x - width;\n            break;\n        default:\n            xTranslate = x;\n            break;\n    }\n    switch (dominantBaseline) {\n        case 'middle':\n        case 'central':\n            yTranslate = y + capHeight / 2;\n            break;\n        case 'hanging':\n            yTranslate = y + capHeight;\n            break;\n        case 'mathematical':\n            yTranslate = y + xHeight;\n            break;\n        case 'text-after-edge':\n            yTranslate = y + descent;\n            break;\n        case 'text-before-edge':\n            yTranslate = y + ascent;\n            break;\n        default:\n            yTranslate = y;\n            break;\n    }\n    ctx.translate(xTranslate, yTranslate);\n    line.runs.forEach((run) => renderRun$1(ctx, run));\n    ctx.restore();\n};\nconst renderSvgText = (ctx, node) => {\n    const children = node.children;\n    children.forEach((span) => renderSpan(ctx, span.lines[0], span.props.textAnchor, span.props.dominantBaseline));\n};\n\nconst pairs = (values) => {\n    const result = [];\n    for (let i = 0; i < values.length; i += 2) {\n        result.push([values[i], values[i + 1]]);\n    }\n    return result;\n};\n/**\n * Parse svg-like points into number arrays\n *\n * @param points string ex. \"20,30 50,60\"\n * @returns points array ex. [[20, 30], [50, 60]]\n */\nconst parsePoints = (points) => {\n    let values = (points || '')\n        .trim()\n        .replace(/,/g, ' ')\n        .replace(/(\\d)-(\\d)/g, '$1 -$2')\n        .split(/\\s+/);\n    if (values.length % 2 !== 0) {\n        values = values.slice(0, -1);\n    }\n    const mappedValues = values.map(parseFloat);\n    return pairs(mappedValues);\n};\n\nconst drawPolyline = (ctx, points) => {\n    if (points.length > 0) {\n        ctx.moveTo(points[0][0], points[0][1]);\n        points.slice(1).forEach((p) => ctx.lineTo(p[0], p[1]));\n    }\n};\nconst renderPolyline = (ctx, node) => {\n    const points = parsePoints(node.props.points || '');\n    drawPolyline(ctx, points);\n};\n\nconst renderPolygon = (ctx, node) => {\n    const points = parsePoints(node.props.points || '');\n    drawPolyline(ctx, points);\n    ctx.closePath();\n};\n\nconst renderImage$1 = (ctx, node) => {\n    if (!node.box)\n        return;\n    if (!node.image?.data)\n        return;\n    const { x = 0, y = 0 } = node.props;\n    const { width, height, opacity } = node.style;\n    const paddingTop = node.box.paddingLeft || 0;\n    const paddingLeft = node.box.paddingLeft || 0;\n    if (width === 0 || height === 0) {\n        console.warn(`Image with src '${node.props.href}' skipped due to invalid dimensions`);\n        return;\n    }\n    if (typeof width === 'string' || typeof height === 'string') {\n        console.warn(`Image with src '${node.props.href}' skipped due to percentage width or height`);\n        return;\n    }\n    ctx.save();\n    ctx\n        .fillOpacity(opacity || 1)\n        .image(node.image.data, x + paddingLeft, y + paddingTop, {\n        width,\n        height,\n    });\n    ctx.restore();\n};\n\n// This constant is used to approximate a symmetrical arc using a cubic\n// Bezier curve.\nconst KAPPA$1 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst clipNode = (ctx, node) => {\n    if (!node.box)\n        return;\n    if (!node.style)\n        return;\n    const { top, left, width, height } = node.box;\n    const { borderTopLeftRadius = 0, borderTopRightRadius = 0, borderBottomRightRadius = 0, borderBottomLeftRadius = 0, } = node.style;\n    // Border top\n    // @ts-expect-error this is always a number due to resolve border radius step\n    const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n    const ctr = rtr * (1.0 - KAPPA$1);\n    ctx.moveTo(left + rtr, top);\n    ctx.lineTo(left + width - rtr, top);\n    ctx.bezierCurveTo(left + width - ctr, top, left + width, top + ctr, left + width, top + rtr);\n    // Border right\n    // @ts-expect-error this is always a number due to resolve border radius step\n    const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n    const cbr = rbr * (1.0 - KAPPA$1);\n    ctx.lineTo(left + width, top + height - rbr);\n    ctx.bezierCurveTo(left + width, top + height - cbr, left + width - cbr, top + height, left + width - rbr, top + height);\n    // Border bottom\n    // @ts-expect-error this is always a number due to resolve border radius step\n    const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n    const cbl = rbl * (1.0 - KAPPA$1);\n    ctx.lineTo(left + rbl, top + height);\n    ctx.bezierCurveTo(left + cbl, top + height, left, top + height - cbl, left, top + height - rbl);\n    // Border left\n    // @ts-expect-error this is always a number due to resolve border radius step\n    const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n    const ctl = rtl * (1.0 - KAPPA$1);\n    ctx.lineTo(left, top + rtl);\n    ctx.bezierCurveTo(left, top + ctl, left + ctl, top, left + rtl, top);\n    ctx.closePath();\n    ctx.clip();\n};\n\nconst applySingleTransformation = (ctx, transform, origin) => {\n    const { operation, value } = transform;\n    switch (operation) {\n        case 'scale': {\n            const [scaleX, scaleY] = value;\n            ctx.scale(scaleX, scaleY, { origin });\n            break;\n        }\n        case 'rotate': {\n            const [angle] = value;\n            ctx.rotate(angle, { origin });\n            break;\n        }\n        case 'translate': {\n            const [x, y = 0] = value;\n            ctx.translate(x, y, { origin });\n            break;\n        }\n        case 'skew': {\n            const [xAngle = 0, yAngle = 0] = value;\n            const radx = (xAngle * Math.PI) / 180;\n            const rady = (yAngle * Math.PI) / 180;\n            const tanx = Math.tan(radx);\n            const tany = Math.tan(rady);\n            let x = 0;\n            let y = 0;\n            if (origin != null) {\n                [x, y] = Array.from(origin);\n                const x1 = x + tanx * y;\n                const y1 = y + tany * x;\n                x -= x1;\n                y -= y1;\n            }\n            ctx.transform(1, tany, tanx, 1, x, y);\n            break;\n        }\n        case 'matrix': {\n            ctx.transform(...value);\n            break;\n        }\n        default: {\n            console.error(`Transform operation: '${operation}' doesn't supported`);\n        }\n    }\n};\nconst applyTransformations = (ctx, node) => {\n    if (!node.origin)\n        return;\n    const { props, style } = node;\n    const origin = [node.origin.left, node.origin.top];\n    const propsTransform = 'transform' in props ? props.transform : undefined;\n    const operations = style?.transform || propsTransform || [];\n    operations.forEach((operation) => {\n        applySingleTransformation(ctx, operation, origin);\n    });\n};\n\n// From https://github.com/dy/svg-path-bounds/blob/master/index.js\nconst getPathBoundingBox = (node) => {\n    const path = normalizePath(absPath(parsePath(node.props?.d || '')));\n    if (!path.length)\n        return [0, 0, 0, 0];\n    const bounds = [Infinity, Infinity, -Infinity, -Infinity];\n    for (let i = 0, l = path.length; i < l; i += 1) {\n        const points = path[i].slice(1);\n        for (let j = 0; j < points.length; j += 2) {\n            if (points[j + 0] < bounds[0])\n                bounds[0] = points[j + 0];\n            if (points[j + 1] < bounds[1])\n                bounds[1] = points[j + 1];\n            if (points[j + 0] > bounds[2])\n                bounds[2] = points[j + 0];\n            if (points[j + 1] > bounds[3])\n                bounds[3] = points[j + 1];\n        }\n    }\n    return bounds;\n};\nconst getCircleBoundingBox = (node) => {\n    const r = node.props?.r || 0;\n    const cx = node.props?.cx || 0;\n    const cy = node.props?.cy || 0;\n    return [cx - r, cy - r, cx + r, cy + r];\n};\nconst getEllipseBoundingBox = (node) => {\n    const cx = node.props?.cx || 0;\n    const cy = node.props?.cy || 0;\n    const rx = node.props?.rx || 0;\n    const ry = node.props?.ry || 0;\n    return [cx - rx, cy - ry, cx + rx, cy + ry];\n};\nconst getLineBoundingBox = (node) => {\n    const x1 = node.props?.x1 || 0;\n    const y1 = node.props?.y1 || 0;\n    const x2 = node.props?.x2 || 0;\n    const y2 = node.props?.y2 || 0;\n    return [\n        Math.min(x1, x2),\n        Math.min(y1, y2),\n        Math.max(x1, x2),\n        Math.max(y1, y2),\n    ];\n};\nconst getRectBoundingBox = (node) => {\n    const x = node.props?.x || 0;\n    const y = node.props?.y || 0;\n    const width = node.props?.width || 0;\n    const height = node.props?.height || 0;\n    return [x, y, x + width, y + height];\n};\nconst max = (values) => Math.max(-Infinity, ...values);\nconst min = (values) => Math.min(Infinity, ...values);\nconst getPolylineBoundingBox = (node) => {\n    const points = parsePoints(node.props?.points);\n    const xValues = points.map((p) => p[0]);\n    const yValues = points.map((p) => p[1]);\n    return [min(xValues), min(yValues), max(xValues), max(yValues)];\n};\nconst boundingBoxFns = {\n    [P.Rect]: getRectBoundingBox,\n    [P.Line]: getLineBoundingBox,\n    [P.Path]: getPathBoundingBox,\n    [P.Circle]: getCircleBoundingBox,\n    [P.Ellipse]: getEllipseBoundingBox,\n    [P.Polygon]: getPolylineBoundingBox,\n    [P.Polyline]: getPolylineBoundingBox,\n};\nconst getBoundingBox = (node) => {\n    const boundingBoxFn = boundingBoxFns[node.type];\n    return boundingBoxFn ? boundingBoxFn(node) : [0, 0, 0, 0];\n};\n\nconst setStrokeWidth = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('strokeWidth' in node.props))\n        return;\n    const lineWidth = node.props.strokeWidth;\n    if (lineWidth)\n        ctx.lineWidth(lineWidth);\n};\nconst setStrokeColor = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('stroke' in node.props))\n        return;\n    const strokeColor = node.props.stroke;\n    if (strokeColor)\n        ctx.strokeColor(strokeColor);\n};\nconst setOpacity = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('opacity' in node.props))\n        return;\n    const opacity = node.props.opacity;\n    if (!isNil(opacity))\n        ctx.opacity(opacity);\n};\nconst setFillOpacity = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('fillOpacity' in node.props))\n        return;\n    const fillOpacity = node.props.fillOpacity || null;\n    if (!isNil(fillOpacity))\n        ctx.fillOpacity(fillOpacity);\n};\nconst setStrokeOpacity = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('strokeOpacity' in node.props))\n        return;\n    const strokeOpacity = node.props?.strokeOpacity;\n    if (!isNil(strokeOpacity))\n        ctx.strokeOpacity(strokeOpacity);\n};\nconst setLineJoin = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('strokeLinejoin' in node.props))\n        return;\n    const lineJoin = node.props.strokeLinejoin;\n    if (lineJoin)\n        ctx.lineJoin(lineJoin);\n};\nconst setLineCap = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('strokeLinecap' in node.props))\n        return;\n    const lineCap = node.props?.strokeLinecap;\n    if (lineCap)\n        ctx.lineCap(lineCap);\n};\nconst setLineDash = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('strokeDasharray' in node.props))\n        return;\n    const value = node.props?.strokeDasharray || null;\n    // @ts-expect-error check this works as expected\n    if (value)\n        ctx.dash(value.split(/[\\s,]+/).map(Number));\n};\nconst hasLinearGradientFill = (node) => {\n    if (!node.props)\n        return false;\n    if (!('fill' in node.props))\n        return false;\n    if (typeof node.props.fill === 'string')\n        return false;\n    return node.props.fill?.type === P.LinearGradient;\n};\nconst hasRadialGradientFill = (node) => {\n    if (!node.props)\n        return false;\n    if (!('fill' in node.props))\n        return false;\n    if (typeof node.props.fill === 'string')\n        return false;\n    return node.props.fill?.type === P.RadialGradient;\n};\nfunction multiplyMatrices(m1, m2) {\n    const a = m1[0] * m2[0] + m1[2] * m2[1];\n    const b = m1[1] * m2[0] + m1[3] * m2[1];\n    const c = m1[0] * m2[2] + m1[2] * m2[3];\n    const d = m1[1] * m2[2] + m1[3] * m2[3];\n    const e = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n    const f = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n    return [a, b, c, d, e, f];\n}\nconst transformGradient = (grad, transforms, bbox, units) => {\n    const matrices = transforms.map((transform) => {\n        switch (transform.operation) {\n            case 'scale': {\n                const value = transform.value;\n                return [value[0], 0, 0, value[1], 0, 0];\n            }\n            case 'translate': {\n                const value = transform.value;\n                let x = value[0] || 0;\n                let y = value[1] || 0;\n                if (units === 'objectBoundingBox') {\n                    x = (bbox[2] - bbox[0]) * x;\n                    y = (bbox[3] - bbox[1]) * y;\n                }\n                return [1, 0, 0, 1, x, y];\n            }\n            case 'rotate': {\n                const value = transform.value;\n                const cos = Math.cos(value[0]);\n                const sin = Math.sin(value[0]);\n                return [cos, sin, -sin, cos, 0, 0];\n            }\n            case 'skew': {\n                const value = transform.value;\n                return [1, Math.tan(value[0]), Math.tan(value[1]), 1, 0, 0];\n            }\n            case 'matrix': {\n                const value = transform.value;\n                let x = value[4] || 0;\n                let y = value[5] || 0;\n                if (units === 'objectBoundingBox') {\n                    x = (bbox[2] - bbox[0]) * x;\n                    y = (bbox[3] - bbox[1]) * y;\n                }\n                return [value[0], value[1], value[2], value[3], x, y];\n            }\n            default:\n                return [1, 0, 0, 1, 0, 0];\n        }\n    });\n    const matrix = matrices.reduce(multiplyMatrices, [1, 0, 0, 1, 0, 0]);\n    grad.setTransform(...matrix);\n};\n// Math simplified from https://github.com/devongovett/svgkit/blob/master/src/elements/SVGGradient.js#L104\nconst setLinearGradientFill = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('fill' in node.props))\n        return;\n    const bbox = getBoundingBox(node);\n    const gradient = node.props?.fill;\n    if (!gradient)\n        return;\n    const units = gradient.props.gradientUnits || 'objectBoundingBox';\n    const transforms = gradient.props.gradientTransform || [];\n    let x1 = gradient.props.x1 || 0;\n    let y1 = gradient.props.y1 || 0;\n    let x2 = gradient.props.x2 || 1;\n    let y2 = gradient.props.y2 || 0;\n    if (units === 'objectBoundingBox') {\n        const m0 = bbox[2] - bbox[0];\n        const m3 = bbox[3] - bbox[1];\n        const m4 = bbox[0];\n        const m5 = bbox[1];\n        x1 = m0 * x1 + m4;\n        y1 = m3 * y1 + m5;\n        x2 = m0 * x2 + m4;\n        y2 = m3 * y2 + m5;\n    }\n    const grad = ctx.linearGradient(x1, y1, x2, y2);\n    transformGradient(grad, transforms, bbox, units);\n    gradient.children?.forEach((stop) => {\n        grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);\n    });\n    ctx.fill(grad);\n};\n// Math simplified from https://github.com/devongovett/svgkit/blob/master/src/elements/SVGGradient.js#L155\nconst setRadialGradientFill = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('fill' in node.props))\n        return;\n    const bbox = getBoundingBox(node);\n    const gradient = node.props?.fill;\n    if (!gradient)\n        return;\n    const units = gradient.props.gradientUnits || 'objectBoundingBox';\n    const transforms = gradient.props.gradientTransform || [];\n    let r = gradient.props.r || 0.5;\n    let cx = gradient.props.cx || 0.5;\n    let cy = gradient.props.cy || 0.5;\n    let fx = gradient.props.fx || cx;\n    let fy = gradient.props.fy || cy;\n    if (units === 'objectBoundingBox') {\n        const m0 = bbox[2] - bbox[0];\n        const m3 = bbox[3] - bbox[1];\n        const m4 = bbox[0];\n        const m5 = bbox[1];\n        r = r * m0;\n        cx = m0 * cx + m4;\n        cy = m3 * cy + m5;\n        fx = m0 * fx + m4;\n        fy = m3 * fy + m5;\n    }\n    const grad = ctx.radialGradient(cx, cy, 0, fx, fy, r);\n    transformGradient(grad, transforms, bbox, units);\n    gradient.children?.forEach((stop) => {\n        grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);\n    });\n    ctx.fill(grad);\n};\nconst setFillColor = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('fill' in node.props))\n        return;\n    const fillColor = node.props?.fill;\n    if (fillColor)\n        ctx.fillColor(fillColor);\n};\nconst setFill = (ctx, node) => {\n    if (hasLinearGradientFill(node))\n        return setLinearGradientFill(ctx, node);\n    if (hasRadialGradientFill(node))\n        return setRadialGradientFill(ctx, node);\n    return setFillColor(ctx, node);\n};\nconst draw = (ctx, node) => {\n    const props = node.props || {};\n    if ('fill' in props && 'stroke' in props && props.fill && props.stroke) {\n        ctx.fillAndStroke(props.fillRule);\n    }\n    else if ('fill' in props && props.fill) {\n        ctx.fill(props.fillRule);\n    }\n    else if ('stroke' in props && props.stroke) {\n        ctx.stroke();\n    }\n    else {\n        ctx.save();\n        ctx.opacity(0);\n        ctx.fill(null);\n        ctx.restore();\n    }\n};\nconst noop = () => { };\nconst renderFns$1 = {\n    [P.Tspan]: noop,\n    [P.TextInstance]: noop,\n    [P.Path]: renderPath,\n    [P.Rect]: renderRect,\n    [P.Line]: renderLine$1,\n    [P.G]: renderGroup,\n    [P.Text]: renderSvgText,\n    [P.Circle]: renderCircle,\n    [P.Image]: renderImage$1,\n    [P.Ellipse]: renderEllipse,\n    [P.Polygon]: renderPolygon,\n    [P.Polyline]: renderPolyline,\n};\nconst renderNode$1 = (ctx, node) => {\n    const renderFn = renderFns$1[node.type];\n    if (renderFn) {\n        renderFn(ctx, node);\n    }\n    else {\n        console.warn(`SVG node of type ${node.type} is not currently supported`);\n    }\n};\nconst drawNode = (ctx, node) => {\n    setLineCap(ctx, node);\n    setLineDash(ctx, node);\n    setLineJoin(ctx, node);\n    setStrokeWidth(ctx, node);\n    setStrokeColor(ctx, node);\n    setFill(ctx, node);\n    setStrokeOpacity(ctx, node);\n    setFillOpacity(ctx, node);\n    setOpacity(ctx, node);\n    applyTransformations(ctx, node);\n    renderNode$1(ctx, node);\n    draw(ctx, node);\n};\nconst clipPath = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('clipPath' in node.props))\n        return;\n    const value = node.props.clipPath;\n    if (value) {\n        const children = value.children || [];\n        children.forEach((child) => renderNode$1(ctx, child));\n        ctx.clip();\n    }\n};\nconst drawChildren = (ctx, node) => {\n    const children = node.children || [];\n    children.forEach((child) => {\n        ctx.save();\n        clipPath(ctx, child);\n        drawNode(ctx, child);\n        drawChildren(ctx, child);\n        ctx.restore();\n    });\n};\nconst resolveAspectRatio = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { width, height } = node.box;\n    const { viewBox, preserveAspectRatio } = node.props;\n    const { meetOrSlice = 'meet', align = 'xMidYMid' } = preserveAspectRatio || {};\n    if (viewBox == null || width == null || height == null)\n        return;\n    const x = viewBox?.minX || 0;\n    const y = viewBox?.minY || 0;\n    const logicalWidth = viewBox?.maxX || width;\n    const logicalHeight = viewBox?.maxY || height;\n    const logicalRatio = logicalWidth / logicalHeight;\n    const physicalRatio = width / height;\n    const scaleX = width / logicalWidth;\n    const scaleY = height / logicalHeight;\n    if (align === 'none') {\n        ctx.scale(scaleX, scaleY);\n        ctx.translate(-x, -y);\n        return;\n    }\n    if ((logicalRatio < physicalRatio && meetOrSlice === 'meet') ||\n        (logicalRatio >= physicalRatio && meetOrSlice === 'slice')) {\n        ctx.scale(scaleY, scaleY);\n        switch (align) {\n            case 'xMinYMin':\n            case 'xMinYMid':\n            case 'xMinYMax':\n                ctx.translate(-x, -y);\n                break;\n            case 'xMidYMin':\n            case 'xMidYMid':\n            case 'xMidYMax':\n                ctx.translate(-x - (logicalWidth - (width * logicalHeight) / height) / 2, -y);\n                break;\n            default:\n                ctx.translate(-x - (logicalWidth - (width * logicalHeight) / height), -y);\n        }\n    }\n    else {\n        ctx.scale(scaleX, scaleX);\n        switch (align) {\n            case 'xMinYMin':\n            case 'xMidYMin':\n            case 'xMaxYMin':\n                ctx.translate(-x, -y);\n                break;\n            case 'xMinYMid':\n            case 'xMidYMid':\n            case 'xMaxYMid':\n                ctx.translate(-x, -y - (logicalHeight - (height * logicalWidth) / width) / 2);\n                break;\n            default:\n                ctx.translate(-x, -y - (logicalHeight - (height * logicalWidth) / width));\n        }\n    }\n};\nconst moveToOrigin = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { top, left } = node.box;\n    const paddingLeft = node.box.paddingLeft || 0;\n    const paddingTop = node.box.paddingTop || 0;\n    ctx.translate(left + paddingLeft, top + paddingTop);\n};\nconst renderSvg = (ctx, node) => {\n    ctx.save();\n    clipNode(ctx, node);\n    moveToOrigin(ctx, node);\n    resolveAspectRatio(ctx, node);\n    drawChildren(ctx, node);\n    ctx.restore();\n};\n\nconst black = { value: '#000', opacity: 1 };\n// TODO: parse to number[] in layout to avoid this step\nconst parseColor = (hex) => {\n    if (!hex)\n        return black;\n    const parsed = colorString.get(hex);\n    if (!parsed)\n        return black;\n    const value = colorString.to.hex(parsed.value.slice(0, 3));\n    const opacity = parsed.value[3];\n    return { value, opacity };\n};\n\nconst DEST_REGEXP = /^#.+/;\nconst isSrcId$1 = (src) => src.match(DEST_REGEXP);\nconst renderAttachment = (ctx, attachment) => {\n    const { xOffset = 0, yOffset = 0, width, height, image } = attachment;\n    ctx.translate(-width + xOffset, -height + yOffset);\n    ctx.image(image, 0, 0, {\n        fit: [width, height],\n        align: 'center',\n        valign: 'bottom',\n    });\n};\nconst renderAttachments = (ctx, run) => {\n    if (!run.glyphs)\n        return;\n    if (!run.positions)\n        return;\n    const font = run.attributes.font?.[0];\n    if (!font)\n        return;\n    ctx.save();\n    const space = font.glyphForCodePoint(0x20);\n    const objectReplacement = font.glyphForCodePoint(0xfffc);\n    let attachmentAdvance = 0;\n    for (let i = 0; i < run.glyphs.length; i += 1) {\n        const position = run.positions[i];\n        const glyph = run.glyphs[i];\n        attachmentAdvance += position.xAdvance || 0;\n        if (glyph.id === objectReplacement.id && run.attributes.attachment) {\n            ctx.translate(attachmentAdvance, position.yOffset || 0);\n            renderAttachment(ctx, run.attributes.attachment);\n            run.glyphs[i] = space;\n            attachmentAdvance = 0;\n        }\n    }\n    ctx.restore();\n};\nconst renderRun = (ctx, run) => {\n    if (!run.glyphs)\n        return;\n    if (!run.positions)\n        return;\n    const font = run.attributes.font?.[0];\n    if (!font)\n        return;\n    const { fontSize, link } = run.attributes;\n    const color = parseColor(run.attributes.color);\n    const opacity = isNil(run.attributes.opacity)\n        ? color.opacity\n        : run.attributes.opacity;\n    const { height = 0, descent = 0, xAdvance = 0 } = run;\n    ctx.fillColor(color.value);\n    ctx.fillOpacity(opacity);\n    if (link) {\n        if (isSrcId$1(link)) {\n            ctx.goTo(0, -height - descent, xAdvance, height, link.slice(1));\n        }\n        else {\n            ctx.link(0, -height - descent, xAdvance, height, link);\n        }\n    }\n    renderAttachments(ctx, run);\n    ctx.font(font.type === 'STANDARD' ? font.fullName : font, fontSize);\n    try {\n        renderGlyphs(ctx, run.glyphs, run.positions, 0, 0);\n    }\n    catch (error) {\n        console.log(error);\n    }\n    ctx.translate(xAdvance, 0);\n};\nconst renderBackground$1 = (ctx, rect, backgroundColor) => {\n    const color = parseColor(backgroundColor);\n    ctx.save();\n    ctx.fillOpacity(color.opacity);\n    ctx.rect(rect.x, rect.y, rect.width, rect.height);\n    ctx.fill(color.value);\n    ctx.restore();\n};\nconst renderDecorationLine = (ctx, decorationLine) => {\n    ctx.save();\n    ctx.lineWidth(decorationLine.rect.height);\n    ctx.strokeOpacity(decorationLine.opacity);\n    if (/dashed/.test(decorationLine.style)) {\n        ctx.dash(3 * decorationLine.rect.height, {});\n    }\n    else if (/dotted/.test(decorationLine.style)) {\n        ctx.dash(decorationLine.rect.height, {});\n    }\n    if (/wavy/.test(decorationLine.style)) {\n        const dist = Math.max(2, decorationLine.rect.height);\n        let step = 1.1 * dist;\n        const stepCount = Math.floor(decorationLine.rect.width / (2 * step));\n        // Adjust step to fill entire width\n        const remainingWidth = decorationLine.rect.width - stepCount * 2 * step;\n        const adjustment = remainingWidth / stepCount / 2;\n        step += adjustment;\n        const cp1y = decorationLine.rect.y + dist;\n        const cp2y = decorationLine.rect.y - dist;\n        let { x } = decorationLine.rect;\n        ctx.moveTo(decorationLine.rect.x, decorationLine.rect.y);\n        for (let i = 0; i < stepCount; i += 1) {\n            ctx.bezierCurveTo(x + step, cp1y, x + step, cp2y, x + 2 * step, decorationLine.rect.y);\n            x += 2 * step;\n        }\n    }\n    else {\n        ctx.moveTo(decorationLine.rect.x, decorationLine.rect.y);\n        ctx.lineTo(decorationLine.rect.x + decorationLine.rect.width, decorationLine.rect.y);\n        if (/double/.test(decorationLine.style)) {\n            ctx.moveTo(decorationLine.rect.x, decorationLine.rect.y + decorationLine.rect.height * 2);\n            ctx.lineTo(decorationLine.rect.x + decorationLine.rect.width, decorationLine.rect.y + decorationLine.rect.height * 2);\n        }\n    }\n    ctx.stroke(decorationLine.color);\n    ctx.restore();\n};\nconst renderLine = (ctx, line) => {\n    if (!line.box)\n        return;\n    const lineAscent = line.ascent || 0;\n    ctx.save();\n    ctx.translate(line.box.x, line.box.y + lineAscent);\n    for (let i = 0; i < line.runs.length; i += 1) {\n        const run = line.runs[i];\n        const isLastRun = i === line.runs.length - 1;\n        if (run.attributes.backgroundColor) {\n            const xAdvance = run.xAdvance ?? 0;\n            const overflowRight = isLastRun ? line.overflowRight ?? 0 : 0;\n            const backgroundRect = {\n                x: 0,\n                y: -lineAscent,\n                height: line.box.height,\n                width: xAdvance - overflowRight,\n            };\n            renderBackground$1(ctx, backgroundRect, run.attributes.backgroundColor);\n        }\n        renderRun(ctx, run);\n    }\n    ctx.restore();\n    ctx.save();\n    ctx.translate(line.box.x, line.box.y);\n    if (line.decorationLines) {\n        for (let i = 0; i < line.decorationLines.length; i += 1) {\n            const decorationLine = line.decorationLines[i];\n            renderDecorationLine(ctx, decorationLine);\n        }\n    }\n    ctx.restore();\n};\nconst renderBlock = (ctx, block) => {\n    block.forEach((line) => {\n        renderLine(ctx, line);\n    });\n};\nconst renderText = (ctx, node) => {\n    if (!node.box)\n        return;\n    if (!node.lines)\n        return;\n    const { top, left } = node.box;\n    const blocks = [node.lines];\n    const paddingTop = node.box?.paddingTop || 0;\n    const paddingLeft = node.box?.paddingLeft || 0;\n    const initialY = node.lines[0] ? node.lines[0].box.y : 0;\n    const offsetX = node.alignOffset || 0;\n    ctx.save();\n    ctx.translate(left + paddingLeft - offsetX, top + paddingTop - initialY);\n    blocks.forEach((block) => {\n        renderBlock(ctx, block);\n    });\n    ctx.restore();\n};\n\nconst renderPage = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { width, height } = node.box;\n    const dpi = node.props?.dpi || 72;\n    const userUnit = dpi / 72;\n    ctx.addPage({ size: [width, height], margin: 0, userUnit });\n};\n\nconst renderNote = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { top, left } = node.box;\n    const value = node?.children?.[0].value || '';\n    const color = node.style?.backgroundColor;\n    ctx.note(left, top, 0, 0, value, { color });\n};\n\nconst embedImage = (ctx, node) => {\n    const src = node.image.data;\n    let image;\n    if (typeof src === 'string') {\n        image = ctx._imageRegistry[src];\n    }\n    if (!image) {\n        image = ctx.openImage(src);\n    }\n    if (!image.obj) {\n        image.embed(ctx);\n    }\n    return image;\n};\n\nconst isNumeric = (n) => {\n    return !Number.isNaN(parseFloat(n)) && Number.isFinite(n);\n};\nconst applyContainObjectFit = (cw, ch, iw, ih, px, py) => {\n    const cr = cw / ch;\n    const ir = iw / ih;\n    const pxp = matchPercent(px ?? null);\n    const pyp = matchPercent(py ?? null);\n    const pxv = pxp ? pxp.percent : 0.5;\n    const pyv = pyp ? pyp.percent : 0.5;\n    if (cr > ir) {\n        const height = ch;\n        const width = height * ir;\n        const yOffset = isNumeric(py) ? py : 0;\n        const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n        return { width, height, xOffset, yOffset };\n    }\n    const width = cw;\n    const height = width / ir;\n    const xOffset = isNumeric(px) ? px : 0;\n    const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n    return { width, height, yOffset, xOffset };\n};\nconst applyNoneObjectFit = (cw, ch, iw, ih, px, py) => {\n    const width = iw;\n    const height = ih;\n    const pxp = matchPercent(px ?? null);\n    const pyp = matchPercent(py ?? null);\n    const pxv = pxp ? pxp.percent : 0.5;\n    const pyv = pyp ? pyp.percent : 0.5;\n    const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n    const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n    return { width, height, xOffset, yOffset };\n};\nconst applyCoverObjectFit = (cw, ch, iw, ih, px, py) => {\n    const ir = iw / ih;\n    const cr = cw / ch;\n    const pxp = matchPercent(px ?? null);\n    const pyp = matchPercent(py ?? null);\n    const pxv = pxp ? pxp.percent : 0.5;\n    const pyv = pyp ? pyp.percent : 0.5;\n    if (cr > ir) {\n        const width = cw;\n        const height = width / ir;\n        const xOffset = isNumeric(px) ? px : 0;\n        const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n        return { width, height, yOffset, xOffset };\n    }\n    const height = ch;\n    const width = height * ir;\n    const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n    const yOffset = isNumeric(py) ? py : 0;\n    return { width, height, xOffset, yOffset };\n};\nconst applyScaleDownObjectFit = (cw, ch, iw, ih, px, py) => {\n    const containDimension = applyContainObjectFit(cw, ch, iw, ih, px, py);\n    const noneDimension = applyNoneObjectFit(cw, ch, iw, ih, px, py);\n    return containDimension.width < noneDimension.width\n        ? containDimension\n        : noneDimension;\n};\nconst applyFillObjectFit = (cw, ch, px, py) => {\n    return {\n        width: cw,\n        height: ch,\n        xOffset: matchPercent(px ?? null) ? 0 : px || 0,\n        yOffset: matchPercent(py ?? null) ? 0 : py || 0,\n    };\n};\nconst resolveObjectFit = (type = 'fill', cw, ch, iw, ih, px, py) => {\n    switch (type) {\n        case 'contain':\n            return applyContainObjectFit(cw, ch, iw, ih, px, py);\n        case 'cover':\n            return applyCoverObjectFit(cw, ch, iw, ih, px, py);\n        case 'none':\n            return applyNoneObjectFit(cw, ch, iw, ih, px, py);\n        case 'scale-down':\n            return applyScaleDownObjectFit(cw, ch, iw, ih, px, py);\n        default:\n            return applyFillObjectFit(cw, ch, px, py);\n    }\n};\n\nconst drawImage = (ctx, node, options) => {\n    if (!node.box)\n        return;\n    if (!node.image)\n        return;\n    const { left, top } = node.box;\n    const opacity = node.style?.opacity;\n    const objectFit = node.style?.objectFit;\n    const objectPositionX = node.style?.objectPositionX;\n    const objectPositionY = node.style?.objectPositionY;\n    const paddingTop = node.box.paddingTop || 0;\n    const paddingRight = node.box.paddingRight || 0;\n    const paddingBottom = node.box.paddingBottom || 0;\n    const paddingLeft = node.box.paddingLeft || 0;\n    const imageCache = options.imageCache || new Map();\n    const { width, height, xOffset, yOffset } = resolveObjectFit(objectFit, node.box.width - paddingLeft - paddingRight, node.box.height - paddingTop - paddingBottom, node.image.width, node.image.height, objectPositionX, objectPositionY);\n    if (node.image.data) {\n        if (width !== 0 && height !== 0) {\n            const cacheKey = node.image.key;\n            const image = imageCache.get(cacheKey) || embedImage(ctx, node);\n            if (cacheKey)\n                imageCache.set(cacheKey, image);\n            const imageOpacity = isNil(opacity) ? 1 : opacity;\n            ctx\n                .fillOpacity(imageOpacity)\n                .image(image, left + paddingLeft + xOffset, top + paddingTop + yOffset, {\n                width,\n                height,\n            });\n        }\n        else {\n            console.warn(`Image with src '${JSON.stringify(node.props.src || node.props.source)}' skipped due to invalid dimensions`);\n        }\n    }\n};\nconst renderImage = (ctx, node, options) => {\n    ctx.save();\n    clipNode(ctx, node);\n    drawImage(ctx, node, options);\n    ctx.restore();\n};\n\nconst CONTENT_COLOR = '#a1c6e7';\nconst PADDING_COLOR = '#c4deb9';\nconst MARGIN_COLOR = '#f8cca1';\n// TODO: Draw debug boxes using clipping to enhance quality\nconst debugContent = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { left, top, width, height, paddingLeft = 0, paddingTop = 0, paddingRight = 0, paddingBottom = 0, borderLeftWidth = 0, borderTopWidth = 0, borderRightWidth = 0, borderBottomWidth = 0, } = node.box;\n    ctx\n        .fillColor(CONTENT_COLOR)\n        .opacity(0.5)\n        .rect(left + paddingLeft + borderLeftWidth, top + paddingTop + borderTopWidth, width - paddingLeft - paddingRight - borderRightWidth - borderLeftWidth, height - paddingTop - paddingBottom - borderTopWidth - borderBottomWidth)\n        .fill();\n};\nconst debugPadding = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { left, top, width, height, paddingLeft = 0, paddingTop = 0, paddingRight = 0, paddingBottom = 0, borderLeftWidth = 0, borderTopWidth = 0, borderRightWidth = 0, borderBottomWidth = 0, } = node.box;\n    ctx.fillColor(PADDING_COLOR).opacity(0.5);\n    // Padding top\n    ctx\n        .rect(left + paddingLeft + borderLeftWidth, top + borderTopWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingTop)\n        .fill();\n    // Padding left\n    ctx\n        .rect(left + borderLeftWidth, top + borderTopWidth, paddingLeft, height - borderTopWidth - borderBottomWidth)\n        .fill();\n    // Padding right\n    ctx\n        .rect(left + width - paddingRight - borderRightWidth, top + borderTopWidth, paddingRight, height - borderTopWidth - borderBottomWidth)\n        .fill();\n    // Padding bottom\n    ctx\n        .rect(left + paddingLeft + borderLeftWidth, top + height - paddingBottom - borderBottomWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingBottom)\n        .fill();\n};\nconst debugMargin = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { left, top, width, height } = node.box;\n    const { marginLeft = 0, marginTop = 0, marginRight = 0, marginBottom = 0, } = node.box;\n    ctx.fillColor(MARGIN_COLOR).opacity(0.5);\n    // Margin top\n    ctx.rect(left, top - marginTop, width, marginTop).fill();\n    // Margin left\n    ctx\n        .rect(left - marginLeft, top - marginTop, marginLeft, height + marginTop + marginBottom)\n        .fill();\n    // Margin right\n    ctx\n        .rect(left + width, top - marginTop, marginRight, height + marginTop + marginBottom)\n        .fill();\n    // Margin bottom\n    ctx.rect(left, top + height, width, marginBottom).fill();\n};\nconst debugText = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { left, top, width, height } = node.box;\n    const { marginLeft = 0, marginTop = 0, marginRight = 0, marginBottom = 0, } = node.box;\n    const roundedWidth = Math.round(width + marginLeft + marginRight);\n    const roundedHeight = Math.round(height + marginTop + marginBottom);\n    ctx\n        .fontSize(6)\n        .opacity(1)\n        .fillColor('black')\n        .text(`${roundedWidth} x ${roundedHeight}`, left - marginLeft, Math.max(top - marginTop - 4, 1), { width: Infinity });\n};\nconst debugOrigin = (ctx, node) => {\n    if (node.origin) {\n        ctx\n            .circle(node.origin.left, node.origin.top, 3)\n            .fill('red')\n            .circle(node.origin.left, node.origin.top, 5)\n            .stroke('red');\n    }\n};\nconst renderDebug = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('debug' in node.props) || !node.props.debug)\n        return;\n    ctx.save();\n    debugContent(ctx, node);\n    debugPadding(ctx, node);\n    debugMargin(ctx, node);\n    debugText(ctx, node);\n    debugOrigin(ctx, node);\n    ctx.restore();\n};\n\nconst availableMethods = [\n    'dash',\n    'clip',\n    'save',\n    'path',\n    'fill',\n    'font',\n    'text',\n    'rect',\n    'scale',\n    'moveTo',\n    'lineTo',\n    'stroke',\n    'rotate',\n    'circle',\n    'lineCap',\n    'opacity',\n    'ellipse',\n    'polygon',\n    'restore',\n    'lineJoin',\n    'fontSize',\n    'fillColor',\n    'lineWidth',\n    'translate',\n    'miterLimit',\n    'strokeColor',\n    'fillOpacity',\n    'roundedRect',\n    'fillAndStroke',\n    'strokeOpacity',\n    'bezierCurveTo',\n    'quadraticCurveTo',\n    'linearGradient',\n    'radialGradient',\n];\nconst painter = (ctx) => {\n    const p = availableMethods.reduce((acc, prop) => ({\n        ...acc,\n        [prop]: (...args) => {\n            // @ts-expect-error ctx[prop] is a function\n            ctx[prop](...args);\n            return p;\n        },\n    }), {});\n    return p;\n};\nconst renderCanvas = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { top, left, width, height } = node.box;\n    const paddingTop = node.box.paddingTop || 0;\n    const paddingLeft = node.box.paddingLeft || 0;\n    const paddingRight = node.box.paddingRight || 0;\n    const paddingBottom = node.box.paddingBottom || 0;\n    const availableWidth = width - paddingLeft - paddingRight;\n    const availableHeight = height - paddingTop - paddingBottom;\n    if (!availableWidth || !availableHeight) {\n        console.warn('Canvas element has null width or height. Please provide valid values via the `style` prop in order to correctly render it.');\n    }\n    ctx.save().translate(left + paddingLeft, top + paddingTop);\n    if (node.props.paint) {\n        node.props.paint(painter(ctx), availableWidth, availableHeight);\n    }\n    ctx.restore();\n};\n\n// Ref: https://www.w3.org/TR/css-backgrounds-3/#borders\n// This constant is used to approximate a symmetrical arc using a cubic Bezier curve.\nconst KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst clipBorderTop = (ctx, layout, style, rtr, rtl) => {\n    const { top, left, width, height } = layout;\n    const { borderTopWidth, borderRightWidth, borderLeftWidth } = style;\n    // Clip outer top border edge\n    ctx.moveTo(left + rtl, top);\n    ctx.lineTo(left + width - rtr, top);\n    // Ellipse coefficients outer top right cap\n    const c0 = rtr * (1.0 - KAPPA);\n    // Clip outer top right cap\n    ctx.bezierCurveTo(left + width - c0, top, left + width, top + c0, left + width, top + rtr);\n    // Move down in case the margin exceedes the radius\n    const topRightYCoord = top + Math.max(borderTopWidth, rtr);\n    ctx.lineTo(left + width, topRightYCoord);\n    // Clip inner top right cap\n    ctx.lineTo(left + width - borderRightWidth, topRightYCoord);\n    // Ellipse coefficients inner top right cap\n    const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n    const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n    const c1 = innerTopRightRadiusX * (1.0 - KAPPA);\n    const c2 = innerTopRightRadiusY * (1.0 - KAPPA);\n    // Clip inner top right cap\n    ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c2, left + width - borderRightWidth - c1, top + borderTopWidth, left + width - borderRightWidth - innerTopRightRadiusX, top + borderTopWidth);\n    // Clip inner top border edge\n    ctx.lineTo(left + Math.max(rtl, borderLeftWidth), top + borderTopWidth);\n    // Ellipse coefficients inner top left cap\n    const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n    const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n    const c3 = innerTopLeftRadiusX * (1.0 - KAPPA);\n    const c4 = innerTopLeftRadiusY * (1.0 - KAPPA);\n    const topLeftYCoord = top + Math.max(borderTopWidth, rtl);\n    // Clip inner top left cap\n    ctx.bezierCurveTo(left + borderLeftWidth + c3, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c4, left + borderLeftWidth, topLeftYCoord);\n    ctx.lineTo(left, topLeftYCoord);\n    // Move down in case the margin exceedes the radius\n    ctx.lineTo(left, top + rtl);\n    // Ellipse coefficients outer top left cap\n    const c5 = rtl * (1.0 - KAPPA);\n    // Clip outer top left cap\n    ctx.bezierCurveTo(left, top + c5, left + c5, top, left + rtl, top);\n    ctx.closePath();\n    ctx.clip();\n    // Clip border top cap joins\n    if (borderRightWidth) {\n        const trSlope = -borderTopWidth / borderRightWidth;\n        ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n        ctx.lineTo(left + width, top);\n        ctx.lineTo(left, top);\n        ctx.lineTo(left, top + height);\n        ctx.closePath();\n        ctx.clip();\n    }\n    if (borderLeftWidth) {\n        const trSlope = -borderTopWidth / borderLeftWidth;\n        ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n        ctx.lineTo(left, top);\n        ctx.lineTo(left + width, top);\n        ctx.lineTo(left + width, top + height);\n        ctx.closePath();\n        ctx.clip();\n    }\n};\nconst fillBorderTop = (ctx, layout, style, rtr, rtl) => {\n    const { top, left, width } = layout;\n    const { borderTopColor, borderTopWidth, borderTopStyle, borderRightWidth, borderLeftWidth, } = style;\n    const c0 = rtl * (1.0 - KAPPA);\n    const c1 = rtr * (1.0 - KAPPA);\n    ctx.moveTo(left, top + Math.max(rtl, borderTopWidth));\n    ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);\n    ctx.lineTo(left + width - rtr, top);\n    ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);\n    ctx.strokeColor(borderTopColor);\n    ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderLeftWidth) * 2);\n    if (borderTopStyle === 'dashed') {\n        ctx.dash(borderTopWidth * 2, { space: borderTopWidth * 1.2 });\n    }\n    else if (borderTopStyle === 'dotted') {\n        ctx.dash(borderTopWidth, { space: borderTopWidth * 1.2 });\n    }\n    ctx.stroke();\n    ctx.undash();\n};\nconst clipBorderRight = (ctx, layout, style, rtr, rbr) => {\n    const { top, left, width, height } = layout;\n    const { borderTopWidth, borderRightWidth, borderBottomWidth } = style;\n    // Clip outer right border edge\n    ctx.moveTo(left + width, top + rtr);\n    ctx.lineTo(left + width, top + height - rbr);\n    // Ellipse coefficients outer bottom right cap\n    const c0 = rbr * (1.0 - KAPPA);\n    // Clip outer top right cap\n    ctx.bezierCurveTo(left + width, top + height - c0, left + width - c0, top + height, left + width - rbr, top + height);\n    // Move left in case the margin exceedes the radius\n    const topBottomXCoord = left + width - Math.max(borderRightWidth, rbr);\n    ctx.lineTo(topBottomXCoord, top + height);\n    // Clip inner bottom right cap\n    ctx.lineTo(topBottomXCoord, top + height - borderBottomWidth);\n    // Ellipse coefficients inner bottom right cap\n    const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n    const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n    const c1 = innerBottomRightRadiusX * (1.0 - KAPPA);\n    const c2 = innerBottomRightRadiusY * (1.0 - KAPPA);\n    // Clip inner top right cap\n    ctx.bezierCurveTo(left + width - borderRightWidth - c1, top + height - borderBottomWidth, left + width - borderRightWidth, top + height - borderBottomWidth - c2, left + width - borderRightWidth, top + height - Math.max(rbr, borderBottomWidth));\n    // Clip inner right border edge\n    ctx.lineTo(left + width - borderRightWidth, top + Math.max(rtr, borderTopWidth));\n    // Ellipse coefficients inner top right cap\n    const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n    const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n    const c3 = innerTopRightRadiusX * (1.0 - KAPPA);\n    const c4 = innerTopRightRadiusY * (1.0 - KAPPA);\n    const topRightXCoord = left + width - Math.max(rtr, borderRightWidth);\n    // Clip inner top left cap\n    ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c4, left + width - borderRightWidth - c3, top + borderTopWidth, topRightXCoord, top + borderTopWidth);\n    ctx.lineTo(topRightXCoord, top);\n    // Move right in case the margin exceedes the radius\n    ctx.lineTo(left + width - rtr, top);\n    // Ellipse coefficients outer top right cap\n    const c5 = rtr * (1.0 - KAPPA);\n    // Clip outer top right cap\n    ctx.bezierCurveTo(left + width - c5, top, left + width, top + c5, left + width, top + rtr);\n    ctx.closePath();\n    ctx.clip();\n    // Clip border right cap joins\n    if (borderTopWidth) {\n        const trSlope = -borderTopWidth / borderRightWidth;\n        ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n        ctx.lineTo(left + width, top);\n        ctx.lineTo(left + width, top + height);\n        ctx.lineTo(left, top + height);\n        ctx.closePath();\n        ctx.clip();\n    }\n    if (borderBottomWidth) {\n        const brSlope = borderBottomWidth / borderRightWidth;\n        ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n        ctx.lineTo(left + width, top + height);\n        ctx.lineTo(left + width, top);\n        ctx.lineTo(left, top);\n        ctx.closePath();\n        ctx.clip();\n    }\n};\nconst fillBorderRight = (ctx, layout, style, rtr, rbr) => {\n    const { top, left, width, height } = layout;\n    const { borderRightColor, borderRightStyle, borderRightWidth, borderTopWidth, borderBottomWidth, } = style;\n    const c0 = rbr * (1.0 - KAPPA);\n    const c1 = rtr * (1.0 - KAPPA);\n    ctx.moveTo(left + width - rtr, top);\n    ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);\n    ctx.lineTo(left + width, top + height - rbr);\n    ctx.bezierCurveTo(left + width, top + height - c0, left + width - c0, top + height, left + width - rbr, top + height);\n    ctx.strokeColor(borderRightColor);\n    ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderBottomWidth) * 2);\n    if (borderRightStyle === 'dashed') {\n        ctx.dash(borderRightWidth * 2, { space: borderRightWidth * 1.2 });\n    }\n    else if (borderRightStyle === 'dotted') {\n        ctx.dash(borderRightWidth, { space: borderRightWidth * 1.2 });\n    }\n    ctx.stroke();\n    ctx.undash();\n};\nconst clipBorderBottom = (ctx, layout, style, rbl, rbr) => {\n    const { top, left, width, height } = layout;\n    const { borderBottomWidth, borderRightWidth, borderLeftWidth } = style;\n    // Clip outer top border edge\n    ctx.moveTo(left + width - rbr, top + height);\n    ctx.lineTo(left + rbl, top + height);\n    // Ellipse coefficients outer top right cap\n    const c0 = rbl * (1.0 - KAPPA);\n    // Clip outer top right cap\n    ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n    // Move up in case the margin exceedes the radius\n    const bottomLeftYCoord = top + height - Math.max(borderBottomWidth, rbl);\n    ctx.lineTo(left, bottomLeftYCoord);\n    // Clip inner bottom left cap\n    ctx.lineTo(left + borderLeftWidth, bottomLeftYCoord);\n    // Ellipse coefficients inner top right cap\n    const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n    const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n    const c1 = innerBottomLeftRadiusX * (1.0 - KAPPA);\n    const c2 = innerBottomLeftRadiusY * (1.0 - KAPPA);\n    // Clip inner bottom left cap\n    ctx.bezierCurveTo(left + borderLeftWidth, top + height - borderBottomWidth - c2, left + borderLeftWidth + c1, top + height - borderBottomWidth, left + borderLeftWidth + innerBottomLeftRadiusX, top + height - borderBottomWidth);\n    // Clip inner bottom border edge\n    ctx.lineTo(left + width - Math.max(rbr, borderRightWidth), top + height - borderBottomWidth);\n    // Ellipse coefficients inner top left cap\n    const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n    const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n    const c3 = innerBottomRightRadiusX * (1.0 - KAPPA);\n    const c4 = innerBottomRightRadiusY * (1.0 - KAPPA);\n    const bottomRightYCoord = top + height - Math.max(borderBottomWidth, rbr);\n    // Clip inner top left cap\n    ctx.bezierCurveTo(left + width - borderRightWidth - c3, top + height - borderBottomWidth, left + width - borderRightWidth, top + height - borderBottomWidth - c4, left + width - borderRightWidth, bottomRightYCoord);\n    ctx.lineTo(left + width, bottomRightYCoord);\n    // Move down in case the margin exceedes the radius\n    ctx.lineTo(left + width, top + height - rbr);\n    // Ellipse coefficients outer top left cap\n    const c5 = rbr * (1.0 - KAPPA);\n    // Clip outer top left cap\n    ctx.bezierCurveTo(left + width, top + height - c5, left + width - c5, top + height, left + width - rbr, top + height);\n    ctx.closePath();\n    ctx.clip();\n    // Clip border bottom cap joins\n    if (borderRightWidth) {\n        const brSlope = borderBottomWidth / borderRightWidth;\n        ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n        ctx.lineTo(left + width, top + height);\n        ctx.lineTo(left, top + height);\n        ctx.lineTo(left, top);\n        ctx.closePath();\n        ctx.clip();\n    }\n    if (borderLeftWidth) {\n        const trSlope = -borderBottomWidth / borderLeftWidth;\n        ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n        ctx.lineTo(left, top + height);\n        ctx.lineTo(left + width, top + height);\n        ctx.lineTo(left + width, top);\n        ctx.closePath();\n        ctx.clip();\n    }\n};\nconst fillBorderBottom = (ctx, layout, style, rbl, rbr) => {\n    const { top, left, width, height } = layout;\n    const { borderBottomColor, borderBottomStyle, borderBottomWidth, borderRightWidth, borderLeftWidth, } = style;\n    const c0 = rbl * (1.0 - KAPPA);\n    const c1 = rbr * (1.0 - KAPPA);\n    ctx.moveTo(left + width, top + height - rbr);\n    ctx.bezierCurveTo(left + width, top + height - c1, left + width - c1, top + height, left + width - rbr, top + height);\n    ctx.lineTo(left + rbl, top + height);\n    ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n    ctx.strokeColor(borderBottomColor);\n    ctx.lineWidth(Math.max(borderBottomWidth, borderRightWidth, borderLeftWidth) * 2);\n    if (borderBottomStyle === 'dashed') {\n        ctx.dash(borderBottomWidth * 2, { space: borderBottomWidth * 1.2 });\n    }\n    else if (borderBottomStyle === 'dotted') {\n        ctx.dash(borderBottomWidth, { space: borderBottomWidth * 1.2 });\n    }\n    ctx.stroke();\n    ctx.undash();\n};\nconst clipBorderLeft = (ctx, layout, style, rbl, rtl) => {\n    const { top, left, width, height } = layout;\n    const { borderTopWidth, borderLeftWidth, borderBottomWidth } = style;\n    // Clip outer left border edge\n    ctx.moveTo(left, top + height - rbl);\n    ctx.lineTo(left, top + rtl);\n    // Ellipse coefficients outer top left cap\n    const c0 = rtl * (1.0 - KAPPA);\n    // Clip outer top left cap\n    ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);\n    // Move right in case the margin exceedes the radius\n    const topLeftCoordX = left + Math.max(borderLeftWidth, rtl);\n    ctx.lineTo(topLeftCoordX, top);\n    // Clip inner top left cap\n    ctx.lineTo(topLeftCoordX, top + borderTopWidth);\n    // Ellipse coefficients inner top left cap\n    const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n    const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n    const c1 = innerTopLeftRadiusX * (1.0 - KAPPA);\n    const c2 = innerTopLeftRadiusY * (1.0 - KAPPA);\n    // Clip inner top right cap\n    ctx.bezierCurveTo(left + borderLeftWidth + c1, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c2, left + borderLeftWidth, top + Math.max(rtl, borderTopWidth));\n    // Clip inner left border edge\n    ctx.lineTo(left + borderLeftWidth, top + height - Math.max(rbl, borderBottomWidth));\n    // Ellipse coefficients inner bottom left cap\n    const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n    const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n    const c3 = innerBottomLeftRadiusX * (1.0 - KAPPA);\n    const c4 = innerBottomLeftRadiusY * (1.0 - KAPPA);\n    const bottomLeftXCoord = left + Math.max(rbl, borderLeftWidth);\n    // Clip inner top left cap\n    ctx.bezierCurveTo(left + borderLeftWidth, top + height - borderBottomWidth - c4, left + borderLeftWidth + c3, top + height - borderBottomWidth, bottomLeftXCoord, top + height - borderBottomWidth);\n    ctx.lineTo(bottomLeftXCoord, top + height);\n    // Move left in case the margin exceedes the radius\n    ctx.lineTo(left + rbl, top + height);\n    // Ellipse coefficients outer top right cap\n    const c5 = rbl * (1.0 - KAPPA);\n    // Clip outer top right cap\n    ctx.bezierCurveTo(left + c5, top + height, left, top + height - c5, left, top + height - rbl);\n    ctx.closePath();\n    ctx.clip();\n    // Clip border right cap joins\n    if (borderBottomWidth) {\n        const trSlope = -borderBottomWidth / borderLeftWidth;\n        ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n        ctx.lineTo(left, top + height);\n        ctx.lineTo(left, top);\n        ctx.lineTo(left + width, top);\n        ctx.closePath();\n        ctx.clip();\n    }\n    if (borderBottomWidth) {\n        const trSlope = -borderTopWidth / borderLeftWidth;\n        ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n        ctx.lineTo(left, top);\n        ctx.lineTo(left, top + height);\n        ctx.lineTo(left + width, top + height);\n        ctx.closePath();\n        ctx.clip();\n    }\n};\nconst fillBorderLeft = (ctx, layout, style, rbl, rtl) => {\n    const { top, left, height } = layout;\n    const { borderLeftColor, borderLeftStyle, borderLeftWidth, borderTopWidth, borderBottomWidth, } = style;\n    const c0 = rbl * (1.0 - KAPPA);\n    const c1 = rtl * (1.0 - KAPPA);\n    ctx.moveTo(left + rbl, top + height);\n    ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n    ctx.lineTo(left, top + rtl);\n    ctx.bezierCurveTo(left, top + c1, left + c1, top, left + rtl, top);\n    ctx.strokeColor(borderLeftColor);\n    ctx.lineWidth(Math.max(borderLeftWidth, borderTopWidth, borderBottomWidth) * 2);\n    if (borderLeftStyle === 'dashed') {\n        ctx.dash(borderLeftWidth * 2, { space: borderLeftWidth * 1.2 });\n    }\n    else if (borderLeftStyle === 'dotted') {\n        ctx.dash(borderLeftWidth, { space: borderLeftWidth * 1.2 });\n    }\n    ctx.stroke();\n    ctx.undash();\n};\nconst shouldRenderBorders = (node) => node.box &&\n    (node.box.borderTopWidth ||\n        node.box.borderRightWidth ||\n        node.box.borderBottomWidth ||\n        node.box.borderLeftWidth);\nconst renderBorders = (ctx, node) => {\n    if (!node.box)\n        return;\n    if (!shouldRenderBorders(node))\n        return;\n    const { width, height, borderTopWidth = 0, borderLeftWidth = 0, borderRightWidth = 0, borderBottomWidth = 0, } = node.box;\n    const { opacity = 1, borderTopColor = 'black', borderTopStyle = 'solid', borderLeftColor = 'black', borderLeftStyle = 'solid', borderRightColor = 'black', borderRightStyle = 'solid', borderBottomColor = 'black', borderBottomStyle = 'solid', } = node.style;\n    // @ts-expect-error this is always a number due to resolve border radius step\n    const borderTopLeftRadius = node.style.borderTopLeftRadius || 0;\n    // @ts-expect-error this is always a number due to resolve border radius step\n    const borderTopRightRadius = node.style.borderTopRightRadius || 0;\n    // @ts-expect-error this is always a number due to resolve border radius step\n    const borderBottomLeftRadius = node.style.borderBottomLeftRadius || 0;\n    // @ts-expect-error this is always a number due to resolve border radius step\n    const borderBottomRightRadius = node.style.borderBottomRightRadius || 0;\n    const style = {\n        borderTopColor,\n        borderTopWidth,\n        borderTopStyle,\n        borderLeftColor,\n        borderLeftWidth,\n        borderLeftStyle,\n        borderRightColor,\n        borderRightWidth,\n        borderRightStyle,\n        borderBottomColor,\n        borderBottomWidth,\n        borderBottomStyle};\n    const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n    const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n    const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n    const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n    ctx.save();\n    ctx.strokeOpacity(opacity);\n    if (borderTopWidth) {\n        ctx.save();\n        clipBorderTop(ctx, node.box, style, rtr, rtl);\n        fillBorderTop(ctx, node.box, style, rtr, rtl);\n        ctx.restore();\n    }\n    if (borderRightWidth) {\n        ctx.save();\n        clipBorderRight(ctx, node.box, style, rtr, rbr);\n        fillBorderRight(ctx, node.box, style, rtr, rbr);\n        ctx.restore();\n    }\n    if (borderBottomWidth) {\n        ctx.save();\n        clipBorderBottom(ctx, node.box, style, rbl, rbr);\n        fillBorderBottom(ctx, node.box, style, rbl, rbr);\n        ctx.restore();\n    }\n    if (borderLeftWidth) {\n        ctx.save();\n        clipBorderLeft(ctx, node.box, style, rbl, rtl);\n        fillBorderLeft(ctx, node.box, style, rbl, rtl);\n        ctx.restore();\n    }\n    ctx.restore();\n};\n\nconst drawBackground = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { top, left, width, height } = node.box;\n    const color = parseColor(node.style.backgroundColor);\n    const nodeOpacity = isNil(node.style?.opacity) ? 1 : node.style.opacity;\n    const opacity = Math.min(color.opacity, nodeOpacity);\n    ctx\n        .fillOpacity(opacity)\n        .fillColor(color.value)\n        .rect(left, top, width, height)\n        .fill();\n};\nconst renderBackground = (ctx, node) => {\n    const hasBackground = !!node.box && !!node.style?.backgroundColor;\n    if (hasBackground) {\n        ctx.save();\n        clipNode(ctx, node);\n        drawBackground(ctx, node);\n        ctx.restore();\n    }\n};\n\nconst isString = (value) => typeof value === 'string';\nconst isSrcId = (value) => /^#.+/.test(value);\nconst renderLink = (ctx, node, src) => {\n    if (!src || !node.box)\n        return;\n    const isId = isSrcId(src);\n    const method = isId ? 'goTo' : 'link';\n    const value = isId ? src.slice(1) : src;\n    const { top, left, width, height } = node.box;\n    ctx[method](left, top, width, height, value);\n};\nconst setLink = (ctx, node) => {\n    const props = node.props || {};\n    if ('src' in props && isString(props.src))\n        return renderLink(ctx, node, props.src);\n    if ('href' in props && isString(props.href))\n        return renderLink(ctx, node, props.href);\n};\n\nconst setDestination = (ctx, node) => {\n    if (!node.box)\n        return;\n    if (!node.props)\n        return;\n    if ('id' in node.props) {\n        ctx.addNamedDestination(node.props.id, 'XYZ', null, node.box.top, null);\n    }\n};\n\nconst clean = (options) => {\n    const opt = { ...options };\n    // We need to ensure the elements are no present if not true\n    Object.entries(opt).forEach((pair) => {\n        if (!pair[1]) {\n            delete opt[pair[0]];\n        }\n    });\n    return opt;\n};\nconst parseCommonFormOptions = (node) => {\n    // Common Options\n    return {\n        required: node.props?.required || false,\n        noExport: node.props?.noExport || false,\n        readOnly: node.props?.readOnly || false,\n        value: node.props?.value || undefined,\n        defaultValue: node.props?.defaultValue || undefined,\n    };\n};\nconst parseTextInputOptions = (node, fieldSet) => {\n    return clean({\n        ...parseCommonFormOptions(node),\n        parent: fieldSet || undefined,\n        align: node.props?.align || 'left',\n        multiline: node.props?.multiline || undefined,\n        password: node.props?.password || false,\n        noSpell: node.props?.noSpell || false,\n        format: node.props?.format || undefined,\n        fontSize: node.props?.fontSize || undefined,\n        MaxLen: node.props?.maxLength || undefined,\n    });\n};\nconst parseSelectAndListFieldOptions = (node) => {\n    return clean({\n        ...parseCommonFormOptions(node),\n        sort: node.props?.sort || false,\n        edit: node.props?.edit || false,\n        multiSelect: node.props?.multiSelect || false,\n        noSpell: node.props?.noSpell || false,\n        select: node.props?.select || [''],\n    });\n};\nconst getAppearance = (ctx, codepoint, width, height) => {\n    const appearance = ctx.ref({\n        Type: 'XObject',\n        Subtype: 'Form',\n        BBox: [0, 0, width, height],\n        Resources: {\n            ProcSet: ['PDF', 'Text', 'ImageB', 'ImageC', 'ImageI'],\n            Font: {\n                ZaDi: ctx._acroform.fonts.ZaDi,\n            },\n        },\n    });\n    appearance.initDeflate();\n    appearance.write(`/Tx BMC\\nq\\n/ZaDi ${height * 0.8} Tf\\nBT\\n${width * 0.45} ${height / 4} Td (${codepoint}) Tj\\nET\\nQ\\nEMC`);\n    appearance.end(null);\n    return appearance;\n};\nconst parseCheckboxOptions = (ctx, node, fieldSet) => {\n    const { width, height } = node.box || {};\n    const onOption = node.props?.onState || 'Yes';\n    const offOption = node.props?.offState || 'Off';\n    const xMark = node.props?.xMark || false;\n    if (!Object.prototype.hasOwnProperty.call(ctx._acroform.fonts, 'ZaDi')) {\n        const ref = ctx.ref({\n            Type: 'Font',\n            Subtype: 'Type1',\n            BaseFont: 'ZapfDingbats',\n        });\n        ctx._acroform.fonts.ZaDi = ref;\n        ref.end(null);\n    }\n    const normalAppearance = {\n        [onOption]: getAppearance(ctx, xMark ? '8' : '4', width, height),\n        [offOption]: getAppearance(ctx, xMark ? ' ' : '8', width, height),\n    };\n    return clean({\n        ...parseCommonFormOptions(node),\n        backgroundColor: node.props?.backgroundColor || undefined,\n        borderColor: node.props?.borderColor || undefined,\n        parent: fieldSet || undefined,\n        value: `/${node.props?.checked === true ? onOption : offOption}`,\n        defaultValue: `/${node.props?.checked === true ? onOption : offOption}`,\n        AS: node.props?.checked === true ? onOption : offOption,\n        AP: { N: normalAppearance, D: normalAppearance },\n    });\n};\n\nconst renderTextInput = (ctx, node, options) => {\n    if (!node.box)\n        return;\n    const { top, left, width, height } = node.box;\n    // Element's name\n    const name = node.props?.name || '';\n    const fieldSetOptions = options.fieldSets?.at(0);\n    if (!ctx._root.data.AcroForm) {\n        ctx.initForm();\n    }\n    ctx.formText(name, left, top, width, height, parseTextInputOptions(node, fieldSetOptions));\n};\n\nconst renderSelect = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { top, left, width, height } = node.box;\n    // Element's name\n    const name = node.props?.name || '';\n    if (!ctx._root.data.AcroForm) {\n        ctx.initForm();\n    }\n    ctx.formCombo(name, left, top, width, height, parseSelectAndListFieldOptions(node));\n};\n\nconst renderFieldSet = (ctx, node, options) => {\n    const name = node.props?.name || '';\n    if (!ctx._root.data.AcroForm) {\n        ctx.initForm();\n    }\n    const formField = ctx.formField(name);\n    const option = options;\n    if (!option.fieldSets) {\n        option.fieldSets = [formField];\n    }\n    else {\n        option.fieldSets.push(formField);\n    }\n};\nconst cleanUpFieldSet = (_ctx, _node, options) => {\n    options.fieldSets.pop();\n};\n\nconst renderList = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { top, left, width, height } = node.box || {};\n    // Element's name\n    const name = ('name' in node.props ? node.props.name || '' : '');\n    if (!ctx._root.data.AcroForm) {\n        ctx.initForm();\n    }\n    ctx.formList(name, left, top, width, height, parseSelectAndListFieldOptions(node));\n};\n\nconst renderCheckbox = (ctx, node, options) => {\n    if (!node.box)\n        return;\n    const { top, left, width, height } = node.box;\n    // Element's name\n    const name = node.props?.name || '';\n    const fieldSetOptions = options.fieldSets?.at(0);\n    if (!ctx._root.data.AcroForm) {\n        ctx.initForm();\n    }\n    ctx.formCheckbox(name, left, top, width, height, parseCheckboxOptions(ctx, node, fieldSetOptions));\n};\n\nconst isRecursiveNode = (node) => node.type !== P.Text && node.type !== P.Svg;\nconst renderChildren = (ctx, node, options) => {\n    ctx.save();\n    if (node.box) {\n        ctx.translate(node.box.left, node.box.top);\n    }\n    const children = node.children || [];\n    const renderChild = (child) => renderNode(ctx, child, options);\n    children.forEach(renderChild);\n    ctx.restore();\n};\nconst renderFns = {\n    [P.Text]: renderText,\n    [P.Note]: renderNote,\n    [P.Image]: renderImage,\n    [P.FieldSet]: renderFieldSet,\n    [P.TextInput]: renderTextInput,\n    [P.Select]: renderSelect,\n    [P.Checkbox]: renderCheckbox,\n    [P.List]: renderList,\n    [P.Canvas]: renderCanvas,\n    [P.Svg]: renderSvg,\n    [P.Link]: setLink,\n};\nconst cleanUpFns = {\n    [P.FieldSet]: cleanUpFieldSet,\n};\nconst renderNode = (ctx, node, options) => {\n    const overflowHidden = node.style?.overflow === 'hidden';\n    const shouldRenderChildren = isRecursiveNode(node);\n    if (node.type === P.Page)\n        renderPage(ctx, node);\n    ctx.save();\n    if (overflowHidden)\n        clipNode(ctx, node);\n    applyTransformations(ctx, node);\n    renderBackground(ctx, node);\n    renderBorders(ctx, node);\n    const renderFn = renderFns[node.type];\n    if (renderFn)\n        renderFn(ctx, node, options);\n    if (shouldRenderChildren)\n        renderChildren(ctx, node, options);\n    const cleanUpFn = cleanUpFns[node.type];\n    if (cleanUpFn)\n        cleanUpFn(ctx, node, options);\n    setDestination(ctx, node);\n    renderDebug(ctx, node);\n    ctx.restore();\n};\n\nconst addNodeBookmark = (ctx, node, pageNumber, registry) => {\n    if (!node.box)\n        return;\n    if (!node.props)\n        return;\n    if ('bookmark' in node.props && node.props.bookmark) {\n        const bookmark = node.props.bookmark;\n        const { title, parent, expanded, zoom, fit } = bookmark;\n        const outline = registry[parent] || ctx.outline;\n        const top = bookmark.top || node.box.top;\n        const left = bookmark.left || node.box.left;\n        const instance = outline.addItem(title, {\n            pageNumber,\n            expanded,\n            top,\n            left,\n            zoom,\n            fit,\n        });\n        registry[bookmark.ref] = instance;\n    }\n    if (!node.children)\n        return;\n    node.children.forEach((child) => addNodeBookmark(ctx, child, pageNumber, registry));\n};\nconst addBookmarks = (ctx, root) => {\n    const registry = {};\n    const pages = root.children || [];\n    pages.forEach((page, i) => {\n        addNodeBookmark(ctx, page, i, registry);\n    });\n};\n\nconst render = (ctx, doc) => {\n    const pages = doc.children || [];\n    const options = { imageCache: new Map(), fieldSets: [] };\n    pages.forEach((page) => renderNode(ctx, page, options));\n    addBookmarks(ctx, doc);\n    ctx.end();\n    return ctx;\n};\n\nexport { render as default };\n"]},"metadata":{},"sourceType":"module"}