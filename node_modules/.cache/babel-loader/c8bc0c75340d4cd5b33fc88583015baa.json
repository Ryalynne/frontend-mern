{"ast":null,"code":"import _classCallCheck from \"C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport * as utils from './utils.js';\nimport { Base } from './Base.js';\nexport var Pointer = /*#__PURE__*/function (_Base) {\n  _inherits(Pointer, _Base);\n\n  var _super = _createSuper(Pointer);\n\n  function Pointer(offsetType, type) {\n    var _this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, Pointer);\n\n    _this = _super.call(this);\n    _this.offsetType = offsetType;\n    _this.type = type;\n    _this.options = options;\n\n    if (_this.type === 'void') {\n      _this.type = null;\n    }\n\n    if (_this.options.type == null) {\n      _this.options.type = 'local';\n    }\n\n    if (_this.options.allowNull == null) {\n      _this.options.allowNull = true;\n    }\n\n    if (_this.options.nullValue == null) {\n      _this.options.nullValue = 0;\n    }\n\n    if (_this.options.lazy == null) {\n      _this.options.lazy = false;\n    }\n\n    if (_this.options.relativeTo) {\n      if (typeof _this.options.relativeTo !== 'function') {\n        throw new Error('relativeTo option must be a function');\n      }\n\n      _this.relativeToGetter = options.relativeTo;\n    }\n\n    return _this;\n  }\n\n  _createClass(Pointer, [{\n    key: \"decode\",\n    value: function decode(stream, ctx) {\n      var _this2 = this;\n\n      var offset = this.offsetType.decode(stream, ctx); // handle NULL pointers\n\n      if (offset === this.options.nullValue && this.options.allowNull) {\n        return null;\n      }\n\n      var relative;\n\n      switch (this.options.type) {\n        case 'local':\n          relative = ctx._startOffset;\n          break;\n\n        case 'immediate':\n          relative = stream.pos - this.offsetType.size();\n          break;\n\n        case 'parent':\n          relative = ctx.parent._startOffset;\n          break;\n\n        default:\n          var c = ctx;\n\n          while (c.parent) {\n            c = c.parent;\n          }\n\n          relative = c._startOffset || 0;\n      }\n\n      if (this.options.relativeTo) {\n        relative += this.relativeToGetter(ctx);\n      }\n\n      var ptr = offset + relative;\n\n      if (this.type != null) {\n        var val = null;\n\n        var decodeValue = function decodeValue() {\n          if (val != null) {\n            return val;\n          }\n\n          var pos = stream.pos;\n          stream.pos = ptr;\n          val = _this2.type.decode(stream, ctx);\n          stream.pos = pos;\n          return val;\n        }; // If this is a lazy pointer, define a getter to decode only when needed.\n        // This obviously only works when the pointer is contained by a Struct.\n\n\n        if (this.options.lazy) {\n          return new utils.PropertyDescriptor({\n            get: decodeValue\n          });\n        }\n\n        return decodeValue();\n      } else {\n        return ptr;\n      }\n    }\n  }, {\n    key: \"size\",\n    value: function size(val, ctx) {\n      var parent = ctx;\n\n      switch (this.options.type) {\n        case 'local':\n        case 'immediate':\n          break;\n\n        case 'parent':\n          ctx = ctx.parent;\n          break;\n\n        default:\n          // global\n          while (ctx.parent) {\n            ctx = ctx.parent;\n          }\n\n      }\n\n      var type = this.type;\n\n      if (type == null) {\n        if (!(val instanceof VoidPointer)) {\n          throw new Error(\"Must be a VoidPointer\");\n        }\n\n        var _val = val;\n        type = _val.type;\n        val = val.value;\n      }\n\n      if (val && ctx) {\n        // Must be written as two separate lines rather than += in case `type.size` mutates ctx.pointerSize.\n        var size = type.size(val, parent);\n        ctx.pointerSize += size;\n      }\n\n      return this.offsetType.size();\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(stream, val, ctx) {\n      var relative;\n      var parent = ctx;\n\n      if (val == null) {\n        this.offsetType.encode(stream, this.options.nullValue);\n        return;\n      }\n\n      switch (this.options.type) {\n        case 'local':\n          relative = ctx.startOffset;\n          break;\n\n        case 'immediate':\n          relative = stream.pos + this.offsetType.size(val, parent);\n          break;\n\n        case 'parent':\n          ctx = ctx.parent;\n          relative = ctx.startOffset;\n          break;\n\n        default:\n          // global\n          relative = 0;\n\n          while (ctx.parent) {\n            ctx = ctx.parent;\n          }\n\n      }\n\n      if (this.options.relativeTo) {\n        relative += this.relativeToGetter(parent.val);\n      }\n\n      this.offsetType.encode(stream, ctx.pointerOffset - relative);\n      var type = this.type;\n\n      if (type == null) {\n        if (!(val instanceof VoidPointer)) {\n          throw new Error(\"Must be a VoidPointer\");\n        }\n\n        var _val2 = val;\n        type = _val2.type;\n        val = val.value;\n      }\n\n      ctx.pointers.push({\n        type: type,\n        val: val,\n        parent: parent\n      });\n      return ctx.pointerOffset += type.size(val, parent);\n    }\n  }]);\n\n  return Pointer;\n}(Base); // A pointer whose type is determined at decode time\n\nexport var VoidPointer = /*#__PURE__*/_createClass(function VoidPointer(type, value) {\n  _classCallCheck(this, VoidPointer);\n\n  this.type = type;\n  this.value = value;\n});","map":{"version":3,"sources":["C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/restructure/src/Pointer.js"],"names":["utils","Base","Pointer","offsetType","type","options","allowNull","nullValue","lazy","relativeTo","Error","relativeToGetter","stream","ctx","offset","decode","relative","_startOffset","pos","size","parent","c","ptr","val","decodeValue","PropertyDescriptor","get","VoidPointer","value","pointerSize","encode","startOffset","pointerOffset","pointers","push"],"mappings":"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","sourcesContent":["import * as utils from './utils.js';\nimport {Base} from './Base.js';\n\nexport class Pointer extends Base {\n  constructor(offsetType, type, options = {}) {\n    super();\n    this.offsetType = offsetType;\n    this.type = type;\n    this.options = options;\n    if (this.type === 'void') { this.type = null; }\n    if (this.options.type == null) { this.options.type = 'local'; }\n    if (this.options.allowNull == null) { this.options.allowNull = true; }\n    if (this.options.nullValue == null) { this.options.nullValue = 0; }\n    if (this.options.lazy == null) { this.options.lazy = false; }\n    if (this.options.relativeTo) {\n      if (typeof this.options.relativeTo !== 'function') {\n        throw new Error('relativeTo option must be a function');\n      }\n      this.relativeToGetter = options.relativeTo;\n    }\n  }\n\n  decode(stream, ctx) {\n    const offset = this.offsetType.decode(stream, ctx);\n\n    // handle NULL pointers\n    if ((offset === this.options.nullValue) && this.options.allowNull) {\n      return null;\n    }\n\n    let relative;\n    switch (this.options.type) {\n      case 'local':     relative = ctx._startOffset; break;\n      case 'immediate': relative = stream.pos - this.offsetType.size(); break;\n      case 'parent':    relative = ctx.parent._startOffset; break;\n      default:\n        var c = ctx;\n        while (c.parent) {\n          c = c.parent;\n        }\n\n        relative = c._startOffset || 0;\n    }\n\n    if (this.options.relativeTo) {\n      relative += this.relativeToGetter(ctx);\n    }\n\n    const ptr = offset + relative;\n\n    if (this.type != null) {\n      let val = null;\n      const decodeValue = () => {\n        if (val != null) { return val; }\n\n        const { pos } = stream;\n        stream.pos = ptr;\n        val = this.type.decode(stream, ctx);\n        stream.pos = pos;\n        return val;\n      };\n\n      // If this is a lazy pointer, define a getter to decode only when needed.\n      // This obviously only works when the pointer is contained by a Struct.\n      if (this.options.lazy) {\n        return new utils.PropertyDescriptor({\n          get: decodeValue});\n      }\n\n      return decodeValue();\n    } else {\n      return ptr;\n    }\n  }\n\n  size(val, ctx) {\n    const parent = ctx;\n    switch (this.options.type) {\n      case 'local': case 'immediate':\n        break;\n      case 'parent':\n        ctx = ctx.parent;\n        break;\n      default: // global\n        while (ctx.parent) {\n          ctx = ctx.parent;\n        }\n    }\n\n    let { type } = this;\n    if (type == null) {\n      if (!(val instanceof VoidPointer)) {\n        throw new Error(\"Must be a VoidPointer\");\n      }\n\n      ({ type } = val);\n      val = val.value;\n    }\n\n    if (val && ctx) {\n      // Must be written as two separate lines rather than += in case `type.size` mutates ctx.pointerSize.\n      let size = type.size(val, parent);\n      ctx.pointerSize += size;\n    }\n\n    return this.offsetType.size();\n  }\n\n  encode(stream, val, ctx) {\n    let relative;\n    const parent = ctx;\n    if ((val == null)) {\n      this.offsetType.encode(stream, this.options.nullValue);\n      return;\n    }\n\n    switch (this.options.type) {\n      case 'local':\n        relative = ctx.startOffset;\n        break;\n      case 'immediate':\n        relative = stream.pos + this.offsetType.size(val, parent);\n        break;\n      case 'parent':\n        ctx = ctx.parent;\n        relative = ctx.startOffset;\n        break;\n      default: // global\n        relative = 0;\n        while (ctx.parent) {\n          ctx = ctx.parent;\n        }\n    }\n\n    if (this.options.relativeTo) {\n      relative += this.relativeToGetter(parent.val);\n    }\n\n    this.offsetType.encode(stream, ctx.pointerOffset - relative);\n\n    let { type } = this;\n    if (type == null) {\n      if (!(val instanceof VoidPointer)) {\n        throw new Error(\"Must be a VoidPointer\");\n      }\n\n      ({ type } = val);\n      val = val.value;\n    }\n\n    ctx.pointers.push({\n      type,\n      val,\n      parent\n    });\n\n    return ctx.pointerOffset += type.size(val, parent);\n  }\n}\n\n// A pointer whose type is determined at decode time\nexport class VoidPointer {\n  constructor(type, value) {\n    this.type = type;\n    this.value = value;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}