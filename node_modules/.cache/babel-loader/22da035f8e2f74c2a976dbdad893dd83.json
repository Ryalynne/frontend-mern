{"ast":null,"code":"import _classCallCheck from \"C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Struct } from './Struct.js';\n\nvar getPath = function getPath(object, pathArray) {\n  return pathArray.reduce(function (prevObj, key) {\n    return prevObj && prevObj[key];\n  }, object);\n};\n\nexport var VersionedStruct = /*#__PURE__*/function (_Struct) {\n  _inherits(VersionedStruct, _Struct);\n\n  var _super = _createSuper(VersionedStruct);\n\n  function VersionedStruct(type) {\n    var _this;\n\n    var versions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, VersionedStruct);\n\n    _this = _super.call(this);\n    _this.type = type;\n    _this.versions = versions;\n\n    if (typeof type === 'string') {\n      _this.versionPath = type.split('.');\n    }\n\n    return _this;\n  }\n\n  _createClass(VersionedStruct, [{\n    key: \"decode\",\n    value: function decode(stream, parent) {\n      var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n      var res = this._setup(stream, parent, length);\n\n      if (typeof this.type === 'string') {\n        res.version = getPath(parent, this.versionPath);\n      } else {\n        res.version = this.type.decode(stream);\n      }\n\n      if (this.versions.header) {\n        this._parseFields(stream, res, this.versions.header);\n      }\n\n      var fields = this.versions[res.version];\n\n      if (fields == null) {\n        throw new Error(\"Unknown version \".concat(res.version));\n      }\n\n      if (fields instanceof VersionedStruct) {\n        return fields.decode(stream, parent);\n      }\n\n      this._parseFields(stream, res, fields);\n\n      if (this.process != null) {\n        this.process.call(res, stream);\n      }\n\n      return res;\n    }\n  }, {\n    key: \"size\",\n    value: function size(val, parent) {\n      var includePointers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var key, type;\n\n      if (!val) {\n        throw new Error('Not a fixed size');\n      }\n\n      if (this.preEncode != null) {\n        this.preEncode.call(val);\n      }\n\n      var ctx = {\n        parent: parent,\n        val: val,\n        pointerSize: 0\n      };\n      var size = 0;\n\n      if (typeof this.type !== 'string') {\n        size += this.type.size(val.version, ctx);\n      }\n\n      if (this.versions.header) {\n        for (key in this.versions.header) {\n          type = this.versions.header[key];\n\n          if (type.size != null) {\n            size += type.size(val[key], ctx);\n          }\n        }\n      }\n\n      var fields = this.versions[val.version];\n\n      if (fields == null) {\n        throw new Error(\"Unknown version \".concat(val.version));\n      }\n\n      for (key in fields) {\n        type = fields[key];\n\n        if (type.size != null) {\n          size += type.size(val[key], ctx);\n        }\n      }\n\n      if (includePointers) {\n        size += ctx.pointerSize;\n      }\n\n      return size;\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(stream, val, parent) {\n      var key, type;\n\n      if (this.preEncode != null) {\n        this.preEncode.call(val, stream);\n      }\n\n      var ctx = {\n        pointers: [],\n        startOffset: stream.pos,\n        parent: parent,\n        val: val,\n        pointerSize: 0\n      };\n      ctx.pointerOffset = stream.pos + this.size(val, ctx, false);\n\n      if (typeof this.type !== 'string') {\n        this.type.encode(stream, val.version);\n      }\n\n      if (this.versions.header) {\n        for (key in this.versions.header) {\n          type = this.versions.header[key];\n\n          if (type.encode != null) {\n            type.encode(stream, val[key], ctx);\n          }\n        }\n      }\n\n      var fields = this.versions[val.version];\n\n      for (key in fields) {\n        type = fields[key];\n\n        if (type.encode != null) {\n          type.encode(stream, val[key], ctx);\n        }\n      }\n\n      var i = 0;\n\n      while (i < ctx.pointers.length) {\n        var ptr = ctx.pointers[i++];\n        ptr.type.encode(stream, ptr.val, ptr.parent);\n      }\n    }\n  }]);\n\n  return VersionedStruct;\n}(Struct);","map":{"version":3,"sources":["C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/restructure/src/VersionedStruct.js"],"names":["Struct","getPath","object","pathArray","reduce","prevObj","key","VersionedStruct","type","versions","versionPath","split","stream","parent","length","res","_setup","version","decode","header","_parseFields","fields","Error","process","call","val","includePointers","preEncode","ctx","pointerSize","size","pointers","startOffset","pos","pointerOffset","encode","i","ptr"],"mappings":"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","sourcesContent":["import {Struct} from './Struct.js';\n\nconst getPath = (object, pathArray) => {\n  return pathArray.reduce((prevObj, key) => prevObj && prevObj[key], object);\n};\n\nexport class VersionedStruct extends Struct {\n  constructor(type, versions = {}) {\n    super();\n    this.type = type;\n    this.versions = versions;\n    if (typeof type === 'string') {\n      this.versionPath = type.split('.');\n    }\n  }\n\n  decode(stream, parent, length = 0) {\n    const res = this._setup(stream, parent, length);\n\n    if (typeof this.type === 'string') {\n      res.version = getPath(parent, this.versionPath);\n    } else {\n      res.version = this.type.decode(stream);\n    }\n\n    if (this.versions.header) {\n      this._parseFields(stream, res, this.versions.header);\n    }\n\n    const fields = this.versions[res.version];\n    if ((fields == null)) {\n      throw new Error(`Unknown version ${res.version}`);\n    }\n\n    if (fields instanceof VersionedStruct) {\n      return fields.decode(stream, parent);\n    }\n\n    this._parseFields(stream, res, fields);\n\n    if (this.process != null) {\n      this.process.call(res, stream);\n    }\n    return res;\n  }\n\n  size(val, parent, includePointers = true) {\n    let key, type;\n    if (!val) {\n      throw new Error('Not a fixed size');\n    }\n\n    if (this.preEncode != null) {\n      this.preEncode.call(val);\n    }\n\n    const ctx = {\n      parent,\n      val,\n      pointerSize: 0\n    };\n\n    let size = 0;\n    if (typeof this.type !== 'string') {\n      size += this.type.size(val.version, ctx);\n    }\n\n    if (this.versions.header) {\n      for (key in this.versions.header) {\n        type = this.versions.header[key];\n        if (type.size != null) {\n          size += type.size(val[key], ctx);\n        }\n      }\n    }\n\n    const fields = this.versions[val.version];\n    if ((fields == null)) {\n      throw new Error(`Unknown version ${val.version}`);\n    }\n\n    for (key in fields) {\n      type = fields[key];\n      if (type.size != null) {\n        size += type.size(val[key], ctx);\n      }\n    }\n\n    if (includePointers) {\n      size += ctx.pointerSize;\n    }\n\n    return size;\n  }\n\n  encode(stream, val, parent) {\n    let key, type;\n    if (this.preEncode != null) {\n      this.preEncode.call(val, stream);\n    }\n\n    const ctx = {\n      pointers: [],\n      startOffset: stream.pos,\n      parent,\n      val,\n      pointerSize: 0\n    };\n\n    ctx.pointerOffset = stream.pos + this.size(val, ctx, false);\n\n    if (typeof this.type !== 'string') {\n      this.type.encode(stream, val.version);\n    }\n\n    if (this.versions.header) {\n      for (key in this.versions.header) {\n        type = this.versions.header[key];\n        if (type.encode != null) {\n          type.encode(stream, val[key], ctx);\n        }\n      }\n    }\n\n    const fields = this.versions[val.version];\n    for (key in fields) {\n      type = fields[key];\n      if (type.encode != null) {\n        type.encode(stream, val[key], ctx);\n      }\n    }\n\n    let i = 0;\n    while (i < ctx.pointers.length) {\n      const ptr = ctx.pointers[i++];\n      ptr.type.encode(stream, ptr.val, ptr.parent);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}