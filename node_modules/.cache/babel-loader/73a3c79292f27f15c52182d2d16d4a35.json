{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { DecodeStream } from './DecodeStream.js';\nvar textEncoder = new TextEncoder();\nvar isBigEndian = new Uint8Array(new Uint16Array([0x1234]).buffer)[0] == 0x12;\nexport var EncodeStream = /*#__PURE__*/function () {\n  function EncodeStream(buffer) {\n    _classCallCheck(this, EncodeStream);\n\n    this.buffer = buffer;\n    this.view = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);\n    this.pos = 0;\n  }\n\n  _createClass(EncodeStream, [{\n    key: \"writeBuffer\",\n    value: function writeBuffer(buffer) {\n      this.buffer.set(buffer, this.pos);\n      this.pos += buffer.length;\n    }\n  }, {\n    key: \"writeString\",\n    value: function writeString(string) {\n      var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'ascii';\n      var buf;\n\n      switch (encoding) {\n        case 'utf16le':\n        case 'utf16-le':\n        case 'ucs2':\n          // node treats this the same as utf16.\n          buf = stringToUtf16(string, isBigEndian);\n          break;\n\n        case 'utf16be':\n        case 'utf16-be':\n          buf = stringToUtf16(string, !isBigEndian);\n          break;\n\n        case 'utf8':\n          buf = textEncoder.encode(string);\n          break;\n\n        case 'ascii':\n          buf = stringToAscii(string);\n          break;\n\n        default:\n          throw new Error(\"Unsupported encoding: \".concat(encoding));\n      }\n\n      this.writeBuffer(buf);\n    }\n  }, {\n    key: \"writeUInt24BE\",\n    value: function writeUInt24BE(val) {\n      this.buffer[this.pos++] = val >>> 16 & 0xff;\n      this.buffer[this.pos++] = val >>> 8 & 0xff;\n      this.buffer[this.pos++] = val & 0xff;\n    }\n  }, {\n    key: \"writeUInt24LE\",\n    value: function writeUInt24LE(val) {\n      this.buffer[this.pos++] = val & 0xff;\n      this.buffer[this.pos++] = val >>> 8 & 0xff;\n      this.buffer[this.pos++] = val >>> 16 & 0xff;\n    }\n  }, {\n    key: \"writeInt24BE\",\n    value: function writeInt24BE(val) {\n      if (val >= 0) {\n        this.writeUInt24BE(val);\n      } else {\n        this.writeUInt24BE(val + 0xffffff + 1);\n      }\n    }\n  }, {\n    key: \"writeInt24LE\",\n    value: function writeInt24LE(val) {\n      if (val >= 0) {\n        this.writeUInt24LE(val);\n      } else {\n        this.writeUInt24LE(val + 0xffffff + 1);\n      }\n    }\n  }, {\n    key: \"fill\",\n    value: function fill(val, length) {\n      if (length < this.buffer.length) {\n        this.buffer.fill(val, this.pos, this.pos + length);\n        this.pos += length;\n      } else {\n        var buf = new Uint8Array(length);\n        buf.fill(val);\n        this.writeBuffer(buf);\n      }\n    }\n  }]);\n\n  return EncodeStream;\n}();\n\nfunction stringToUtf16(string, swap) {\n  var buf = new Uint16Array(string.length);\n\n  for (var i = 0; i < string.length; i++) {\n    var code = string.charCodeAt(i);\n\n    if (swap) {\n      code = code >> 8 | (code & 0xff) << 8;\n    }\n\n    buf[i] = code;\n  }\n\n  return new Uint8Array(buf.buffer);\n}\n\nfunction stringToAscii(string) {\n  var buf = new Uint8Array(string.length);\n\n  for (var i = 0; i < string.length; i++) {\n    // Match node.js behavior - encoding allows 8-bit rather than 7-bit.\n    buf[i] = string.charCodeAt(i);\n  }\n\n  return buf;\n}\n\nvar _iterator = _createForOfIteratorHelper(Object.getOwnPropertyNames(DataView.prototype)),\n    _step;\n\ntry {\n  var _loop = function _loop() {\n    var key = _step.value;\n\n    if (key.slice(0, 3) === 'set') {\n      var type = key.slice(3).replace('Ui', 'UI');\n\n      if (type === 'Float32') {\n        type = 'Float';\n      } else if (type === 'Float64') {\n        type = 'Double';\n      }\n\n      var bytes = DecodeStream.TYPES[type];\n\n      EncodeStream.prototype['write' + type + (bytes === 1 ? '' : 'BE')] = function (value) {\n        this.view[key](this.pos, value, false);\n        this.pos += bytes;\n      };\n\n      if (bytes !== 1) {\n        EncodeStream.prototype['write' + type + 'LE'] = function (value) {\n          this.view[key](this.pos, value, true);\n          this.pos += bytes;\n        };\n      }\n    }\n  };\n\n  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n    _loop();\n  }\n} catch (err) {\n  _iterator.e(err);\n} finally {\n  _iterator.f();\n}","map":{"version":3,"sources":["C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/restructure/src/EncodeStream.js"],"names":["DecodeStream","textEncoder","TextEncoder","isBigEndian","Uint8Array","Uint16Array","buffer","EncodeStream","view","DataView","byteOffset","byteLength","pos","set","length","string","encoding","buf","stringToUtf16","encode","stringToAscii","Error","writeBuffer","val","writeUInt24BE","writeUInt24LE","fill","swap","i","code","charCodeAt","Object","getOwnPropertyNames","prototype","key","slice","type","replace","bytes","TYPES","value"],"mappings":"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","sourcesContent":["import {DecodeStream} from './DecodeStream.js';\n\nconst textEncoder = new TextEncoder();\nconst isBigEndian = new Uint8Array(new Uint16Array([0x1234]).buffer)[0] == 0x12;\n\nexport class EncodeStream {\n  constructor(buffer) {\n    this.buffer = buffer;\n    this.view = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);\n    this.pos = 0;\n  }\n\n  writeBuffer(buffer) {\n    this.buffer.set(buffer, this.pos);\n    this.pos += buffer.length;\n  }\n\n  writeString(string, encoding = 'ascii') {\n    let buf;\n    switch (encoding) {\n      case 'utf16le':\n      case 'utf16-le':\n      case 'ucs2': // node treats this the same as utf16.\n        buf = stringToUtf16(string, isBigEndian);\n        break;\n\n      case 'utf16be':\n      case 'utf16-be':\n        buf = stringToUtf16(string, !isBigEndian);\n        break;\n\n      case 'utf8':\n        buf = textEncoder.encode(string);\n        break;\n\n      case 'ascii':\n        buf = stringToAscii(string);\n        break;\n\n      default:\n        throw new Error(`Unsupported encoding: ${encoding}`);\n    }\n\n    this.writeBuffer(buf);\n  }\n\n  writeUInt24BE(val) {\n    this.buffer[this.pos++] = (val >>> 16) & 0xff;\n    this.buffer[this.pos++] = (val >>> 8) & 0xff;\n    this.buffer[this.pos++] = val & 0xff;\n  }\n\n  writeUInt24LE(val) {\n    this.buffer[this.pos++] = val & 0xff;\n    this.buffer[this.pos++] = (val >>> 8) & 0xff;\n    this.buffer[this.pos++] = (val >>> 16) & 0xff;\n  }\n\n  writeInt24BE(val) {\n    if (val >= 0) {\n      this.writeUInt24BE(val);\n    } else {\n      this.writeUInt24BE(val + 0xffffff + 1);\n    }\n  }\n\n  writeInt24LE(val) {\n    if (val >= 0) {\n      this.writeUInt24LE(val);\n    } else {\n      this.writeUInt24LE(val + 0xffffff + 1);\n    }\n  }\n\n  fill(val, length) {\n    if (length < this.buffer.length) {\n      this.buffer.fill(val, this.pos, this.pos + length);\n      this.pos += length;\n    } else {\n      const buf = new Uint8Array(length);\n      buf.fill(val);\n      this.writeBuffer(buf);\n    }\n  }\n}\n\nfunction stringToUtf16(string, swap) {\n  let buf = new Uint16Array(string.length);\n  for (let i = 0; i < string.length; i++) {\n    let code = string.charCodeAt(i);\n    if (swap) {\n      code = (code >> 8) | ((code & 0xff) << 8);\n    }\n    buf[i] = code;\n  }\n  return new Uint8Array(buf.buffer);\n}\n\nfunction stringToAscii(string) {\n  let buf = new Uint8Array(string.length);\n  for (let i = 0; i < string.length; i++) {\n    // Match node.js behavior - encoding allows 8-bit rather than 7-bit.\n    buf[i] = string.charCodeAt(i);\n  }\n  return buf;\n}\n\nfor (let key of Object.getOwnPropertyNames(DataView.prototype)) {\n  if (key.slice(0, 3) === 'set') {\n    let type = key.slice(3).replace('Ui', 'UI');\n    if (type === 'Float32') {\n      type = 'Float';\n    } else if (type === 'Float64') {\n      type = 'Double';\n    }\n    let bytes = DecodeStream.TYPES[type];\n    EncodeStream.prototype['write' + type + (bytes === 1 ? '' : 'BE')] = function (value) {\n      this.view[key](this.pos, value, false);\n      this.pos += bytes;\n    };\n\n    if (bytes !== 1) {\n      EncodeStream.prototype['write' + type + 'LE'] = function (value) {\n        this.view[key](this.pos, value, true);\n        this.pos += bytes;\n      };\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}