{"ast":null,"code":"import * as utils from './utils.js';\nimport { Base } from './Base.js';\nexport class Pointer extends Base {\n  constructor(offsetType, type) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super();\n    this.offsetType = offsetType;\n    this.type = type;\n    this.options = options;\n\n    if (this.type === 'void') {\n      this.type = null;\n    }\n\n    if (this.options.type == null) {\n      this.options.type = 'local';\n    }\n\n    if (this.options.allowNull == null) {\n      this.options.allowNull = true;\n    }\n\n    if (this.options.nullValue == null) {\n      this.options.nullValue = 0;\n    }\n\n    if (this.options.lazy == null) {\n      this.options.lazy = false;\n    }\n\n    if (this.options.relativeTo) {\n      if (typeof this.options.relativeTo !== 'function') {\n        throw new Error('relativeTo option must be a function');\n      }\n\n      this.relativeToGetter = options.relativeTo;\n    }\n  }\n\n  decode(stream, ctx) {\n    const offset = this.offsetType.decode(stream, ctx); // handle NULL pointers\n\n    if (offset === this.options.nullValue && this.options.allowNull) {\n      return null;\n    }\n\n    let relative;\n\n    switch (this.options.type) {\n      case 'local':\n        relative = ctx._startOffset;\n        break;\n\n      case 'immediate':\n        relative = stream.pos - this.offsetType.size();\n        break;\n\n      case 'parent':\n        relative = ctx.parent._startOffset;\n        break;\n\n      default:\n        var c = ctx;\n\n        while (c.parent) {\n          c = c.parent;\n        }\n\n        relative = c._startOffset || 0;\n    }\n\n    if (this.options.relativeTo) {\n      relative += this.relativeToGetter(ctx);\n    }\n\n    const ptr = offset + relative;\n\n    if (this.type != null) {\n      let val = null;\n\n      const decodeValue = () => {\n        if (val != null) {\n          return val;\n        }\n\n        const {\n          pos\n        } = stream;\n        stream.pos = ptr;\n        val = this.type.decode(stream, ctx);\n        stream.pos = pos;\n        return val;\n      }; // If this is a lazy pointer, define a getter to decode only when needed.\n      // This obviously only works when the pointer is contained by a Struct.\n\n\n      if (this.options.lazy) {\n        return new utils.PropertyDescriptor({\n          get: decodeValue\n        });\n      }\n\n      return decodeValue();\n    } else {\n      return ptr;\n    }\n  }\n\n  size(val, ctx) {\n    const parent = ctx;\n\n    switch (this.options.type) {\n      case 'local':\n      case 'immediate':\n        break;\n\n      case 'parent':\n        ctx = ctx.parent;\n        break;\n\n      default:\n        // global\n        while (ctx.parent) {\n          ctx = ctx.parent;\n        }\n\n    }\n\n    let {\n      type\n    } = this;\n\n    if (type == null) {\n      if (!(val instanceof VoidPointer)) {\n        throw new Error(\"Must be a VoidPointer\");\n      }\n\n      ({\n        type\n      } = val);\n      val = val.value;\n    }\n\n    if (val && ctx) {\n      // Must be written as two separate lines rather than += in case `type.size` mutates ctx.pointerSize.\n      let size = type.size(val, parent);\n      ctx.pointerSize += size;\n    }\n\n    return this.offsetType.size();\n  }\n\n  encode(stream, val, ctx) {\n    let relative;\n    const parent = ctx;\n\n    if (val == null) {\n      this.offsetType.encode(stream, this.options.nullValue);\n      return;\n    }\n\n    switch (this.options.type) {\n      case 'local':\n        relative = ctx.startOffset;\n        break;\n\n      case 'immediate':\n        relative = stream.pos + this.offsetType.size(val, parent);\n        break;\n\n      case 'parent':\n        ctx = ctx.parent;\n        relative = ctx.startOffset;\n        break;\n\n      default:\n        // global\n        relative = 0;\n\n        while (ctx.parent) {\n          ctx = ctx.parent;\n        }\n\n    }\n\n    if (this.options.relativeTo) {\n      relative += this.relativeToGetter(parent.val);\n    }\n\n    this.offsetType.encode(stream, ctx.pointerOffset - relative);\n    let {\n      type\n    } = this;\n\n    if (type == null) {\n      if (!(val instanceof VoidPointer)) {\n        throw new Error(\"Must be a VoidPointer\");\n      }\n\n      ({\n        type\n      } = val);\n      val = val.value;\n    }\n\n    ctx.pointers.push({\n      type,\n      val,\n      parent\n    });\n    return ctx.pointerOffset += type.size(val, parent);\n  }\n\n} // A pointer whose type is determined at decode time\n\nexport class VoidPointer {\n  constructor(type, value) {\n    this.type = type;\n    this.value = value;\n  }\n\n}","map":{"version":3,"sources":["C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/restructure/src/Pointer.js"],"names":["utils","Base","Pointer","constructor","offsetType","type","options","allowNull","nullValue","lazy","relativeTo","Error","relativeToGetter","decode","stream","ctx","offset","relative","_startOffset","pos","size","parent","c","ptr","val","decodeValue","PropertyDescriptor","get","VoidPointer","value","pointerSize","encode","startOffset","pointerOffset","pointers","push"],"mappings":"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","sourcesContent":["import * as utils from './utils.js';\nimport {Base} from './Base.js';\n\nexport class Pointer extends Base {\n  constructor(offsetType, type, options = {}) {\n    super();\n    this.offsetType = offsetType;\n    this.type = type;\n    this.options = options;\n    if (this.type === 'void') { this.type = null; }\n    if (this.options.type == null) { this.options.type = 'local'; }\n    if (this.options.allowNull == null) { this.options.allowNull = true; }\n    if (this.options.nullValue == null) { this.options.nullValue = 0; }\n    if (this.options.lazy == null) { this.options.lazy = false; }\n    if (this.options.relativeTo) {\n      if (typeof this.options.relativeTo !== 'function') {\n        throw new Error('relativeTo option must be a function');\n      }\n      this.relativeToGetter = options.relativeTo;\n    }\n  }\n\n  decode(stream, ctx) {\n    const offset = this.offsetType.decode(stream, ctx);\n\n    // handle NULL pointers\n    if ((offset === this.options.nullValue) && this.options.allowNull) {\n      return null;\n    }\n\n    let relative;\n    switch (this.options.type) {\n      case 'local':     relative = ctx._startOffset; break;\n      case 'immediate': relative = stream.pos - this.offsetType.size(); break;\n      case 'parent':    relative = ctx.parent._startOffset; break;\n      default:\n        var c = ctx;\n        while (c.parent) {\n          c = c.parent;\n        }\n\n        relative = c._startOffset || 0;\n    }\n\n    if (this.options.relativeTo) {\n      relative += this.relativeToGetter(ctx);\n    }\n\n    const ptr = offset + relative;\n\n    if (this.type != null) {\n      let val = null;\n      const decodeValue = () => {\n        if (val != null) { return val; }\n\n        const { pos } = stream;\n        stream.pos = ptr;\n        val = this.type.decode(stream, ctx);\n        stream.pos = pos;\n        return val;\n      };\n\n      // If this is a lazy pointer, define a getter to decode only when needed.\n      // This obviously only works when the pointer is contained by a Struct.\n      if (this.options.lazy) {\n        return new utils.PropertyDescriptor({\n          get: decodeValue});\n      }\n\n      return decodeValue();\n    } else {\n      return ptr;\n    }\n  }\n\n  size(val, ctx) {\n    const parent = ctx;\n    switch (this.options.type) {\n      case 'local': case 'immediate':\n        break;\n      case 'parent':\n        ctx = ctx.parent;\n        break;\n      default: // global\n        while (ctx.parent) {\n          ctx = ctx.parent;\n        }\n    }\n\n    let { type } = this;\n    if (type == null) {\n      if (!(val instanceof VoidPointer)) {\n        throw new Error(\"Must be a VoidPointer\");\n      }\n\n      ({ type } = val);\n      val = val.value;\n    }\n\n    if (val && ctx) {\n      // Must be written as two separate lines rather than += in case `type.size` mutates ctx.pointerSize.\n      let size = type.size(val, parent);\n      ctx.pointerSize += size;\n    }\n\n    return this.offsetType.size();\n  }\n\n  encode(stream, val, ctx) {\n    let relative;\n    const parent = ctx;\n    if ((val == null)) {\n      this.offsetType.encode(stream, this.options.nullValue);\n      return;\n    }\n\n    switch (this.options.type) {\n      case 'local':\n        relative = ctx.startOffset;\n        break;\n      case 'immediate':\n        relative = stream.pos + this.offsetType.size(val, parent);\n        break;\n      case 'parent':\n        ctx = ctx.parent;\n        relative = ctx.startOffset;\n        break;\n      default: // global\n        relative = 0;\n        while (ctx.parent) {\n          ctx = ctx.parent;\n        }\n    }\n\n    if (this.options.relativeTo) {\n      relative += this.relativeToGetter(parent.val);\n    }\n\n    this.offsetType.encode(stream, ctx.pointerOffset - relative);\n\n    let { type } = this;\n    if (type == null) {\n      if (!(val instanceof VoidPointer)) {\n        throw new Error(\"Must be a VoidPointer\");\n      }\n\n      ({ type } = val);\n      val = val.value;\n    }\n\n    ctx.pointers.push({\n      type,\n      val,\n      parent\n    });\n\n    return ctx.pointerOffset += type.size(val, parent);\n  }\n}\n\n// A pointer whose type is determined at decode time\nexport class VoidPointer {\n  constructor(type, value) {\n    this.type = type;\n    this.value = value;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}