{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _createClass from \"C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _objectWithoutProperties from \"C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _defineProperty from \"C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _slicedToArray from \"C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectSpread from \"C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nvar _excluded = [\"excludeRects\"];\nimport { isNil, last, repeat, reverse, dropLast as dropLast$2, adjust, compose } from '@react-pdf/fns';\nimport bidiFactory from 'bidi-js';\nimport unicode from 'unicode-properties';\nimport hyphen from 'hyphen';\nimport pattern from 'hyphen/patterns/en-us.js';\n/**\n * Create attributed string from text fragments\n *\n * @param fragments - Fragments\n * @returns Attributed string\n */\n\nvar fromFragments = function fromFragments(fragments) {\n  var offset = 0;\n  var string = '';\n  var runs = [];\n  fragments.forEach(function (fragment) {\n    string += fragment.string;\n    runs.push(_objectSpread(_objectSpread({}, fragment), {}, {\n      start: offset,\n      end: offset + fragment.string.length,\n      attributes: fragment.attributes || {}\n    }));\n    offset += fragment.string.length;\n  });\n  return {\n    string: string,\n    runs: runs\n  };\n};\n/**\n * Default word hyphenation engine used when no one provided.\n * Does not perform word hyphenation at all\n *\n * @param word\n * @returns Same word\n */\n\n\nvar defaultHyphenationEngine = function defaultHyphenationEngine(word) {\n  return [word];\n};\n/**\n * Wrap words of attribute string\n *\n * @param engines layout engines\n * @param options layout options\n */\n\n\nvar wrapWords = function wrapWords() {\n  var engines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  /**\n   * @param attributedString - Attributed string\n   * @returns Attributed string including syllables\n   */\n  return function (attributedString) {\n    var _engines$wordHyphenat;\n\n    var syllables = [];\n    var fragments = [];\n    var hyphenateWord = options.hyphenationCallback || ((_engines$wordHyphenat = engines.wordHyphenation) === null || _engines$wordHyphenat === void 0 ? void 0 : _engines$wordHyphenat.call(engines)) || defaultHyphenationEngine;\n\n    for (var i = 0; i < attributedString.runs.length; i += 1) {\n      var string = '';\n      var run = attributedString.runs[i];\n      var words = attributedString.string.slice(run.start, run.end).split(/([ ]+)/g).filter(Boolean);\n\n      for (var j = 0; j < words.length; j += 1) {\n        var word = words[j];\n        var parts = hyphenateWord(word);\n        syllables.push.apply(syllables, _toConsumableArray(parts));\n        string += parts.join('');\n      }\n\n      fragments.push(_objectSpread(_objectSpread({}, run), {}, {\n        string: string\n      }));\n    }\n\n    var result = _objectSpread(_objectSpread({}, fromFragments(fragments)), {}, {\n      syllables: syllables\n    });\n\n    return result;\n  };\n};\n/**\n * Clone rect\n *\n * @param rect - Rect\n * @returns Cloned rect\n */\n\n\nvar copy = function copy(rect) {\n  return Object.assign({}, rect);\n};\n/**\n * Partition rect in two in the vertical direction\n *\n * @param rect - Rect\n * @param height - Height\n * @returns Partitioned rects\n */\n\n\nvar partition = function partition(rect, height) {\n  var a = Object.assign({}, rect, {\n    height: height\n  });\n  var b = Object.assign({}, rect, {\n    y: rect.y + height,\n    height: rect.height - height\n  });\n  return [a, b];\n};\n/**\n * Crop upper section of rect\n *\n * @param height - Height\n * @param rect - Rect\n * @returns Cropped rect\n */\n\n\nvar crop = function crop(height, rect) {\n  var _partition = partition(rect, height),\n      _partition2 = _slicedToArray(_partition, 2),\n      result = _partition2[1];\n\n  return result;\n};\n/**\n * Get paragraph block height\n *\n * @param paragraph - Paragraph\n * @returns Paragraph block height\n */\n\n\nvar height$2 = function height$2(paragraph) {\n  return paragraph.reduce(function (acc, block) {\n    return acc + block.box.height;\n  }, 0);\n};\n/**\n * Calculate run scale\n *\n * @param run - Run\n * @returns Scale\n */\n\n\nvar calculateScale = function calculateScale(run) {\n  var _font$;\n\n  var attributes = run.attributes || {};\n  var fontSize = attributes.fontSize || 12;\n  var font = attributes.font;\n  var unitsPerEm = typeof font === 'string' ? null : font === null || font === void 0 ? void 0 : (_font$ = font[0]) === null || _font$ === void 0 ? void 0 : _font$.unitsPerEm;\n  return unitsPerEm ? fontSize / unitsPerEm : 0;\n};\n/**\n * Get run scale\n *\n * @param  run\n * @returns Scale\n */\n\n\nvar scale = function scale(run) {\n  var _run$attributes;\n\n  return ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.scale) || calculateScale(run);\n};\n/**\n * Get ligature offset by index\n *\n * Ex. ffi ligature\n *\n *   glyphs:         l  o  f  f  i  m\n *   glyphIndices:   0  1  2  2  2  3\n *   offset:         0  0  0  1  2  0\n *\n * @param index\n * @param run - Run\n * @returns Ligature offset\n */\n\n\nvar offset = function offset(index, run) {\n  if (!run) return 0;\n  var glyphIndices = run.glyphIndices || [];\n  var value = glyphIndices[index];\n  return glyphIndices.slice(0, index).filter(function (i) {\n    return i === value;\n  }).length;\n};\n/**\n * Get run font\n *\n * @param run - Run\n * @returns Font\n */\n\n\nvar getFont = function getFont(run) {\n  var _run$attributes2, _run$attributes2$font;\n\n  return ((_run$attributes2 = run.attributes) === null || _run$attributes2 === void 0 ? void 0 : (_run$attributes2$font = _run$attributes2.font) === null || _run$attributes2$font === void 0 ? void 0 : _run$attributes2$font[0]) || null;\n};\n/**\n * Slice glyph between codePoints range\n * Util for breaking ligatures\n *\n * @param start - Start code point index\n * @param end - End code point index\n * @param font - Font to generate new glyph\n * @param glyph - Glyph to be sliced\n * @returns Sliced glyph parts\n */\n\n\nvar slice$2 = function slice$2(start, end, font, glyph) {\n  if (!glyph) return [];\n  if (start === end) return [];\n  if (start === 0 && end === glyph.codePoints.length) return [glyph];\n  var codePoints = glyph.codePoints.slice(start, end);\n  var string = String.fromCodePoint.apply(String, _toConsumableArray(codePoints)); // passing LTR To force fontkit to not reverse the string\n\n  return font ? font.layout(string, undefined, undefined, undefined, 'ltr').glyphs : [glyph];\n};\n/**\n * Return glyph index at string index, if glyph indices present.\n * Otherwise return string index\n *\n * @param index - Index\n * @param run - Run\n * @returns Glyph index\n */\n\n\nvar glyphIndexAt = function glyphIndexAt(index, run) {\n  var _run$glyphIndices;\n\n  var result = run === null || run === void 0 ? void 0 : (_run$glyphIndices = run.glyphIndices) === null || _run$glyphIndices === void 0 ? void 0 : _run$glyphIndices[index];\n  return isNil(result) ? index : result;\n};\n/**\n * Returns new array starting with zero, and keeping same relation between consecutive values\n *\n * @param array - List\n * @returns Normalized array\n */\n\n\nvar normalize = function normalize(array) {\n  var head = array[0];\n  return array.map(function (value) {\n    return value - head;\n  });\n};\n/**\n * Slice run between glyph indices range\n *\n * @param start - Glyph index\n * @param end - Glyph index\n * @param run - Run\n * @returns Sliced run\n */\n\n\nvar slice$1 = function slice$1(start, end, run) {\n  var _run$glyphs, _run$glyphs2;\n\n  var runScale = scale(run);\n  var font = getFont(run); // Get glyph start and end indices\n\n  var startIndex = glyphIndexAt(start, run);\n  var endIndex = glyphIndexAt(end, run); // Get start and end glyph\n\n  var startGlyph = (_run$glyphs = run.glyphs) === null || _run$glyphs === void 0 ? void 0 : _run$glyphs[startIndex];\n  var endGlyph = (_run$glyphs2 = run.glyphs) === null || _run$glyphs2 === void 0 ? void 0 : _run$glyphs2[endIndex]; // Get start ligature chunks (if any)\n\n  var startOffset = offset(start, run);\n  var startGlyphs = startOffset > 0 ? slice$2(startOffset, Infinity, font, startGlyph) : []; // Get end ligature chunks (if any)\n\n  var endOffset = offset(end, run);\n  var endGlyphs = slice$2(0, endOffset, font, endGlyph); // Compute new glyphs\n\n  var sliceStart = startIndex + Math.min(1, startOffset);\n  var glyphs = (run.glyphs || []).slice(sliceStart, endIndex); // Compute new positions\n\n  var glyphPosition = function glyphPosition(g) {\n    return {\n      xAdvance: g.advanceWidth * runScale,\n      yAdvance: 0,\n      xOffset: 0,\n      yOffset: 0\n    };\n  };\n\n  var startPositions = startGlyphs.map(glyphPosition);\n  var positions = (run.positions || []).slice(sliceStart, endIndex);\n  var endPositions = endGlyphs.map(glyphPosition);\n  return Object.assign({}, run, {\n    start: run.start + start,\n    end: Math.min(run.end, run.start + end),\n    glyphIndices: normalize((run.glyphIndices || []).slice(start, end)),\n    glyphs: [startGlyphs, glyphs, endGlyphs].flat(),\n    positions: [startPositions, positions, endPositions].flat()\n  });\n};\n/**\n * Get run index that contains passed index\n *\n * @param index - Index\n * @param runs - Runs\n * @returns Run index\n */\n\n\nvar runIndexAt$1 = function runIndexAt$1(index, runs) {\n  if (!runs) return -1;\n  return runs.findIndex(function (run) {\n    return run.start <= index && index < run.end;\n  });\n};\n/**\n * Filter runs contained between start and end\n *\n * @param start\n * @param end\n * @param runs\n * @returns Filtered runs\n */\n\n\nvar filter = function filter(start, end, runs) {\n  var startIndex = runIndexAt$1(start, runs);\n  var endIndex = Math.max(runIndexAt$1(end - 1, runs), startIndex);\n  return runs.slice(startIndex, endIndex + 1);\n};\n/**\n * Subtract scalar to run\n *\n * @param index - Scalar\n * @param run - Run\n * @returns Subtracted run\n */\n\n\nvar subtract = function subtract(index, run) {\n  var start = run.start - index;\n  var end = run.end - index;\n  return Object.assign({}, run, {\n    start: start,\n    end: end\n  });\n};\n/**\n * Slice array of runs\n *\n * @param start - Offset\n * @param end - Offset\n * @param runs\n * @returns Sliced runs\n */\n\n\nvar sliceRuns = function sliceRuns(start, end, runs) {\n  var sliceFirstRun = function sliceFirstRun(a) {\n    return slice$1(start - a.start, end - a.start, a);\n  };\n\n  var sliceLastRun = function sliceLastRun(a) {\n    return slice$1(0, end - a.start, a);\n  };\n\n  return runs.map(function (run, i) {\n    var result = run;\n    var isFirst = i === 0;\n    var isLast = !isFirst && i === runs.length - 1;\n    if (isFirst) result = sliceFirstRun(run);\n    if (isLast) result = sliceLastRun(run);\n    return subtract(start, result);\n  });\n};\n/**\n * Slice attributed string between two indices\n *\n * @param start - Offset\n * @param end - Offset\n * @param attributedString - Attributed string\n * @returns Attributed string\n */\n\n\nvar slice = function slice(start, end, attributedString) {\n  if (attributedString.string.length === 0) return attributedString;\n  var string = attributedString.string.slice(start, end);\n  var filteredRuns = filter(start, end, attributedString.runs);\n  var slicedRuns = sliceRuns(start, end, filteredRuns);\n  return Object.assign({}, attributedString, {\n    string: string,\n    runs: slicedRuns\n  });\n};\n\nvar findCharIndex = function findCharIndex(string) {\n  return string.search(/\\S/g);\n};\n\nvar findLastCharIndex = function findLastCharIndex(string) {\n  var match = string.match(/\\S/g);\n  return match ? string.lastIndexOf(match[match.length - 1]) : -1;\n};\n/**\n * Removes (strips) whitespace from both ends of the attributted string.\n *\n * @param attributedString - Attributed string\n * @returns Attributed string\n */\n\n\nvar trim = function trim(attributedString) {\n  var start = findCharIndex(attributedString.string);\n  var end = findLastCharIndex(attributedString.string);\n  return slice(start, end + 1, attributedString);\n};\n/**\n * Returns empty run\n *\n * @returns Empty run\n */\n\n\nvar empty$1 = function empty$1() {\n  return {\n    start: 0,\n    end: 0,\n    glyphIndices: [],\n    glyphs: [],\n    positions: [],\n    attributes: {}\n  };\n};\n/**\n * Check if value is a number\n *\n * @param value - Value to check\n * @returns Whether value is a number\n */\n\n\nvar isNumber = function isNumber(value) {\n  return typeof value === 'number';\n};\n/**\n * Append glyph indices with given length\n *\n * Ex. appendIndices(3, [0, 1, 2, 2]) => [0, 1, 2, 2, 3, 3, 3]\n *\n * @param length - Length\n * @param indices - Glyph indices\n * @returns Extended glyph indices\n */\n\n\nvar appendIndices = function appendIndices(length, indices) {\n  var lastIndex = last(indices);\n  var value = isNil(lastIndex) ? 0 : lastIndex + 1;\n  var newIndices = Array(length).fill(value);\n  return indices.concat(newIndices);\n};\n/**\n * Get glyph for a given code point\n *\n * @param value - CodePoint\n * @param font - Font\n * @returns Glyph\n * */\n\n\nvar fromCodePoint = function fromCodePoint(value, font) {\n  if (typeof font === 'string') return null;\n  return font && value ? font.glyphForCodePoint(value) : null;\n};\n/**\n * Append glyph to run\n *\n * @param glyph - Glyph\n * @param run - Run\n * @returns Run with glyph\n */\n\n\nvar appendGlyph = function appendGlyph(glyph, run) {\n  var _glyph$codePoints;\n\n  var glyphLength = ((_glyph$codePoints = glyph.codePoints) === null || _glyph$codePoints === void 0 ? void 0 : _glyph$codePoints.length) || 0;\n  var end = run.end + glyphLength;\n  var glyphs = run.glyphs.concat(glyph);\n  var glyphIndices = appendIndices(glyphLength, run.glyphIndices);\n  if (!run.positions) return Object.assign({}, run, {\n    end: end,\n    glyphs: glyphs,\n    glyphIndices: glyphIndices\n  });\n  var positions = run.positions.concat({\n    xAdvance: glyph.advanceWidth * scale(run),\n    yAdvance: 0,\n    xOffset: 0,\n    yOffset: 0\n  });\n  return Object.assign({}, run, {\n    end: end,\n    glyphs: glyphs,\n    glyphIndices: glyphIndices,\n    positions: positions\n  });\n};\n/**\n * Append glyph or code point to run\n *\n * @param value - Glyph or codePoint\n * @param run - Run\n * @returns Run with glyph\n */\n\n\nvar append$1 = function append$1(value, run) {\n  if (!value) return run;\n  var font = getFont(run);\n  var glyph = isNumber(value) ? fromCodePoint(value, font) : value;\n  return appendGlyph(glyph, run);\n};\n/**\n * Get string from array of code points\n *\n * @param codePoints - Points\n * @returns String\n */\n\n\nvar stringFromCodePoints = function stringFromCodePoints(codePoints) {\n  return String.fromCodePoint.apply(String, _toConsumableArray(codePoints || []));\n};\n/**\n * Append glyph into last run of attributed string\n *\n * @param glyph - Glyph or code point\n * @param attributedString - Attributed string\n * @returns Attributed string with new glyph\n */\n\n\nvar append = function append(glyph, attributedString) {\n  var codePoints = typeof glyph === 'number' ? [glyph] : glyph === null || glyph === void 0 ? void 0 : glyph.codePoints;\n  var codePointsString = stringFromCodePoints(codePoints || []);\n  var string = attributedString.string + codePointsString;\n  var firstRuns = attributedString.runs.slice(0, -1);\n  var lastRun = last(attributedString.runs) || empty$1();\n  var runs = firstRuns.concat(append$1(glyph, lastRun));\n  return Object.assign({}, attributedString, {\n    string: string,\n    runs: runs\n  });\n};\n\nvar ELLIPSIS_UNICODE = 8230;\nvar ELLIPSIS_STRING = String.fromCharCode(ELLIPSIS_UNICODE);\n/**\n * Get ellipsis codepoint. This may be different in standard and embedded fonts\n *\n * @param font\n * @returns Ellipsis codepoint\n */\n\nvar getEllipsisCodePoint = function getEllipsisCodePoint(font) {\n  if (!font.encode) return ELLIPSIS_UNICODE;\n\n  var _font$encode = font.encode(ELLIPSIS_STRING),\n      _font$encode2 = _slicedToArray(_font$encode, 1),\n      codePoints = _font$encode2[0];\n\n  return parseInt(codePoints[0], 16);\n};\n/**\n * Trucante block with ellipsis\n *\n * @param paragraph - Paragraph\n * @returns Sliced paragraph\n */\n\n\nvar truncate = function truncate(paragraph) {\n  var _last, _last2, _last2$attributes;\n\n  var runs = ((_last = last(paragraph)) === null || _last === void 0 ? void 0 : _last.runs) || [];\n  var font = (_last2 = last(runs)) === null || _last2 === void 0 ? void 0 : (_last2$attributes = _last2.attributes) === null || _last2$attributes === void 0 ? void 0 : _last2$attributes.font[0];\n\n  if (font) {\n    var index = paragraph.length - 1;\n    var codePoint = getEllipsisCodePoint(font);\n    var glyph = font.glyphForCodePoint(codePoint);\n    var lastBlock = append(glyph, trim(paragraph[index]));\n    return Object.assign([], paragraph, _defineProperty({}, index, lastBlock));\n  }\n\n  return paragraph;\n};\n/**\n * Omit attribute from run\n *\n * @param value - Attribute key\n * @param run - Run\n * @returns Run without ommited attribute\n */\n\n\nvar omit = function omit(value, run) {\n  var attributes = Object.assign({}, run.attributes);\n  delete attributes[value];\n  return Object.assign({}, run, {\n    attributes: attributes\n  });\n};\n/**\n * Get run ascent\n *\n * @param run - Run\n * @returns Ascent\n */\n\n\nvar ascent$1 = function ascent$1(run) {\n  var _font$2;\n\n  var _run$attributes3 = run.attributes,\n      font = _run$attributes3.font,\n      attachment = _run$attributes3.attachment;\n  var attachmentHeight = (attachment === null || attachment === void 0 ? void 0 : attachment.height) || 0;\n  var fontAscent = typeof font === 'string' ? 0 : (font === null || font === void 0 ? void 0 : (_font$2 = font[0]) === null || _font$2 === void 0 ? void 0 : _font$2.ascent) || 0;\n  return Math.max(attachmentHeight, fontAscent * scale(run));\n};\n/**\n * Get run descent\n *\n * @param run - Run\n * @returns Descent\n */\n\n\nvar descent = function descent(run) {\n  var _run$attributes4, _font$3;\n\n  var font = (_run$attributes4 = run.attributes) === null || _run$attributes4 === void 0 ? void 0 : _run$attributes4.font;\n  var fontDescent = typeof font === 'string' ? 0 : (font === null || font === void 0 ? void 0 : (_font$3 = font[0]) === null || _font$3 === void 0 ? void 0 : _font$3.descent) || 0;\n  return scale(run) * fontDescent;\n};\n/**\n * Get run lineGap\n *\n * @param run - Run\n * @returns LineGap\n */\n\n\nvar lineGap = function lineGap(run) {\n  var _run$attributes5, _font$4;\n\n  var font = (_run$attributes5 = run.attributes) === null || _run$attributes5 === void 0 ? void 0 : _run$attributes5.font;\n  var lineGap = typeof font === 'string' ? 0 : (font === null || font === void 0 ? void 0 : (_font$4 = font[0]) === null || _font$4 === void 0 ? void 0 : _font$4.lineGap) || 0;\n  return lineGap * scale(run);\n};\n/**\n * Get run height\n *\n * @param run - Run\n * @returns Height\n */\n\n\nvar height$1 = function height$1(run) {\n  var _run$attributes6;\n\n  var lineHeight = (_run$attributes6 = run.attributes) === null || _run$attributes6 === void 0 ? void 0 : _run$attributes6.lineHeight;\n  return lineHeight || lineGap(run) + ascent$1(run) - descent(run);\n};\n/**\n * Returns attributed string height\n *\n * @param attributedString - Attributed string\n * @returns Height\n */\n\n\nvar height = function height(attributedString) {\n  var reducer = function reducer(acc, run) {\n    return Math.max(acc, height$1(run));\n  };\n\n  return attributedString.runs.reduce(reducer, 0);\n};\n/**\n * Checks if two rects intersect each other\n *\n * @param a - Rect A\n * @param b - Rect B\n * @returns Whether rects intersect\n */\n\n\nvar intersects = function intersects(a, b) {\n  var x = Math.max(a.x, b.x);\n  var num1 = Math.min(a.x + a.width, b.x + b.width);\n  var y = Math.max(a.y, b.y);\n  var num2 = Math.min(a.y + a.height, b.y + b.height);\n  return num1 >= x && num2 >= y;\n};\n\nvar getLineFragment = function getLineFragment(lineRect, excludeRect) {\n  if (!intersects(excludeRect, lineRect)) return [lineRect];\n  var eStart = excludeRect.x;\n  var eEnd = excludeRect.x + excludeRect.width;\n  var lStart = lineRect.x;\n  var lEnd = lineRect.x + lineRect.width;\n  var a = Object.assign({}, lineRect, {\n    width: eStart - lStart\n  });\n  var b = Object.assign({}, lineRect, {\n    x: eEnd,\n    width: lEnd - eEnd\n  });\n  return [a, b].filter(function (r) {\n    return r.width > 0;\n  });\n};\n\nvar getLineFragments = function getLineFragments(rect, excludeRects) {\n  var fragments = [rect];\n\n  var _loop = function _loop(i) {\n    var excludeRect = excludeRects[i];\n    fragments = fragments.reduce(function (acc, fragment) {\n      var pieces = getLineFragment(fragment, excludeRect);\n      return acc.concat(pieces);\n    }, []);\n  };\n\n  for (var i = 0; i < excludeRects.length; i += 1) {\n    _loop(i);\n  }\n\n  return fragments;\n};\n\nvar generateLineRects = function generateLineRects(container, height) {\n  var excludeRects = container.excludeRects,\n      rect = _objectWithoutProperties(container, _excluded);\n\n  if (!excludeRects) return [rect];\n  var lineRects = [];\n  var maxY = Math.max.apply(Math, _toConsumableArray(excludeRects.map(function (r) {\n    return r.y + r.height;\n  })));\n  var currentRect = rect;\n\n  while (currentRect.y < maxY) {\n    var _partition3 = partition(currentRect, height),\n        _partition4 = _slicedToArray(_partition3, 2),\n        lineRect = _partition4[0],\n        rest = _partition4[1];\n\n    var lineRectFragments = getLineFragments(lineRect, excludeRects);\n    currentRect = rest;\n    lineRects.push.apply(lineRects, _toConsumableArray(lineRectFragments));\n  }\n\n  return [].concat(lineRects, [currentRect]);\n};\n\nvar ATTACHMENT_CODE$1 = \"\\uFFFC\"; // 65532\n\n/**\n * Remove attachment attribute if no char present\n *\n * @param line - Line\n * @returns Line\n */\n\nvar purgeAttachments = function purgeAttachments(line) {\n  var shouldPurge = !line.string.includes(ATTACHMENT_CODE$1);\n  if (!shouldPurge) return line;\n  var runs = line.runs.map(function (run) {\n    return omit('attachment', run);\n  });\n  return Object.assign({}, line, {\n    runs: runs\n  });\n};\n/**\n * Layout paragraphs inside rectangle\n *\n * @param rects - Rects\n * @param lines - Attributed strings\n * @param indent\n * @returns layout blocks\n */\n\n\nvar layoutLines = function layoutLines(rects, lines, indent) {\n  var rect = rects.shift();\n  var currentY = rect.y;\n  return lines.map(function (line, i) {\n    var _line$runs, _line$runs$;\n\n    var lineIndent = i === 0 ? indent : 0;\n    var style = ((_line$runs = line.runs) === null || _line$runs === void 0 ? void 0 : (_line$runs$ = _line$runs[0]) === null || _line$runs$ === void 0 ? void 0 : _line$runs$.attributes) || {};\n    var height$1 = Math.max(height(line), style.lineHeight);\n\n    if (currentY + height$1 > rect.y + rect.height && rects.length > 0) {\n      rect = rects.shift();\n      currentY = rect.y;\n    }\n\n    var newLine = {\n      string: line.string,\n      runs: line.runs,\n      box: {\n        x: rect.x + lineIndent,\n        y: currentY,\n        width: rect.width - lineIndent,\n        height: height$1\n      }\n    };\n    currentY += height$1;\n    return purgeAttachments(newLine);\n  });\n};\n/**\n * Performs line breaking and layout\n *\n * @param engines - Engines\n * @param options - Layout options\n */\n\n\nvar layoutParagraph = function layoutParagraph(engines) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  /**\n   * @param container - Container\n   * @param paragraph - Attributed string\n   * @returns Layout block\n   */\n  return function (container, paragraph) {\n    var _paragraph$runs, _paragraph$runs$, _paragraph$runs$$attr;\n\n    var height$1 = height(paragraph);\n    var indent = ((_paragraph$runs = paragraph.runs) === null || _paragraph$runs === void 0 ? void 0 : (_paragraph$runs$ = _paragraph$runs[0]) === null || _paragraph$runs$ === void 0 ? void 0 : (_paragraph$runs$$attr = _paragraph$runs$.attributes) === null || _paragraph$runs$$attr === void 0 ? void 0 : _paragraph$runs$$attr.indent) || 0;\n    var rects = generateLineRects(container, height$1);\n    var availableWidths = rects.map(function (r) {\n      return r.width;\n    });\n    availableWidths.unshift(availableWidths[0] - indent);\n    var lines = engines.linebreaker(options)(paragraph, availableWidths);\n    return layoutLines(rects, lines, indent);\n  };\n};\n/**\n * Slice block at given height\n *\n * @param height - Height\n * @param paragraph - Paragraph\n * @returns Sliced paragraph\n */\n\n\nvar sliceAtHeight = function sliceAtHeight(height, paragraph) {\n  var newBlock = [];\n  var counter = 0;\n\n  for (var i = 0; i < paragraph.length; i += 1) {\n    var line = paragraph[i];\n    counter += line.box.height;\n\n    if (counter < height) {\n      newBlock.push(line);\n    } else {\n      break;\n    }\n  }\n\n  return newBlock;\n};\n/**\n * Layout paragraphs inside container until it does not\n * fit anymore, performing line wrapping in the process.\n *\n * @param  engines - Engines\n * @param  options - Layout options\n * @param container - Container\n */\n\n\nvar typesetter = function typesetter(engines, options, container) {\n  /**\n   * @param attributedStrings - Attributed strings (paragraphs)\n   * @returns Paragraph blocks\n   */\n  return function (attributedStrings) {\n    var result = [];\n\n    var paragraphs = _toConsumableArray(attributedStrings);\n\n    var layout = layoutParagraph(engines, options);\n    var maxLines = isNil(container.maxLines) ? Infinity : container.maxLines;\n    var truncateEllipsis = container.truncateMode === 'ellipsis';\n    var linesCount = maxLines;\n    var paragraphRect = copy(container);\n    var nextParagraph = paragraphs.shift();\n\n    while (linesCount > 0 && nextParagraph) {\n      var paragraph = layout(paragraphRect, nextParagraph);\n      var slicedBlock = paragraph.slice(0, linesCount);\n      var linesHeight = height$2(slicedBlock);\n      var shouldTruncate = truncateEllipsis && paragraph.length !== slicedBlock.length;\n      linesCount -= slicedBlock.length;\n\n      if (paragraphRect.height >= linesHeight) {\n        result.push(shouldTruncate ? truncate(slicedBlock) : slicedBlock);\n        paragraphRect = crop(linesHeight, paragraphRect);\n        nextParagraph = paragraphs.shift();\n      } else {\n        result.push(truncate(sliceAtHeight(paragraphRect.height, slicedBlock)));\n        break;\n      }\n    }\n\n    return result;\n  };\n};\n/**\n * Get attributed string start value\n *\n * @param attributedString - Attributed string\n * @returns Start\n */\n\n\nvar start = function start(attributedString) {\n  var runs = attributedString.runs;\n  return runs.length === 0 ? 0 : runs[0].start;\n};\n/**\n * Get attributed string end value\n *\n * @param attributedString - Attributed string\n * @returns End\n */\n\n\nvar end = function end(attributedString) {\n  var runs = attributedString.runs;\n  return runs.length === 0 ? 0 : last(runs).end;\n};\n/**\n * Get attributed string length\n *\n * @param attributedString - Attributed string\n * @returns End\n */\n\n\nvar length$1 = function length$1(attributedString) {\n  return end(attributedString) - start(attributedString);\n};\n\nvar bidi$2 = bidiFactory();\n\nvar getBidiLevels$1 = function getBidiLevels$1(runs) {\n  return runs.reduce(function (acc, run) {\n    var length = run.end - run.start;\n    var levels = repeat(run.attributes.bidiLevel, length);\n    return acc.concat(levels);\n  }, []);\n};\n\nvar getReorderedIndices = function getReorderedIndices(string, segments) {\n  // Fill an array with indices\n  var indices = [];\n\n  for (var i = 0; i < string.length; i += 1) {\n    indices[i] = i;\n  } // Reverse each segment in order\n\n\n  segments.forEach(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        start = _ref2[0],\n        end = _ref2[1];\n\n    var slice = indices.slice(start, end + 1);\n\n    for (var _i = slice.length - 1; _i >= 0; _i -= 1) {\n      indices[end - _i] = slice[_i];\n    }\n  });\n  return indices;\n};\n\nvar getItemAtIndex = function getItemAtIndex(runs, objectName, index) {\n  for (var i = 0; i < runs.length; i += 1) {\n    var run = runs[i];\n    var updatedIndex = run.glyphIndices[index - run.start];\n\n    if (index >= run.start && index < run.end) {\n      return run[objectName][updatedIndex];\n    }\n  }\n\n  throw new Error(\"index \".concat(index, \" out of range\"));\n};\n\nvar reorderLine = function reorderLine(line) {\n  var _line$runs$2;\n\n  var levels = getBidiLevels$1(line.runs);\n  var direction = (_line$runs$2 = line.runs[0]) === null || _line$runs$2 === void 0 ? void 0 : _line$runs$2.attributes.direction;\n  var level = direction === 'rtl' ? 1 : 0;\n  var end = length$1(line) - 1;\n  var paragraphs = [{\n    start: 0,\n    end: end,\n    level: level\n  }];\n  var embeddingLevels = {\n    paragraphs: paragraphs,\n    levels: levels\n  };\n  var segments = bidi$2.getReorderSegments(line.string, embeddingLevels); // No need for bidi reordering\n\n  if (segments.length === 0) return line;\n  var indices = getReorderedIndices(line.string, segments);\n  var updatedString = bidi$2.getReorderedString(line.string, embeddingLevels);\n  var updatedRuns = line.runs.map(function (run) {\n    var selectedIndices = indices.slice(run.start, run.end);\n    var updatedGlyphs = [];\n    var updatedPositions = [];\n    var addedGlyphs = new Set();\n\n    for (var i = 0; i < selectedIndices.length; i += 1) {\n      var index = selectedIndices[i];\n      var glyph = getItemAtIndex(line.runs, 'glyphs', index);\n      if (addedGlyphs.has(glyph.id)) continue;\n      updatedGlyphs.push(glyph);\n      updatedPositions.push(getItemAtIndex(line.runs, 'positions', index));\n\n      if (glyph.isLigature) {\n        addedGlyphs.add(glyph.id);\n      }\n    }\n\n    return _objectSpread(_objectSpread({}, run), {}, {\n      glyphs: updatedGlyphs,\n      positions: updatedPositions\n    });\n  });\n  return {\n    box: line.box,\n    runs: updatedRuns,\n    string: updatedString\n  };\n};\n\nvar reorderParagraph = function reorderParagraph(paragraph) {\n  return paragraph.map(reorderLine);\n};\n/**\n * Perform bidi reordering\n *\n * @returns Reordered paragraphs\n */\n\n\nvar bidiReordering = function bidiReordering() {\n  /**\n   * @param paragraphs - Paragraphs\n   * @returns Reordered paragraphs\n   */\n  return function (paragraphs) {\n    return paragraphs.map(reorderParagraph);\n  };\n};\n\nvar DUMMY_CODEPOINT = 123;\n/**\n * Resolve string indices based on glyphs code points\n *\n * @param glyphs\n * @returns Glyph indices\n */\n\nvar resolve = function resolve() {\n  var glyphs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return glyphs.reduce(function (acc, glyph) {\n    var codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [DUMMY_CODEPOINT];\n    if (acc.length === 0) return codePoints.map(function () {\n      return 0;\n    });\n    var last = acc[acc.length - 1];\n    var next = codePoints.map(function () {\n      return last + 1;\n    });\n    return [].concat(_toConsumableArray(acc), _toConsumableArray(next));\n  }, []);\n};\n\nvar getCharacterSpacing = function getCharacterSpacing(run) {\n  var _run$attributes7;\n\n  return ((_run$attributes7 = run.attributes) === null || _run$attributes7 === void 0 ? void 0 : _run$attributes7.characterSpacing) || 0;\n};\n/**\n * Scale run positions\n *\n * @param  run\n * @param  positions\n * @returns Scaled positions\n */\n\n\nvar scalePositions = function scalePositions(run, positions) {\n  var runScale = scale(run);\n  var characterSpacing = getCharacterSpacing(run);\n  return positions.map(function (position, i) {\n    var isLast = i === positions.length;\n    var xSpacing = isLast ? 0 : characterSpacing;\n    return Object.assign({}, position, {\n      xAdvance: position.xAdvance * runScale + xSpacing,\n      yAdvance: position.yAdvance * runScale,\n      xOffset: position.xOffset * runScale,\n      yOffset: position.yOffset * runScale\n    });\n  });\n};\n/**\n * Create glyph run\n *\n * @param string string\n */\n\n\nvar layoutRun = function layoutRun(string) {\n  /**\n   * @param run - Run\n   * @returns Glyph run\n   */\n  return function (run) {\n    var start = run.start,\n        end = run.end,\n        _run$attributes8 = run.attributes,\n        attributes = _run$attributes8 === void 0 ? {} : _run$attributes8;\n    var font = attributes.font;\n    if (!font) return _objectSpread(_objectSpread({}, run), {}, {\n      glyphs: [],\n      glyphIndices: [],\n      positions: []\n    });\n    var runString = string.slice(start, end);\n    if (typeof font === 'string') throw new Error('Invalid font'); // passing LTR To force fontkit to not reverse the string\n\n    var glyphRun = font[0].layout(runString, undefined, undefined, undefined, 'ltr');\n    var positions = scalePositions(run, glyphRun.positions);\n    var glyphIndices = resolve(glyphRun.glyphs);\n\n    var result = _objectSpread(_objectSpread({}, run), {}, {\n      positions: positions,\n      glyphIndices: glyphIndices,\n      glyphs: glyphRun.glyphs\n    });\n\n    return result;\n  };\n};\n/**\n * Generate glyphs for single attributed string\n */\n\n\nvar generateGlyphs = function generateGlyphs() {\n  /**\n   * @param attributedString - Attributed string\n   * @returns Attributed string with glyphs\n   */\n  return function (attributedString) {\n    var runs = attributedString.runs.map(layoutRun(attributedString.string));\n    var res = Object.assign({}, attributedString, {\n      runs: runs\n    });\n    return res;\n  };\n};\n/**\n * Resolves yOffset for run\n *\n * @param run - Run\n * @returns Run\n */\n\n\nvar resolveRunYOffset = function resolveRunYOffset(run) {\n  var _run$attributes9, _run$attributes9$font, _run$attributes9$font2, _run$attributes10;\n\n  if (!run.positions) return run;\n  var unitsPerEm = ((_run$attributes9 = run.attributes) === null || _run$attributes9 === void 0 ? void 0 : (_run$attributes9$font = _run$attributes9.font) === null || _run$attributes9$font === void 0 ? void 0 : (_run$attributes9$font2 = _run$attributes9$font[0]) === null || _run$attributes9$font2 === void 0 ? void 0 : _run$attributes9$font2.unitsPerEm) || 0;\n  var yOffset = (((_run$attributes10 = run.attributes) === null || _run$attributes10 === void 0 ? void 0 : _run$attributes10.yOffset) || 0) * unitsPerEm;\n  var positions = run.positions.map(function (p) {\n    return Object.assign({}, p, {\n      yOffset: yOffset\n    });\n  });\n  return Object.assign({}, run, {\n    positions: positions\n  });\n};\n/**\n * Resolves yOffset for multiple paragraphs\n */\n\n\nvar resolveYOffset = function resolveYOffset() {\n  /**\n   * @param attributedString - Attributed string\n   * @returns Attributed string\n   */\n  return function (attributedString) {\n    var runs = attributedString.runs.map(resolveRunYOffset);\n    var res = Object.assign({}, attributedString, {\n      runs: runs\n    });\n    return res;\n  };\n};\n/**\n * Sort runs in ascending order\n *\n * @param runs\n * @returns Sorted runs\n */\n\n\nvar sort = function sort(runs) {\n  return runs.sort(function (a, b) {\n    return a.start - b.start || a.end - b.end;\n  });\n};\n/**\n * Is run empty (start === end)\n *\n * @param run - Run\n * @returns Is run empty\n */\n\n\nvar isEmpty = function isEmpty(run) {\n  return run.start === run.end;\n};\n/**\n * Sort points in ascending order\n * @param a - First point\n * @param b - Second point\n * @returns Sort order\n */\n\n\nvar sortPoints = function sortPoints(a, b) {\n  return a[1] - b[1] || a[3] - b[3];\n};\n/**\n * @param runs\n * @returns Points\n */\n\n\nvar generatePoints = function generatePoints(runs) {\n  var result = runs.reduce(function (acc, run, i) {\n    return acc.concat([['start', run.start, run.attributes, i], ['end', run.end, run.attributes, i]]);\n  }, []);\n  return result.sort(sortPoints);\n};\n/**\n * @param runs\n * @returns Merged runs\n */\n\n\nvar mergeRuns = function mergeRuns(runs) {\n  return runs.reduce(function (acc, run) {\n    var attributes = Object.assign({}, acc.attributes, run.attributes);\n    return Object.assign({}, run, {\n      attributes: attributes\n    });\n  }, {});\n};\n/**\n * @param runs\n * @returns Grouped runs\n */\n\n\nvar groupEmptyRuns = function groupEmptyRuns(runs) {\n  var groups = runs.reduce(function (acc, run) {\n    if (!acc[run.start]) acc[run.start] = [];\n    acc[run.start].push(run);\n    return acc;\n  }, []);\n  return Object.values(groups);\n};\n/**\n * @param runs\n * @returns Flattened runs\n */\n\n\nvar flattenEmptyRuns = function flattenEmptyRuns(runs) {\n  return groupEmptyRuns(runs).map(mergeRuns);\n};\n/**\n * @param runs\n * @returns Flattened runs\n */\n\n\nvar flattenRegularRuns = function flattenRegularRuns(runs) {\n  var res = [];\n  var points = generatePoints(runs);\n  var start = -1;\n  var attrs = {};\n  var stack = [];\n\n  for (var i = 0; i < points.length; i += 1) {\n    var _points$i = _slicedToArray(points[i], 3),\n        type = _points$i[0],\n        _offset = _points$i[1],\n        attributes = _points$i[2];\n\n    if (start !== -1 && start < _offset) {\n      res.push({\n        start: start,\n        end: _offset,\n        attributes: attrs,\n        glyphIndices: [],\n        glyphs: [],\n        positions: []\n      });\n    }\n\n    if (type === 'start') {\n      stack.push(attributes);\n      attrs = Object.assign({}, attrs, attributes);\n    } else {\n      attrs = {};\n\n      for (var j = 0; j < stack.length; j += 1) {\n        if (stack[j] === attributes) {\n          stack.splice(j--, 1);\n        } else {\n          attrs = Object.assign({}, attrs, stack[j]);\n        }\n      }\n    }\n\n    start = _offset;\n  }\n\n  return res;\n};\n/**\n * Flatten many runs\n *\n * @param runs\n * @returns Flattened runs\n */\n\n\nvar flatten = function flatten() {\n  var runs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var emptyRuns = flattenEmptyRuns(runs.filter(function (run) {\n    return isEmpty(run);\n  }));\n  var regularRuns = flattenRegularRuns(runs.filter(function (run) {\n    return !isEmpty(run);\n  }));\n  return sort(emptyRuns.concat(regularRuns));\n};\n/**\n * Returns empty attributed string\n *\n * @returns Empty attributed string\n */\n\n\nvar empty = function empty() {\n  return {\n    string: '',\n    runs: []\n  };\n};\n/**\n *\n * @param attributedString\n * @returns Attributed string without font\n */\n\n\nvar omitFont = function omitFont(attributedString) {\n  var runs = attributedString.runs.map(function (run) {\n    return omit('font', run);\n  });\n  return Object.assign({}, attributedString, {\n    runs: runs\n  });\n};\n/**\n * Performs font substitution and script itemization on attributed string\n *\n * @param engines - engines\n */\n\n\nvar preprocessRuns = function preprocessRuns(engines) {\n  /**\n   * @param attributedString - Attributed string\n   * @returns Processed attributed string\n   */\n  return function (attributedString) {\n    if (isNil(attributedString)) return empty();\n    var string = attributedString.string;\n    var fontSubstitution = engines.fontSubstitution,\n        scriptItemizer = engines.scriptItemizer,\n        bidi = engines.bidi;\n\n    var _omitFont = omitFont(attributedString),\n        omittedFontRuns = _omitFont.runs;\n\n    var _scriptItemizer = scriptItemizer()(attributedString),\n        itemizationRuns = _scriptItemizer.runs;\n\n    var _fontSubstitution = fontSubstitution()(attributedString),\n        substitutedRuns = _fontSubstitution.runs;\n\n    var _bidi = bidi()(attributedString),\n        bidiRuns = _bidi.runs;\n\n    var runs = bidiRuns.concat(substitutedRuns).concat(itemizationRuns).concat(omittedFontRuns);\n    return {\n      string: string,\n      runs: flatten(runs)\n    };\n  };\n};\n/**\n * Breaks attributed string into paragraphs\n */\n\n\nvar splitParagraphs = function splitParagraphs() {\n  /**\n   * @param attributedString - Attributed string\n   * @returns Paragraphs attributed strings\n   */\n  return function (attributedString) {\n    var paragraphs = [];\n    var start = 0;\n    var breakPoint = attributedString.string.indexOf('\\n') + 1;\n\n    while (breakPoint > 0) {\n      paragraphs.push(slice(start, breakPoint, attributedString));\n      start = breakPoint;\n      breakPoint = attributedString.string.indexOf('\\n', breakPoint) + 1;\n    }\n\n    if (start === 0) {\n      paragraphs.push(attributedString);\n    } else if (start < attributedString.string.length) {\n      paragraphs.push(slice(start, length$1(attributedString), attributedString));\n    }\n\n    return paragraphs;\n  };\n};\n/**\n * Return positions advance width\n *\n * @param positions - Positions\n * @returns {number} advance width\n */\n\n\nvar advanceWidth$2 = function advanceWidth$2(positions) {\n  return positions.reduce(function (acc, pos) {\n    return acc + (pos.xAdvance || 0);\n  }, 0);\n};\n/**\n * Return run advance width\n *\n * @param run - Run\n * @returns Advance width\n */\n\n\nvar advanceWidth$1 = function advanceWidth$1(run) {\n  return advanceWidth$2(run.positions || []);\n};\n/**\n * Returns attributed string advancewidth\n *\n * @param attributedString - Attributed string\n * @returns Advance width\n */\n\n\nvar advanceWidth = function advanceWidth(attributedString) {\n  var reducer = function reducer(acc, run) {\n    return acc + advanceWidth$1(run);\n  };\n\n  return attributedString.runs.reduce(reducer, 0);\n};\n\nvar WHITE_SPACES_CODE = 32;\n/**\n * Check if glyph is white space\n *\n * @param glyph - Glyph\n * @returns Whether glyph is white space\n * */\n\nvar isWhiteSpace = function isWhiteSpace(glyph) {\n  var codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [];\n  return codePoints.includes(WHITE_SPACES_CODE);\n};\n/**\n * Get white space leading positions\n *\n * @param run - Run\n * @returns White space leading positions\n */\n\n\nvar leadingPositions = function leadingPositions(run) {\n  var glyphs = run.glyphs || [];\n  var positions = run.positions || [];\n  var leadingWhitespaces = glyphs.findIndex(function (g) {\n    return !isWhiteSpace(g);\n  });\n  return positions.slice(0, leadingWhitespaces);\n};\n/**\n * Get run leading white space offset\n *\n * @param run - Run\n * @returns Leading white space offset\n */\n\n\nvar leadingOffset$1 = function leadingOffset$1(run) {\n  var positions = leadingPositions(run);\n  return positions.reduce(function (acc, pos) {\n    return acc + (pos.xAdvance || 0);\n  }, 0);\n};\n/**\n * Get attributed string leading white space offset\n *\n * @param attributedString - Attributed string\n * @returns Leading white space offset\n */\n\n\nvar leadingOffset = function leadingOffset(attributedString) {\n  var runs = attributedString.runs || [];\n  return leadingOffset$1(runs[0]);\n};\n/**\n * Get white space trailing positions\n *\n * @param run run\n * @returns White space trailing positions\n */\n\n\nvar trailingPositions = function trailingPositions(run) {\n  var glyphs = reverse(run.glyphs || []);\n  var positions = reverse(run.positions || []);\n  var leadingWhitespaces = glyphs.findIndex(function (g) {\n    return !isWhiteSpace(g);\n  });\n  return positions.slice(0, leadingWhitespaces);\n};\n/**\n * Get run trailing white space offset\n *\n * @param run - Run\n * @returns Trailing white space offset\n */\n\n\nvar trailingOffset$1 = function trailingOffset$1(run) {\n  var positions = trailingPositions(run);\n  return positions.reduce(function (acc, pos) {\n    return acc + (pos.xAdvance || 0);\n  }, 0);\n};\n/**\n * Get attributed string trailing white space offset\n *\n * @param attributedString - Attributed string\n * @returns Trailing white space offset\n */\n\n\nvar trailingOffset = function trailingOffset(attributedString) {\n  var runs = attributedString.runs || [];\n  return trailingOffset$1(last(runs));\n};\n/**\n * Drop last char of run\n *\n * @param run - Run\n * @returns Run without last char\n */\n\n\nvar dropLast$1 = function dropLast$1(run) {\n  return slice$1(0, run.end - run.start - 1, run);\n};\n/**\n * Drop last glyph\n *\n * @param attributedString - Attributed string\n * @returns Attributed string with new glyph\n */\n\n\nvar dropLast = function dropLast(attributedString) {\n  var string = dropLast$2(attributedString.string);\n  var runs = adjust(-1, dropLast$1, attributedString.runs);\n  return Object.assign({}, attributedString, {\n    string: string,\n    runs: runs\n  });\n};\n\nvar ALIGNMENT_FACTORS = {\n  center: 0.5,\n  right: 1\n};\n/**\n * Remove new line char at the end of line if present\n *\n * @param line\n * @returns Line\n */\n\nvar removeNewLine = function removeNewLine(line) {\n  return last(line.string) === '\\n' ? dropLast(line) : line;\n};\n\nvar getOverflowLeft = function getOverflowLeft(line) {\n  return leadingOffset(line) + (line.overflowLeft || 0);\n};\n\nvar getOverflowRight = function getOverflowRight(line) {\n  return trailingOffset(line) + (line.overflowRight || 0);\n};\n/**\n * Ignore whitespace at the start and end of a line for alignment\n *\n * @param line\n * @returns Line\n */\n\n\nvar adjustOverflow = function adjustOverflow(line) {\n  var overflowLeft = getOverflowLeft(line);\n  var overflowRight = getOverflowRight(line);\n  var x = line.box.x - overflowLeft;\n  var width = line.box.width + overflowLeft + overflowRight;\n  var box = Object.assign({}, line.box, {\n    x: x,\n    width: width\n  });\n  return Object.assign({}, line, {\n    box: box,\n    overflowLeft: overflowLeft,\n    overflowRight: overflowRight\n  });\n};\n/**\n * Performs line justification by calling appropiate engine\n *\n * @param engines - Engines\n * @param options - Layout options\n * @param align - Text align\n */\n\n\nvar justifyLine$1 = function justifyLine$1(engines, options, align) {\n  /**\n   * @param line - Line\n   * @returns Line\n   */\n  return function (line) {\n    var lineWidth = advanceWidth(line);\n    var alignFactor = ALIGNMENT_FACTORS[align] || 0;\n    var remainingWidth = Math.max(0, line.box.width - lineWidth);\n    var shouldJustify = align === 'justify' || lineWidth > line.box.width;\n    var x = line.box.x + remainingWidth * alignFactor;\n    var box = Object.assign({}, line.box, {\n      x: x\n    });\n    var newLine = Object.assign({}, line, {\n      box: box\n    });\n    return shouldJustify ? engines.justification(options)(newLine) : newLine;\n  };\n};\n\nvar finalizeLine = function finalizeLine(line) {\n  var lineAscent = 0;\n  var lineDescent = 0;\n  var lineHeight = 0;\n  var lineXAdvance = 0;\n  var runs = line.runs.map(function (run) {\n    var height = height$1(run);\n    var ascent = ascent$1(run);\n    var descent$1 = descent(run);\n    var xAdvance = advanceWidth$1(run);\n    lineHeight = Math.max(lineHeight, height);\n    lineAscent = Math.max(lineAscent, ascent);\n    lineDescent = Math.max(lineDescent, descent$1);\n    lineXAdvance += xAdvance;\n    return Object.assign({}, run, {\n      height: height,\n      ascent: ascent,\n      descent: descent$1,\n      xAdvance: xAdvance\n    });\n  });\n  return Object.assign({}, line, {\n    runs: runs,\n    height: lineHeight,\n    ascent: lineAscent,\n    descent: lineDescent,\n    xAdvance: lineXAdvance\n  });\n};\n/**\n * Finalize line by performing line justification\n * and text decoration (using appropiate engines)\n *\n * @param engines - Engines\n * @param options - Layout options\n */\n\n\nvar finalizeBlock = function finalizeBlock(engines, options) {\n  /**\n   * @param line - Line\n   * @param i - Line index\n   * @param lines - Total lines\n   * @returns Line\n   */\n  return function (line, index, lines) {\n    var _line$runs2, _line$runs2$;\n\n    var isLastFragment = index === lines.length - 1;\n    var style = ((_line$runs2 = line.runs) === null || _line$runs2 === void 0 ? void 0 : (_line$runs2$ = _line$runs2[0]) === null || _line$runs2$ === void 0 ? void 0 : _line$runs2$.attributes) || {};\n    var align = isLastFragment ? style.alignLastLine : style.align;\n    return compose(finalizeLine, engines.textDecoration(), justifyLine$1(engines, options, align), adjustOverflow, removeNewLine)(line);\n  };\n};\n/**\n * Finalize line block by performing line justification\n * and text decoration (using appropiate engines)\n *\n * @param engines - Engines\n * @param options - Layout options\n */\n\n\nvar finalizeFragments = function finalizeFragments(engines, options) {\n  /**\n   * @param paragraphs - Paragraphs\n   * @returns Paragraphs\n   */\n  return function (paragraphs) {\n    var blockFinalizer = finalizeBlock(engines, options);\n    return paragraphs.map(function (paragraph) {\n      return paragraph.map(blockFinalizer);\n    });\n  };\n};\n\nvar ATTACHMENT_CODE = 0xfffc; // 65532\n\nvar isReplaceGlyph = function isReplaceGlyph(glyph) {\n  return glyph.codePoints.includes(ATTACHMENT_CODE);\n};\n/**\n * Resolve attachments of run\n *\n * @param run\n * @returns Run\n */\n\n\nvar resolveRunAttachments = function resolveRunAttachments(run) {\n  var _run$attributes11;\n\n  if (!run.positions) return run;\n  var glyphs = run.glyphs || [];\n  var attachment = (_run$attributes11 = run.attributes) === null || _run$attributes11 === void 0 ? void 0 : _run$attributes11.attachment;\n  if (!attachment) return run;\n  var positions = run.positions.map(function (position, i) {\n    var glyph = glyphs[i];\n\n    if (attachment.width && isReplaceGlyph(glyph)) {\n      return Object.assign({}, position, {\n        xAdvance: attachment.width\n      });\n    }\n\n    return Object.assign({}, position);\n  });\n  return Object.assign({}, run, {\n    positions: positions\n  });\n};\n/**\n * Resolve attachments for multiple paragraphs\n */\n\n\nvar resolveAttachments = function resolveAttachments() {\n  /**\n   * @param attributedString - Attributed string\n   * @returns Attributed string\n   */\n  return function (attributedString) {\n    var runs = attributedString.runs.map(resolveRunAttachments);\n    var res = Object.assign({}, attributedString, {\n      runs: runs\n    });\n    return res;\n  };\n};\n/**\n * @param attributes - Attributes\n * @returns Attributes with defaults\n */\n\n\nvar applyAttributes = function applyAttributes(a) {\n  return {\n    align: a.align || (a.direction === 'rtl' ? 'right' : 'left'),\n    alignLastLine: a.alignLastLine || (a.align === 'justify' ? 'left' : a.align || 'left'),\n    attachment: a.attachment || null,\n    backgroundColor: a.backgroundColor || null,\n    bullet: a.bullet || null,\n    characterSpacing: a.characterSpacing || 0,\n    color: a.color || 'black',\n    direction: a.direction || 'ltr',\n    features: a.features || [],\n    fill: a.fill !== false,\n    font: a.font || [],\n    fontSize: a.fontSize || 12,\n    hangingPunctuation: a.hangingPunctuation || false,\n    hyphenationFactor: a.hyphenationFactor || 0,\n    indent: a.indent || 0,\n    justificationFactor: a.justificationFactor || 1,\n    lineHeight: a.lineHeight || null,\n    lineSpacing: a.lineSpacing || 0,\n    link: a.link || null,\n    marginLeft: a.marginLeft || a.margin || 0,\n    marginRight: a.marginRight || a.margin || 0,\n    opacity: a.opacity,\n    paddingTop: a.paddingTop || a.padding || 0,\n    paragraphSpacing: a.paragraphSpacing || 0,\n    script: a.script || null,\n    shrinkFactor: a.shrinkFactor || 0,\n    strike: a.strike || false,\n    strikeColor: a.strikeColor || a.color || 'black',\n    strikeStyle: a.strikeStyle || 'solid',\n    stroke: a.stroke || false,\n    underline: a.underline || false,\n    underlineColor: a.underlineColor || a.color || 'black',\n    underlineStyle: a.underlineStyle || 'solid',\n    verticalAlign: a.verticalAlign || null,\n    wordSpacing: a.wordSpacing || 0,\n    yOffset: a.yOffset || 0\n  };\n};\n/**\n * Apply default style to run\n *\n * @param run - Run\n * @returns Run with default styles\n */\n\n\nvar applyRunStyles = function applyRunStyles(run) {\n  var attributes = applyAttributes(run.attributes);\n  return Object.assign({}, run, {\n    attributes: attributes\n  });\n};\n/**\n * Apply default attributes for an attributed string\n */\n\n\nvar applyDefaultStyles = function applyDefaultStyles() {\n  return function (attributedString) {\n    var string = attributedString.string || '';\n    var runs = (attributedString.runs || []).map(applyRunStyles);\n    return {\n      string: string,\n      runs: runs\n    };\n  };\n};\n/**\n * Apply scaling and yOffset for verticalAlign 'sub' and 'super'.\n */\n\n\nvar verticalAlignment = function verticalAlignment() {\n  /**\n   * @param attributedString - Attributed string\n   * @returns Attributed string\n   */\n  return function (attributedString) {\n    attributedString.runs.forEach(function (run) {\n      var attributes = run.attributes;\n      var verticalAlign = attributes.verticalAlign;\n\n      if (verticalAlign === 'sub') {\n        attributes.yOffset = -0.2;\n      } else if (verticalAlign === 'super') {\n        attributes.yOffset = 0.4;\n      }\n    });\n    return attributedString;\n  };\n};\n\nvar bidi$1 = bidiFactory();\n/**\n * @param runs\n * @returns Bidi levels\n */\n\nvar getBidiLevels = function getBidiLevels(runs) {\n  return runs.reduce(function (acc, run) {\n    var length = run.end - run.start;\n    var levels = repeat(run.attributes.bidiLevel, length);\n    return acc.concat(levels);\n  }, []);\n};\n/**\n * Perform bidi mirroring\n */\n\n\nvar mirrorString = function mirrorString() {\n  /**\n   * @param attributedString - Attributed string\n   * @returns Attributed string\n   */\n  return function (attributedString) {\n    var levels = getBidiLevels(attributedString.runs);\n    var updatedString = '';\n    attributedString.string.split('').forEach(function (char, index) {\n      var isRTL = levels[index] % 2 === 1;\n      var mirroredChar = isRTL ? bidi$1.getMirroredCharacter(attributedString.string.charAt(index)) : null;\n      updatedString += mirroredChar || char;\n    });\n\n    var result = _objectSpread(_objectSpread({}, attributedString), {}, {\n      string: updatedString\n    });\n\n    return result;\n  };\n};\n/**\n * A LayoutEngine is the main object that performs text layout.\n * It accepts an AttributedString and a Container object\n * to layout text into, and uses several helper objects to perform\n * various layout tasks. These objects can be overridden to customize\n * layout behavior.\n */\n\n\nvar layoutEngine = function layoutEngine(engines) {\n  return function (attributedString, container) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var processParagraph = compose(resolveYOffset(), resolveAttachments(), verticalAlignment(), wrapWords(engines, options), generateGlyphs(), mirrorString(), preprocessRuns(engines));\n\n    var processParagraphs = function processParagraphs(paragraphs) {\n      return paragraphs.map(processParagraph);\n    };\n\n    return compose(finalizeFragments(engines, options), bidiReordering(), typesetter(engines, options, container), processParagraphs, splitParagraphs(), applyDefaultStyles())(attributedString);\n  };\n};\n\nvar bidi = bidiFactory();\n\nvar bidiEngine = function bidiEngine() {\n  /**\n   * @param attributedString - Attributed string\n   * @returns Attributed string\n   */\n  return function (attributedString) {\n    var _attributedString$run;\n\n    var string = attributedString.string;\n    var direction = (_attributedString$run = attributedString.runs[0]) === null || _attributedString$run === void 0 ? void 0 : _attributedString$run.attributes.direction;\n\n    var _bidi$getEmbeddingLev = bidi.getEmbeddingLevels(string, direction),\n        levels = _bidi$getEmbeddingLev.levels;\n\n    var lastLevel = null;\n    var lastIndex = 0;\n    var index = 0;\n    var runs = [];\n\n    for (var i = 0; i < levels.length; i += 1) {\n      var level = levels[i];\n\n      if (level !== lastLevel) {\n        if (lastLevel !== null) {\n          runs.push({\n            start: lastIndex,\n            end: index,\n            attributes: {\n              bidiLevel: lastLevel\n            }\n          });\n        }\n\n        lastIndex = index;\n        lastLevel = level;\n      }\n\n      index += 1;\n    }\n\n    if (lastIndex < string.length) {\n      runs.push({\n        start: lastIndex,\n        end: string.length,\n        attributes: {\n          bidiLevel: lastLevel\n        }\n      });\n    }\n\n    var result = {\n      string: string,\n      runs: runs\n    };\n    return result;\n  };\n};\n\nvar INFINITY = 10000;\n\nvar getNextBreakpoint = function getNextBreakpoint(subnodes, widths, lineNumber) {\n  var position = null;\n  var minimumBadness = Infinity;\n  var sum = {\n    width: 0,\n    stretch: 0,\n    shrink: 0\n  };\n  var lineLength = widths[Math.min(lineNumber, widths.length - 1)];\n\n  var calculateRatio = function calculateRatio(node) {\n    var stretch = 'stretch' in node ? node.stretch : null;\n\n    if (sum.width < lineLength) {\n      if (!stretch) return INFINITY;\n      return sum.stretch - stretch > 0 ? (lineLength - sum.width) / sum.stretch : INFINITY;\n    }\n\n    var shrink = 'shrink' in node ? node.shrink : null;\n\n    if (sum.width > lineLength) {\n      if (!shrink) return INFINITY;\n      return sum.shrink - shrink > 0 ? (lineLength - sum.width) / sum.shrink : INFINITY;\n    }\n\n    return 0;\n  };\n\n  for (var i = 0; i < subnodes.length; i += 1) {\n    var node = subnodes[i];\n\n    if (node.type === 'box') {\n      sum.width += node.width;\n    }\n\n    if (node.type === 'glue') {\n      sum.width += node.width;\n      sum.stretch += node.stretch;\n      sum.shrink += node.shrink;\n    }\n\n    if (sum.width - sum.shrink > lineLength) {\n      if (position === null) {\n        var j = i === 0 ? i + 1 : i;\n\n        while (j < subnodes.length && (subnodes[j].type === 'glue' || subnodes[j].type === 'penalty')) {\n          j++;\n        }\n\n        position = j - 1;\n      }\n\n      break;\n    }\n\n    if (node.type === 'penalty' || node.type === 'glue') {\n      var ratio = calculateRatio(node);\n      var penalty = node.type === 'penalty' ? node.penalty : 0;\n      var badness = 100 * Math.pow(Math.abs(ratio), 3) + penalty;\n\n      if (minimumBadness >= badness) {\n        position = i;\n        minimumBadness = badness;\n      }\n    }\n  }\n\n  return sum.width - sum.shrink > lineLength ? position : null;\n};\n\nvar applyBestFit = function applyBestFit(nodes, widths) {\n  var count = 0;\n  var lineNumber = 0;\n  var subnodes = nodes;\n  var breakpoints = [0];\n\n  while (subnodes.length > 0) {\n    var _breakpoint = getNextBreakpoint(subnodes, widths, lineNumber);\n\n    if (_breakpoint !== null) {\n      count += _breakpoint;\n      breakpoints.push(count);\n      subnodes = subnodes.slice(_breakpoint + 1, subnodes.length);\n      count++;\n      lineNumber++;\n    } else {\n      subnodes = [];\n    }\n  }\n\n  return breakpoints;\n};\n/* eslint-disable max-classes-per-file */\n\n\nvar LinkedListNode = /*#__PURE__*/_createClass(function LinkedListNode(data) {\n  _classCallCheck(this, LinkedListNode);\n\n  _defineProperty(this, \"data\", void 0);\n\n  _defineProperty(this, \"prev\", void 0);\n\n  _defineProperty(this, \"next\", void 0);\n\n  this.data = data;\n  this.prev = null;\n  this.next = null;\n});\n\nvar LinkedList = /*#__PURE__*/function () {\n  function LinkedList() {\n    _classCallCheck(this, LinkedList);\n\n    _defineProperty(this, \"head\", void 0);\n\n    _defineProperty(this, \"tail\", void 0);\n\n    _defineProperty(this, \"listSize\", void 0);\n\n    _defineProperty(this, \"listLength\", void 0);\n\n    this.head = null;\n    this.tail = null;\n    this.listSize = 0;\n    this.listLength = 0;\n  }\n\n  _createClass(LinkedList, [{\n    key: \"isLinked\",\n    value: function isLinked(node) {\n      return !(node && node.prev === null && node.next === null && this.tail !== node && this.head !== node || this.isEmpty());\n    }\n  }, {\n    key: \"size\",\n    value: function size() {\n      return this.listSize;\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this.listSize === 0;\n    }\n  }, {\n    key: \"first\",\n    value: function first() {\n      return this.head;\n    }\n  }, {\n    key: \"last\",\n    value: function last() {\n      return this.last;\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach(callback) {\n      var node = this.head;\n\n      while (node !== null) {\n        callback(node);\n        node = node.next;\n      }\n    }\n  }, {\n    key: \"at\",\n    value: function at(i) {\n      var node = this.head;\n      var index = 0;\n\n      if (i >= this.listLength || i < 0) {\n        return null;\n      }\n\n      while (node !== null) {\n        if (i === index) {\n          return node;\n        }\n\n        node = node.next;\n        index += 1;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"insertAfter\",\n    value: function insertAfter(node, newNode) {\n      if (!this.isLinked(node)) return this;\n      newNode.prev = node;\n      newNode.next = node.next;\n\n      if (node.next === null) {\n        this.tail = newNode;\n      } else {\n        node.next.prev = newNode;\n      }\n\n      node.next = newNode;\n      this.listSize += 1;\n      return this;\n    }\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(node, newNode) {\n      if (!this.isLinked(node)) return this;\n      newNode.prev = node.prev;\n      newNode.next = node;\n\n      if (node.prev === null) {\n        this.head = newNode;\n      } else {\n        node.prev.next = newNode;\n      }\n\n      node.prev = newNode;\n      this.listSize += 1;\n      return this;\n    }\n  }, {\n    key: \"push\",\n    value: function push(node) {\n      if (this.head === null) {\n        this.unshift(node);\n      } else {\n        this.insertAfter(this.tail, node);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(node) {\n      if (this.head === null) {\n        this.head = node;\n        this.tail = node;\n        node.prev = null;\n        node.next = null;\n        this.listSize += 1;\n      } else {\n        this.insertBefore(this.head, node);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(node) {\n      if (!this.isLinked(node)) return this;\n\n      if (node.prev === null) {\n        this.head = node.next;\n      } else {\n        node.prev.next = node.next;\n      }\n\n      if (node.next === null) {\n        this.tail = node.prev;\n      } else {\n        node.next.prev = node.prev;\n      }\n\n      this.listSize -= 1;\n      return this;\n    }\n  }]);\n\n  return LinkedList;\n}();\n/**\n * Licensed under the new BSD License.\n * Copyright 2009-2010, Bram Stein\n * All rights reserved.\n */\n\n\n_defineProperty(LinkedList, \"Node\", LinkedListNode);\n\nfunction breakpoint(position, demerits, line, fitnessClass, totals, previous) {\n  return {\n    position: position,\n    demerits: demerits,\n    line: line,\n    fitnessClass: fitnessClass,\n    totals: totals || {\n      width: 0,\n      stretch: 0,\n      shrink: 0\n    },\n    previous: previous\n  };\n}\n\nfunction computeCost(nodes, lineLengths, sum, end, active, currentLine) {\n  var width = sum.width - active.totals.width;\n  var stretch = 0;\n  var shrink = 0; // If the current line index is within the list of linelengths, use it, otherwise use\n  // the last line length of the list.\n\n  var lineLength = currentLine < lineLengths.length ? lineLengths[currentLine - 1] : lineLengths[lineLengths.length - 1];\n\n  if (nodes[end].type === 'penalty') {\n    width += nodes[end].width;\n  } // Calculate the stretch ratio\n\n\n  if (width < lineLength) {\n    stretch = sum.stretch - active.totals.stretch;\n\n    if (stretch > 0) {\n      return (lineLength - width) / stretch;\n    }\n\n    return linebreak.infinity;\n  } // Calculate the shrink ratio\n\n\n  if (width > lineLength) {\n    shrink = sum.shrink - active.totals.shrink;\n\n    if (shrink > 0) {\n      return (lineLength - width) / shrink;\n    }\n\n    return linebreak.infinity;\n  } // perfect match\n\n\n  return 0;\n} // Add width, stretch and shrink values from the current\n// break point up to the next box or forced penalty.\n\n\nfunction computeSum(nodes, sum, breakPointIndex) {\n  var result = {\n    width: sum.width,\n    stretch: sum.stretch,\n    shrink: sum.shrink\n  };\n\n  for (var i = breakPointIndex; i < nodes.length; i += 1) {\n    var node = nodes[i];\n\n    if (node.type === 'glue') {\n      result.width += node.width;\n      result.stretch += node.stretch;\n      result.shrink += node.shrink;\n    } else if (node.type === 'box' || node.type === 'penalty' && node.penalty === -linebreak.infinity && i > breakPointIndex) {\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction findBestBreakpoints(activeNodes) {\n  var breakpoints = [];\n  if (activeNodes.size() === 0) return [];\n  var tmp = {\n    data: {\n      demerits: Infinity\n    }\n  }; // Find the best active node (the one with the least total demerits.)\n\n  activeNodes.forEach(function (node) {\n    if (node.data.demerits < tmp.data.demerits) {\n      tmp = node;\n    }\n  });\n\n  while (tmp !== null) {\n    breakpoints.push(tmp.data.position);\n    tmp = tmp.data.previous;\n  }\n\n  return breakpoints.reverse();\n}\n/**\n * @param nodes\n * @param availableWidths\n * @param tolerance\n * @preserve Knuth and Plass line breaking algorithm in JavaScript\n */\n\n\nvar linebreak = function linebreak(nodes, availableWidths, tolerance) {\n  // Demerits are used as a way to penalize bad line breaks\n  //  - line: applied to each line, depending on how much spaces need to stretch or shrink\n  //  - flagged: applied when consecutive lines end in hyphenation\n  //  - fitness: algorithm groups lines into fitness classes based on how loose or tight the spacing is.\n  //             if a paragraph has consecutive lines from different fitness classes,\n  //             a fitness demerit is applied to maintain visual consistency.\n  var options = {\n    demerits: {\n      line: 10,\n      flagged: 100,\n      fitness: 3000\n    },\n    tolerance: tolerance || 3\n  };\n  var activeNodes = new LinkedList();\n  var sum = {\n    width: 0,\n    stretch: 0,\n    shrink: 0\n  };\n  var lineLengths = availableWidths; // Add an active node for the start of the paragraph.\n\n  activeNodes.push(new LinkedList.Node(breakpoint(0, 0, 0, 0, undefined, null))); // The main loop of the algorithm\n\n  function mainLoop(node, index, nodes) {\n    var active = activeNodes.first(); // The inner loop iterates through all the active nodes with line < currentLine and then\n    // breaks out to insert the new active node candidates before looking at the next active\n    // nodes for the next lines. The result of this is that the active node list is always\n    // sorted by line number.\n\n    while (active !== null) {\n      var currentLine = 0; // Candidates fo each fitness class\n\n      var candidates = [{\n        active: undefined,\n        demerits: Infinity\n      }, {\n        active: undefined,\n        demerits: Infinity\n      }, {\n        active: undefined,\n        demerits: Infinity\n      }, {\n        active: undefined,\n        demerits: Infinity\n      }]; // Iterate through the linked list of active nodes to find new potential active nodes and deactivate current active nodes.\n\n      while (active !== null) {\n        currentLine = active.data.line + 1;\n        var ratio = computeCost(nodes, lineLengths, sum, index, active.data, currentLine); // Deactive nodes when the distance between the current active node and the\n        // current node becomes too large (i.e. it exceeds the stretch limit and the stretch\n        // ratio becomes negative) or when the current node is a forced break (i.e. the end\n        // of the paragraph when we want to remove all active nodes, but possibly have a final\n        // candidate active node---if the paragraph can be set using the given tolerance value.)\n\n        if (ratio < -1 || node.type === 'penalty' && node.penalty === -linebreak.infinity) {\n          activeNodes.remove(active);\n        } // If the ratio is within the valid range of -1 <= ratio <= tolerance calculate the\n        // total demerits and record a candidate active node.\n\n\n        if (ratio >= -1 && ratio <= options.tolerance) {\n          var badness = 100 * Math.pow(Math.abs(ratio), 3);\n          var demerits = 0; // Positive penalty\n\n          if (node.type === 'penalty' && node.penalty >= 0) {\n            demerits = Math.pow(options.demerits.line + badness, 2) + Math.pow(node.penalty, 2); // Negative penalty but not a forced break\n          } else if (node.type === 'penalty' && node.penalty !== -linebreak.infinity) {\n            demerits = Math.pow(options.demerits.line + badness, 2) - Math.pow(node.penalty, 2); // All other cases\n          } else {\n            demerits = Math.pow(options.demerits.line + badness, 2);\n          }\n\n          if (node.type === 'penalty' && nodes[active.data.position].type === 'penalty') {\n            demerits += options.demerits.flagged * node.flagged * // @ts-expect-error node is penalty here\n            nodes[active.data.position].flagged;\n          } // Calculate the fitness class for this candidate active node.\n\n\n          var currentClass = void 0;\n\n          if (ratio < -0.5) {\n            currentClass = 0;\n          } else if (ratio <= 0.5) {\n            currentClass = 1;\n          } else if (ratio <= 1) {\n            currentClass = 2;\n          } else {\n            currentClass = 3;\n          } // Add a fitness penalty to the demerits if the fitness classes of two adjacent lines differ too much.\n\n\n          if (Math.abs(currentClass - active.data.fitnessClass) > 1) {\n            demerits += options.demerits.fitness;\n          } // Add the total demerits of the active node to get the total demerits of this candidate node.\n\n\n          demerits += active.data.demerits; // Only store the best candidate for each fitness class\n\n          if (demerits < candidates[currentClass].demerits) {\n            candidates[currentClass] = {\n              active: active,\n              demerits: demerits\n            };\n          }\n        }\n\n        active = active.next; // Stop iterating through active nodes to insert new candidate active nodes in the active list\n        // before moving on to the active nodes for the next line.\n        // TODO: The Knuth and Plass paper suggests a conditional for currentLine < j0. This means paragraphs\n        // with identical line lengths will not be sorted by line number. Find out if that is a desirable outcome.\n        // For now I left this out, as it only adds minimal overhead to the algorithm and keeping the active node\n        // list sorted has a higher priority.\n\n        if (active !== null && active.data.line >= currentLine) {\n          break;\n        }\n      }\n\n      var tmpSum = computeSum(nodes, sum, index);\n\n      for (var fitnessClass = 0; fitnessClass < candidates.length; fitnessClass += 1) {\n        var candidate = candidates[fitnessClass];\n        if (candidate.demerits === Infinity) continue;\n        var newNode = new LinkedList.Node(breakpoint(index, candidate.demerits, candidate.active.data.line + 1, fitnessClass, tmpSum, candidate.active));\n\n        if (active !== null) {\n          activeNodes.insertBefore(active, newNode);\n        } else {\n          activeNodes.push(newNode);\n        }\n      }\n    }\n  }\n\n  nodes.forEach(function (node, index, nodes) {\n    if (node.type === 'box') {\n      sum.width += node.width;\n      return;\n    }\n\n    if (node.type === 'glue') {\n      var precedesBox = index > 0 && nodes[index - 1].type === 'box';\n      if (precedesBox) mainLoop(node, index, nodes);\n      sum.width += node.width;\n      sum.stretch += node.stretch;\n      sum.shrink += node.shrink;\n      return;\n    }\n\n    if (node.type === 'penalty' && node.penalty !== linebreak.infinity) {\n      mainLoop(node, index, nodes);\n    }\n  });\n  return findBestBreakpoints(activeNodes);\n};\n\nlinebreak.infinity = 10000;\n\nlinebreak.glue = function (width, start, end, stretch, shrink) {\n  return {\n    type: 'glue',\n    start: start,\n    end: end,\n    width: width,\n    stretch: stretch,\n    shrink: shrink\n  };\n};\n\nlinebreak.box = function (width, start, end) {\n  var hyphenated = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  return {\n    type: 'box',\n    width: width,\n    start: start,\n    end: end,\n    hyphenated: hyphenated\n  };\n};\n\nlinebreak.penalty = function (width, penalty, flagged) {\n  return {\n    type: 'penalty',\n    width: width,\n    penalty: penalty,\n    flagged: flagged\n  };\n};\n/**\n * Add scalar to run\n *\n * @param index - Scalar\n * @param run - Run\n * @returns Added run\n */\n\n\nvar add = function add(index, run) {\n  var start = run.start + index;\n  var end = run.end + index;\n  return Object.assign({}, run, {\n    start: start,\n    end: end\n  });\n};\n/**\n * Get run length\n *\n * @param run - Run\n * @returns Length\n */\n\n\nvar length = function length(run) {\n  return run.end - run.start;\n};\n/**\n * Concats two runs into one\n *\n * @param runA - First run\n * @param runB - Second run\n * @returns Concatenated run\n */\n\n\nvar concat = function concat(runA, runB) {\n  var end = runA.end + length(runB);\n  var glyphs = (runA.glyphs || []).concat(runB.glyphs || []);\n  var positions = (runA.positions || []).concat(runB.positions || []);\n  var attributes = Object.assign({}, runA.attributes, runB.attributes);\n  var runAIndices = runA.glyphIndices || [];\n  var runALastIndex = last(runAIndices) || 0;\n  var runBIndices = (runB.glyphIndices || []).map(function (i) {\n    return i + runALastIndex + 1;\n  });\n  var glyphIndices = normalize(runAIndices.concat(runBIndices));\n  return Object.assign({}, runA, {\n    end: end,\n    glyphs: glyphs,\n    positions: positions,\n    attributes: attributes,\n    glyphIndices: glyphIndices\n  });\n};\n/**\n * Insert glyph to run in the given index\n *\n * @param index - Index\n * @param glyph - Glyph\n * @param run - Run\n * @returns Run with glyph\n */\n\n\nvar insertGlyph$1 = function insertGlyph$1(index, glyph, run) {\n  if (!glyph) return run; // Split resolves ligature splitting in case new glyph breaks some\n\n  var leadingRun = slice$1(0, index, run);\n  var trailingRun = slice$1(index, Infinity, run);\n  return concat(append$1(glyph, leadingRun), trailingRun);\n};\n/**\n * Insert either glyph or code point to run in the given index\n *\n * @param index - Index\n * @param value - Glyph or codePoint\n * @param run - Run\n * @returns Run with glyph\n */\n\n\nvar insert = function insert(index, value, run) {\n  var font = getFont(run);\n  var glyph = isNumber(value) ? fromCodePoint(value, font) : value;\n  return insertGlyph$1(index, glyph, run);\n};\n/**\n * Get run index at char index\n *\n * @param index - Char index\n * @param attributedString - Attributed string\n * @returns Run index\n */\n\n\nvar runIndexAt = function runIndexAt(index, attributedString) {\n  return runIndexAt$1(index, attributedString.runs);\n};\n/**\n * Insert glyph into attributed string\n *\n * @param index - Index\n * @param glyph - Glyph or code point\n * @param attributedString - Attributed string\n * @returns Attributed string with new glyph\n */\n\n\nvar insertGlyph = function insertGlyph(index, glyph, attributedString) {\n  var runIndex = runIndexAt(index, attributedString); // Add glyph to the end if run index invalid\n\n  if (runIndex === -1) return append(glyph, attributedString);\n  var codePoints = [glyph];\n  var string = attributedString.string.slice(0, index) + stringFromCodePoints(codePoints) + attributedString.string.slice(index);\n  var runs = attributedString.runs.map(function (run, i) {\n    if (i === runIndex) return insert(index - run.start, glyph, run);\n    if (i > runIndex) return add(codePoints.length, run);\n    return run;\n  });\n  return Object.assign({}, attributedString, {\n    string: string,\n    runs: runs\n  });\n};\n/**\n * Advance width between two string indices\n *\n * @param start - Glyph index\n * @param end - Glyph index\n * @param run - Run\n * @returns Advanced width run\n */\n\n\nvar advanceWidthBetween$1 = function advanceWidthBetween$1(start, end, run) {\n  var runStart = run.start || 0;\n  var glyphStartIndex = Math.max(0, glyphIndexAt(start - runStart, run));\n  var glyphEndIndex = Math.max(0, glyphIndexAt(end - runStart, run));\n  var positions = (run.positions || []).slice(glyphStartIndex, glyphEndIndex);\n  return advanceWidth$2(positions);\n};\n/**\n * Advance width between start and end\n * Does not consider ligature splitting for the moment.\n * Check performance impact on supporting this\n *\n * @param start - Start offset\n * @param end - End offset\n * @param attributedString\n * @returns Advance width\n */\n\n\nvar advanceWidthBetween = function advanceWidthBetween(start, end, attributedString) {\n  var runs = filter(start, end, attributedString.runs);\n  return runs.reduce(function (acc, run) {\n    return acc + advanceWidthBetween$1(start, end, run);\n  }, 0);\n};\n\nvar HYPHEN = 0x002d;\nvar TOLERANCE_STEPS = 5;\nvar TOLERANCE_LIMIT = 50;\nvar opts = {\n  width: 3,\n  stretch: 6,\n  shrink: 9\n};\n/**\n * Slice attributed string to many lines\n *\n * @param attributedString - Attributed string\n * @param nodes\n * @param breaks\n * @returns Attributed strings\n */\n\nvar breakLines = function breakLines(attributedString, nodes, breaks) {\n  var start = 0;\n  var end = null;\n  var lines = breaks.reduce(function (acc, breakPoint) {\n    var node = nodes[breakPoint];\n    var prevNode = nodes[breakPoint - 1]; // Last breakpoint corresponds to K&P mandatory final glue\n\n    if (breakPoint === nodes.length - 1) return acc;\n    var line;\n\n    if (node.type === 'penalty') {\n      // @ts-expect-error penalty node will always preceed box or glue node\n      end = prevNode.end;\n      line = slice(start, end, attributedString);\n      line = insertGlyph(line.string.length, HYPHEN, line);\n    } else {\n      end = node.end;\n      line = slice(start, end, attributedString);\n    }\n\n    start = end;\n    return [].concat(_toConsumableArray(acc), [line]);\n  }, []); // Last line\n\n  lines.push(slice(start, attributedString.string.length, attributedString));\n  return lines;\n};\n/**\n * Return Knuth & Plass nodes based on line and previously calculated syllables\n *\n * @param attributedString - Attributed string\n * @param attributes - Attributes\n * @param options - Layout options\n * @returns ?\n */\n\n\nvar getNodes = function getNodes(attributedString, _ref3, options) {\n  var align = _ref3.align;\n  var start = 0;\n  var hyphenWidth = 5;\n  var syllables = attributedString.syllables;\n  var hyphenPenalty = options.hyphenationPenalty || (align === 'justify' ? 100 : 600);\n  var result = syllables.reduce(function (acc, s, index) {\n    var width = advanceWidthBetween(start, start + s.length, attributedString);\n\n    if (s.trim() === '') {\n      var stretch = width * opts.width / opts.stretch;\n      var shrink = width * opts.width / opts.shrink;\n\n      var _end = start + s.length; // Add glue node. Glue nodes are used to fill the space between words.\n\n\n      acc.push(linebreak.glue(width, start, _end, stretch, shrink));\n    } else {\n      var hyphenated = syllables[index + 1] !== ' ';\n\n      var _end2 = start + s.length; // Add box node. Box nodes are used to represent words.\n\n\n      acc.push(linebreak.box(width, start, _end2, hyphenated));\n\n      if (syllables[index + 1] && hyphenated) {\n        // Add penalty node. Penalty nodes are used to represent hyphenation points.\n        acc.push(linebreak.penalty(hyphenWidth, hyphenPenalty, 1));\n      }\n    }\n\n    start += s.length;\n    return acc;\n  }, []); // Add mandatory final glue\n\n  result.push(linebreak.glue(0, start, start, linebreak.infinity, 0));\n  result.push(linebreak.penalty(0, -linebreak.infinity, 1));\n  return result;\n};\n/**\n * @param attributedString - Attributed string\n * @returns Attributes\n */\n\n\nvar getAttributes = function getAttributes(attributedString) {\n  var _attributedString$run2, _attributedString$run3;\n\n  return ((_attributedString$run2 = attributedString.runs) === null || _attributedString$run2 === void 0 ? void 0 : (_attributedString$run3 = _attributedString$run2[0]) === null || _attributedString$run3 === void 0 ? void 0 : _attributedString$run3.attributes) || {};\n};\n/**\n * Performs Knuth & Plass line breaking algorithm\n * Fallbacks to best fit algorithm if latter not successful\n *\n * @param options - Layout options\n */\n\n\nvar linebreaker = function linebreaker(options) {\n  /**\n   * @param attributedString - Attributed string\n   * @param availableWidths - Available widths\n   * @returns Attributed string\n   */\n  return function (attributedString, availableWidths) {\n    var tolerance = options.tolerance || 4;\n    var attributes = getAttributes(attributedString);\n    var nodes = getNodes(attributedString, attributes, options);\n    var breaks = linebreak(nodes, availableWidths, tolerance); // Try again with a higher tolerance if the line breaking failed.\n\n    while (breaks.length === 0 && tolerance < TOLERANCE_LIMIT) {\n      tolerance += TOLERANCE_STEPS;\n      breaks = linebreak(nodes, availableWidths, tolerance);\n    }\n\n    if (breaks.length === 0 || breaks.length === 1 && breaks[0] === 0) {\n      breaks = applyBestFit(nodes, availableWidths);\n    }\n\n    return breakLines(attributedString, nodes, breaks.slice(1));\n  };\n};\n\nvar Direction;\n\n(function (Direction) {\n  Direction[Direction[\"GROW\"] = 0] = \"GROW\";\n  Direction[Direction[\"SHRINK\"] = 1] = \"SHRINK\";\n})(Direction || (Direction = {}));\n\nvar WHITESPACE_PRIORITY = 1;\nvar LETTER_PRIORITY = 2;\nvar EXPAND_WHITESPACE_FACTOR = {\n  before: 0.5,\n  after: 0.5,\n  priority: WHITESPACE_PRIORITY,\n  unconstrained: false\n};\nvar EXPAND_CHAR_FACTOR = {\n  before: 0.14453125,\n  // 37/256\n  after: 0.14453125,\n  priority: LETTER_PRIORITY,\n  unconstrained: false\n};\nvar SHRINK_WHITESPACE_FACTOR = {\n  before: -0.04296875,\n  // -11/256\n  after: -0.04296875,\n  priority: WHITESPACE_PRIORITY,\n  unconstrained: false\n};\nvar SHRINK_CHAR_FACTOR = {\n  before: -0.04296875,\n  after: -0.04296875,\n  priority: LETTER_PRIORITY,\n  unconstrained: false\n};\n\nvar getCharFactor = function getCharFactor(direction, options) {\n  var expandCharFactor = options.expandCharFactor || {};\n  var shrinkCharFactor = options.shrinkCharFactor || {};\n  return direction === Direction.GROW ? Object.assign({}, EXPAND_CHAR_FACTOR, expandCharFactor) : Object.assign({}, SHRINK_CHAR_FACTOR, shrinkCharFactor);\n};\n\nvar getWhitespaceFactor = function getWhitespaceFactor(direction, options) {\n  var expandWhitespaceFactor = options.expandWhitespaceFactor || {};\n  var shrinkWhitespaceFactor = options.shrinkWhitespaceFactor || {};\n  return direction === Direction.GROW ? Object.assign({}, EXPAND_WHITESPACE_FACTOR, expandWhitespaceFactor) : Object.assign({}, SHRINK_WHITESPACE_FACTOR, shrinkWhitespaceFactor);\n};\n\nvar factor = function factor(direction, options) {\n  return function (glyphs) {\n    var charFactor = getCharFactor(direction, options);\n    var whitespaceFactor = getWhitespaceFactor(direction, options);\n    var factors = [];\n\n    for (var index = 0; index < glyphs.length; index += 1) {\n      var f = void 0;\n      var glyph = glyphs[index];\n\n      if (isWhiteSpace(glyph)) {\n        f = Object.assign({}, whitespaceFactor);\n\n        if (index === glyphs.length - 1) {\n          f.before = 0;\n\n          if (index > 0) {\n            factors[index - 1].after = 0;\n          }\n        }\n      } else if (glyph.isMark && index > 0) {\n        f = Object.assign({}, factors[index - 1]);\n        f.before = 0;\n        factors[index - 1].after = 0;\n      } else {\n        f = Object.assign({}, charFactor);\n      }\n\n      factors.push(f);\n    }\n\n    return factors;\n  };\n};\n\nvar getFactors = function getFactors(gap, line, options) {\n  var direction = gap > 0 ? Direction.GROW : Direction.SHRINK;\n  var getFactor = factor(direction, options);\n  var factors = line.runs.reduce(function (acc, run) {\n    return acc.concat(getFactor(run.glyphs));\n  }, []);\n  factors[0].before = 0;\n  factors[factors.length - 1].after = 0;\n  return factors;\n};\n\nvar KASHIDA_PRIORITY = 0;\nvar NULL_PRIORITY = 3;\n\nvar getDistances = function getDistances(gap, factors) {\n  var total = 0;\n  var priorities = [];\n  var unconstrained = [];\n\n  for (var _priority = KASHIDA_PRIORITY; _priority <= NULL_PRIORITY; _priority += 1) {\n    priorities[_priority] = unconstrained[_priority] = 0;\n  } // sum the factors at each priority\n\n\n  for (var j = 0; j < factors.length; j += 1) {\n    var f = factors[j];\n    var sum = f.before + f.after;\n    total += sum;\n    priorities[f.priority] += sum;\n\n    if (f.unconstrained) {\n      unconstrained[f.priority] += sum;\n    }\n  } // choose the priorities that need to be applied\n\n\n  var highestPriority = -1;\n  var highestPrioritySum = 0;\n  var remainingGap = gap;\n  var priority;\n\n  for (priority = KASHIDA_PRIORITY; priority <= NULL_PRIORITY; priority += 1) {\n    var prioritySum = priorities[priority];\n\n    if (prioritySum !== 0) {\n      if (highestPriority === -1) {\n        highestPriority = priority;\n        highestPrioritySum = prioritySum;\n      } // if this priority covers the remaining gap, we're done\n\n\n      if (Math.abs(remainingGap) <= Math.abs(prioritySum)) {\n        priorities[priority] = remainingGap / prioritySum;\n        unconstrained[priority] = 0;\n        remainingGap = 0;\n        break;\n      } // mark that we need to use 100% of the adjustment from\n      // this priority, and subtract the space that it consumes\n\n\n      priorities[priority] = 1;\n      remainingGap -= prioritySum; // if this priority has unconstrained glyphs, let them consume the remaining space\n\n      if (unconstrained[priority] !== 0) {\n        unconstrained[priority] = remainingGap / unconstrained[priority];\n        remainingGap = 0;\n        break;\n      }\n    }\n  } // zero out remaining priorities (if any)\n\n\n  for (var p = priority + 1; p <= NULL_PRIORITY; p += 1) {\n    priorities[p] = 0;\n    unconstrained[p] = 0;\n  } // if there is still space left over, assign it to the highest priority that we saw.\n  // this violates their factors, but it only happens in extreme cases\n\n\n  if (remainingGap > 0 && highestPriority > -1) {\n    priorities[highestPriority] = (highestPrioritySum + (gap - total)) / highestPrioritySum;\n  } // create and return an array of distances to add to each glyph's advance\n\n\n  var distances = [];\n\n  for (var index = 0; index < factors.length; index += 1) {\n    // the distance to add to this glyph is the sum of the space to add\n    // after this glyph, and the space to add before the next glyph\n    var _f = factors[index];\n    var next = factors[index + 1];\n    var dist = _f.after * priorities[_f.priority];\n\n    if (next) {\n      dist += next.before * priorities[next.priority];\n    } // if this glyph is unconstrained, add the unconstrained distance as well\n\n\n    if (_f.unconstrained) {\n      dist += _f.after * unconstrained[_f.priority];\n\n      if (next) {\n        dist += next.before * unconstrained[next.priority];\n      }\n    }\n\n    distances.push(dist);\n  }\n\n  return distances;\n};\n/**\n * Adjust run positions by given distances\n *\n * @param distances\n * @param line\n * @returns Line\n */\n\n\nvar justifyLine = function justifyLine(distances, line) {\n  var index = 0;\n\n  var _iterator = _createForOfIteratorHelper(line.runs),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var run = _step.value;\n\n      var _iterator2 = _createForOfIteratorHelper(run.positions),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var position = _step2.value;\n          position.xAdvance += distances[index++];\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return line;\n};\n/**\n * A JustificationEngine is used by a Typesetter to perform line fragment\n * justification. This implementation is based on a description of Apple's\n * justification algorithm from a PDF in the Apple Font Tools package.\n *\n * @param options - Layout options\n */\n\n\nvar justification = function justification(options) {\n  /**\n   * @param line\n   * @returns Line\n   */\n  return function (line) {\n    var gap = line.box.width - advanceWidth(line);\n    if (gap === 0) return line; // Exact fit\n\n    var factors = getFactors(gap, line, options);\n    var distances = getDistances(gap, factors);\n    return justifyLine(distances, line);\n  };\n};\n/**\n * Returns attributed string ascent\n *\n * @param attributedString - Attributed string\n * @returns Ascent\n */\n\n\nvar ascent = function ascent(attributedString) {\n  var reducer = function reducer(acc, run) {\n    return Math.max(acc, ascent$1(run));\n  };\n\n  return attributedString.runs.reduce(reducer, 0);\n}; // The base font size used for calculating underline thickness.\n\n\nvar BASE_FONT_SIZE = 12;\n/**\n * A TextDecorationEngine is used by a Typesetter to generate\n * DecorationLines for a line fragment, including underlines\n * and strikes.\n */\n\nvar textDecoration = function textDecoration() {\n  return function (line) {\n    var x = line.overflowLeft || 0;\n    var overflowRight = line.overflowRight || 0;\n    var maxX = advanceWidth(line) - overflowRight;\n    line.decorationLines = [];\n\n    for (var i = 0; i < line.runs.length; i += 1) {\n      var run = line.runs[i];\n      var width = Math.min(maxX - x, advanceWidth$1(run));\n      var thickness = Math.max(0.5, Math.floor(run.attributes.fontSize / BASE_FONT_SIZE));\n\n      if (run.attributes.underline) {\n        var rect = {\n          x: x,\n          y: ascent(line) + thickness * 2,\n          width: width,\n          height: thickness\n        };\n        var decorationLine = {\n          rect: rect,\n          opacity: run.attributes.opacity,\n          color: run.attributes.underlineColor || 'black',\n          style: run.attributes.underlineStyle || 'solid'\n        };\n        line.decorationLines.push(decorationLine);\n      }\n\n      if (run.attributes.strike) {\n        var y = ascent(line) - ascent$1(run) / 3;\n        var _rect = {\n          x: x,\n          y: y,\n          width: width,\n          height: thickness\n        };\n        var _decorationLine = {\n          rect: _rect,\n          opacity: run.attributes.opacity,\n          color: run.attributes.strikeColor || 'black',\n          style: run.attributes.strikeStyle || 'solid'\n        };\n        line.decorationLines.push(_decorationLine);\n      }\n\n      x += width;\n    }\n\n    return line;\n  };\n};\n\nvar ignoredScripts = ['Common', 'Inherited', 'Unknown'];\n/**\n * Resolves unicode script in runs, grouping equal runs together\n */\n\nvar scriptItemizer = function scriptItemizer() {\n  /**\n   * @param attributedString - Attributed string\n   * @returns Attributed string\n   */\n  return function (attributedString) {\n    var string = attributedString.string;\n    var lastScript = 'Unknown';\n    var lastIndex = 0;\n    var index = 0;\n    var runs = [];\n    if (!string) return empty();\n\n    for (var i = 0; i < string.length; i += 1) {\n      var char = string[i];\n      var codePoint = char.codePointAt(0);\n      var script = unicode.getScript(codePoint);\n\n      if (script !== lastScript && !ignoredScripts.includes(script)) {\n        if (lastScript !== 'Unknown') {\n          runs.push({\n            start: lastIndex,\n            end: index,\n            attributes: {\n              script: lastScript\n            }\n          });\n        }\n\n        lastIndex = index;\n        lastScript = script;\n      }\n\n      index += char.length;\n    }\n\n    if (lastIndex < string.length) {\n      runs.push({\n        start: lastIndex,\n        end: string.length,\n        attributes: {\n          script: lastScript\n        }\n      });\n    }\n\n    var result = {\n      string: string,\n      runs: runs\n    };\n    return result;\n  };\n};\n\nvar SOFT_HYPHEN = \"\\xAD\";\nvar hyphenator = hyphen(pattern);\n/**\n * @param word\n * @returns Word parts\n */\n\nvar splitHyphen = function splitHyphen(word) {\n  return word.split(SOFT_HYPHEN);\n};\n\nvar cache = {};\n/**\n * @param word\n * @returns Word parts\n */\n\nvar getParts = function getParts(word) {\n  var base = word.includes(SOFT_HYPHEN) ? word : hyphenator(word);\n  return splitHyphen(base);\n};\n\nvar wordHyphenation = function wordHyphenation() {\n  /**\n   * @param word - Word\n   * @returns Word parts\n   */\n  return function (word) {\n    var cacheKey = \"_\".concat(word);\n    if (isNil(word)) return [];\n    if (cache[cacheKey]) return cache[cacheKey];\n    cache[cacheKey] = getParts(word);\n    return cache[cacheKey];\n  };\n};\n\nvar IGNORED_CODE_POINTS = [173];\n\nvar getFontSize = function getFontSize(run) {\n  return run.attributes.fontSize || 12;\n};\n\nvar pickFontFromFontStack = function pickFontFromFontStack(codePoint, fontStack, lastFont) {\n  var fontStackWithFallback = [].concat(_toConsumableArray(fontStack), [lastFont]);\n\n  for (var i = 0; i < fontStackWithFallback.length; i += 1) {\n    var font = fontStackWithFallback[i];\n\n    if (!IGNORED_CODE_POINTS.includes(codePoint) && font && font.hasGlyphForCodePoint && font.hasGlyphForCodePoint(codePoint)) {\n      return font;\n    }\n  }\n\n  return fontStack.at(-1);\n};\n\nvar fontSubstitution = function fontSubstitution() {\n  return function (_ref4) {\n    var string = _ref4.string,\n        runs = _ref4.runs;\n    var lastFont = null;\n    var lastFontSize = null;\n    var lastIndex = 0;\n    var index = 0;\n    var res = [];\n\n    for (var i = 0; i < runs.length; i += 1) {\n      var run = runs[i];\n\n      if (string.length === 0) {\n        res.push({\n          start: 0,\n          end: 0,\n          attributes: {\n            font: run.attributes.font\n          }\n        });\n        break;\n      }\n\n      var chars = string.slice(run.start, run.end);\n\n      for (var j = 0; j < chars.length; j += 1) {\n        var char = chars[j];\n        var codePoint = char.codePointAt(0); // If the default font does not have a glyph and the fallback font does, we use it\n\n        var font = pickFontFromFontStack(codePoint, run.attributes.font, lastFont);\n        var fontSize = getFontSize(run); // If anything that would impact res has changed, update it\n\n        if (font !== lastFont || fontSize !== lastFontSize || font.unitsPerEm !== lastFont.unitsPerEm) {\n          if (lastFont) {\n            res.push({\n              start: lastIndex,\n              end: index,\n              attributes: {\n                font: [lastFont],\n                scale: lastFontSize / lastFont.unitsPerEm\n              }\n            });\n          }\n\n          lastFont = font;\n          lastFontSize = fontSize;\n          lastIndex = index;\n        }\n\n        index += char.length;\n      }\n    }\n\n    if (lastIndex < string.length) {\n      var _fontSize = getFontSize(last(runs));\n\n      res.push({\n        start: lastIndex,\n        end: string.length,\n        attributes: {\n          font: [lastFont],\n          scale: _fontSize / lastFont.unitsPerEm\n        }\n      });\n    }\n\n    return {\n      string: string,\n      runs: res\n    };\n  };\n};\n\nexport { bidiEngine as bidi, layoutEngine as default, fontSubstitution, fromFragments, justification, linebreaker, scriptItemizer, textDecoration, wordHyphenation };","map":{"version":3,"sources":["C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/@react-pdf/textkit/lib/textkit.js"],"names":["isNil","last","repeat","reverse","dropLast","dropLast$2","adjust","compose","bidiFactory","unicode","hyphen","pattern","fromFragments","fragments","offset","string","runs","forEach","fragment","push","start","end","length","attributes","defaultHyphenationEngine","word","wrapWords","engines","options","attributedString","syllables","hyphenateWord","hyphenationCallback","wordHyphenation","i","run","words","slice","split","filter","Boolean","j","parts","join","result","copy","rect","Object","assign","partition","height","a","b","y","crop","height$2","paragraph","reduce","acc","block","box","calculateScale","fontSize","font","unitsPerEm","scale","index","glyphIndices","value","getFont","slice$2","glyph","codePoints","String","fromCodePoint","layout","undefined","glyphs","glyphIndexAt","normalize","array","head","map","slice$1","runScale","startIndex","endIndex","startGlyph","endGlyph","startOffset","startGlyphs","Infinity","endOffset","endGlyphs","sliceStart","Math","min","glyphPosition","g","xAdvance","advanceWidth","yAdvance","xOffset","yOffset","startPositions","positions","endPositions","flat","runIndexAt$1","findIndex","max","subtract","sliceRuns","sliceFirstRun","sliceLastRun","isFirst","isLast","filteredRuns","slicedRuns","findCharIndex","search","findLastCharIndex","match","lastIndexOf","trim","empty$1","isNumber","appendIndices","indices","lastIndex","newIndices","Array","fill","concat","glyphForCodePoint","appendGlyph","glyphLength","append$1","stringFromCodePoints","append","codePointsString","firstRuns","lastRun","ELLIPSIS_UNICODE","ELLIPSIS_STRING","fromCharCode","getEllipsisCodePoint","encode","parseInt","truncate","codePoint","lastBlock","omit","ascent$1","attachment","attachmentHeight","fontAscent","ascent","descent","fontDescent","lineGap","height$1","lineHeight","reducer","intersects","x","num1","width","num2","getLineFragment","lineRect","excludeRect","eStart","eEnd","lStart","lEnd","r","getLineFragments","excludeRects","pieces","generateLineRects","container","lineRects","maxY","currentRect","rest","lineRectFragments","ATTACHMENT_CODE$1","purgeAttachments","line","shouldPurge","includes","layoutLines","rects","lines","indent","shift","currentY","lineIndent","style","newLine","layoutParagraph","availableWidths","unshift","linebreaker","sliceAtHeight","newBlock","counter","typesetter","attributedStrings","paragraphs","maxLines","truncateEllipsis","truncateMode","linesCount","paragraphRect","nextParagraph","slicedBlock","linesHeight","shouldTruncate","length$1","bidi$2","getBidiLevels$1","levels","bidiLevel","getReorderedIndices","segments","getItemAtIndex","objectName","updatedIndex","Error","reorderLine","direction","level","embeddingLevels","getReorderSegments","updatedString","getReorderedString","updatedRuns","selectedIndices","updatedGlyphs","updatedPositions","addedGlyphs","Set","has","id","isLigature","add","reorderParagraph","bidiReordering","DUMMY_CODEPOINT","resolve","next","getCharacterSpacing","characterSpacing","scalePositions","position","xSpacing","layoutRun","runString","glyphRun","generateGlyphs","res","resolveRunYOffset","p","resolveYOffset","sort","isEmpty","sortPoints","generatePoints","mergeRuns","groupEmptyRuns","groups","values","flattenEmptyRuns","flattenRegularRuns","points","attrs","stack","type","splice","flatten","emptyRuns","regularRuns","empty","omitFont","preprocessRuns","fontSubstitution","scriptItemizer","bidi","omittedFontRuns","itemizationRuns","substitutedRuns","bidiRuns","splitParagraphs","breakPoint","indexOf","advanceWidth$2","pos","advanceWidth$1","WHITE_SPACES_CODE","isWhiteSpace","leadingPositions","leadingWhitespaces","leadingOffset$1","leadingOffset","trailingPositions","trailingOffset$1","trailingOffset","dropLast$1","ALIGNMENT_FACTORS","center","right","removeNewLine","getOverflowLeft","overflowLeft","getOverflowRight","overflowRight","adjustOverflow","justifyLine$1","align","lineWidth","alignFactor","remainingWidth","shouldJustify","justification","finalizeLine","lineAscent","lineDescent","lineXAdvance","descent$1","finalizeBlock","isLastFragment","alignLastLine","textDecoration","finalizeFragments","blockFinalizer","ATTACHMENT_CODE","isReplaceGlyph","resolveRunAttachments","resolveAttachments","applyAttributes","backgroundColor","bullet","color","features","hangingPunctuation","hyphenationFactor","justificationFactor","lineSpacing","link","marginLeft","margin","marginRight","opacity","paddingTop","padding","paragraphSpacing","script","shrinkFactor","strike","strikeColor","strikeStyle","stroke","underline","underlineColor","underlineStyle","verticalAlign","wordSpacing","applyRunStyles","applyDefaultStyles","verticalAlignment","bidi$1","getBidiLevels","mirrorString","char","isRTL","mirroredChar","getMirroredCharacter","charAt","layoutEngine","processParagraph","processParagraphs","bidiEngine","getEmbeddingLevels","lastLevel","INFINITY","getNextBreakpoint","subnodes","widths","lineNumber","minimumBadness","sum","stretch","shrink","lineLength","calculateRatio","node","ratio","penalty","badness","abs","applyBestFit","nodes","count","breakpoints","breakpoint","LinkedListNode","data","prev","LinkedList","tail","listSize","listLength","callback","newNode","isLinked","insertAfter","insertBefore","demerits","fitnessClass","totals","previous","computeCost","lineLengths","active","currentLine","linebreak","infinity","computeSum","breakPointIndex","findBestBreakpoints","activeNodes","size","tmp","tolerance","flagged","fitness","Node","mainLoop","first","candidates","remove","pow","currentClass","tmpSum","candidate","precedesBox","glue","hyphenated","runA","runB","runAIndices","runALastIndex","runBIndices","insertGlyph$1","leadingRun","trailingRun","insert","runIndexAt","insertGlyph","runIndex","advanceWidthBetween$1","runStart","glyphStartIndex","glyphEndIndex","advanceWidthBetween","HYPHEN","TOLERANCE_STEPS","TOLERANCE_LIMIT","opts","breakLines","breaks","prevNode","getNodes","hyphenWidth","hyphenPenalty","hyphenationPenalty","s","getAttributes","Direction","WHITESPACE_PRIORITY","LETTER_PRIORITY","EXPAND_WHITESPACE_FACTOR","before","after","priority","unconstrained","EXPAND_CHAR_FACTOR","SHRINK_WHITESPACE_FACTOR","SHRINK_CHAR_FACTOR","getCharFactor","expandCharFactor","shrinkCharFactor","GROW","getWhitespaceFactor","expandWhitespaceFactor","shrinkWhitespaceFactor","factor","charFactor","whitespaceFactor","factors","f","isMark","getFactors","gap","SHRINK","getFactor","KASHIDA_PRIORITY","NULL_PRIORITY","getDistances","total","priorities","highestPriority","highestPrioritySum","remainingGap","prioritySum","distances","dist","justifyLine","BASE_FONT_SIZE","maxX","decorationLines","thickness","floor","decorationLine","ignoredScripts","lastScript","codePointAt","getScript","SOFT_HYPHEN","hyphenator","splitHyphen","cache","getParts","base","cacheKey","IGNORED_CODE_POINTS","getFontSize","pickFontFromFontStack","fontStack","lastFont","fontStackWithFallback","hasGlyphForCodePoint","at","lastFontSize","chars","default"],"mappings":"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","sourcesContent":["import { isNil, last, repeat, reverse, dropLast as dropLast$2, adjust, compose } from '@react-pdf/fns';\nimport bidiFactory from 'bidi-js';\nimport unicode from 'unicode-properties';\nimport hyphen from 'hyphen';\nimport pattern from 'hyphen/patterns/en-us.js';\n\n/**\n * Create attributed string from text fragments\n *\n * @param fragments - Fragments\n * @returns Attributed string\n */\nconst fromFragments = (fragments) => {\n    let offset = 0;\n    let string = '';\n    const runs = [];\n    fragments.forEach((fragment) => {\n        string += fragment.string;\n        runs.push({\n            ...fragment,\n            start: offset,\n            end: offset + fragment.string.length,\n            attributes: fragment.attributes || {},\n        });\n        offset += fragment.string.length;\n    });\n    return { string, runs };\n};\n\n/**\n * Default word hyphenation engine used when no one provided.\n * Does not perform word hyphenation at all\n *\n * @param word\n * @returns Same word\n */\nconst defaultHyphenationEngine = (word) => [word];\n/**\n * Wrap words of attribute string\n *\n * @param engines layout engines\n * @param options layout options\n */\nconst wrapWords = (engines = {}, options = {}) => {\n    /**\n     * @param attributedString - Attributed string\n     * @returns Attributed string including syllables\n     */\n    return (attributedString) => {\n        const syllables = [];\n        const fragments = [];\n        const hyphenateWord = options.hyphenationCallback ||\n            engines.wordHyphenation?.() ||\n            defaultHyphenationEngine;\n        for (let i = 0; i < attributedString.runs.length; i += 1) {\n            let string = '';\n            const run = attributedString.runs[i];\n            const words = attributedString.string\n                .slice(run.start, run.end)\n                .split(/([ ]+)/g)\n                .filter(Boolean);\n            for (let j = 0; j < words.length; j += 1) {\n                const word = words[j];\n                const parts = hyphenateWord(word);\n                syllables.push(...parts);\n                string += parts.join('');\n            }\n            fragments.push({ ...run, string });\n        }\n        const result = { ...fromFragments(fragments), syllables };\n        return result;\n    };\n};\n\n/**\n * Clone rect\n *\n * @param rect - Rect\n * @returns Cloned rect\n */\nconst copy = (rect) => {\n    return Object.assign({}, rect);\n};\n\n/**\n * Partition rect in two in the vertical direction\n *\n * @param rect - Rect\n * @param height - Height\n * @returns Partitioned rects\n */\nconst partition = (rect, height) => {\n    const a = Object.assign({}, rect, { height });\n    const b = Object.assign({}, rect, {\n        y: rect.y + height,\n        height: rect.height - height,\n    });\n    return [a, b];\n};\n\n/**\n * Crop upper section of rect\n *\n * @param height - Height\n * @param rect - Rect\n * @returns Cropped rect\n */\nconst crop = (height, rect) => {\n    const [, result] = partition(rect, height);\n    return result;\n};\n\n/**\n * Get paragraph block height\n *\n * @param paragraph - Paragraph\n * @returns Paragraph block height\n */\nconst height$2 = (paragraph) => {\n    return paragraph.reduce((acc, block) => acc + block.box.height, 0);\n};\n\n/**\n * Calculate run scale\n *\n * @param run - Run\n * @returns Scale\n */\nconst calculateScale = (run) => {\n    const attributes = run.attributes || {};\n    const fontSize = attributes.fontSize || 12;\n    const font = attributes.font;\n    const unitsPerEm = typeof font === 'string' ? null : font?.[0]?.unitsPerEm;\n    return unitsPerEm ? fontSize / unitsPerEm : 0;\n};\n/**\n * Get run scale\n *\n * @param  run\n * @returns Scale\n */\nconst scale = (run) => {\n    return run.attributes?.scale || calculateScale(run);\n};\n\n/**\n * Get ligature offset by index\n *\n * Ex. ffi ligature\n *\n *   glyphs:         l  o  f  f  i  m\n *   glyphIndices:   0  1  2  2  2  3\n *   offset:         0  0  0  1  2  0\n *\n * @param index\n * @param run - Run\n * @returns Ligature offset\n */\nconst offset = (index, run) => {\n    if (!run)\n        return 0;\n    const glyphIndices = run.glyphIndices || [];\n    const value = glyphIndices[index];\n    return glyphIndices.slice(0, index).filter((i) => i === value).length;\n};\n\n/**\n * Get run font\n *\n * @param run - Run\n * @returns Font\n */\nconst getFont = (run) => {\n    return run.attributes?.font?.[0] || null;\n};\n\n/**\n * Slice glyph between codePoints range\n * Util for breaking ligatures\n *\n * @param start - Start code point index\n * @param end - End code point index\n * @param font - Font to generate new glyph\n * @param glyph - Glyph to be sliced\n * @returns Sliced glyph parts\n */\nconst slice$2 = (start, end, font, glyph) => {\n    if (!glyph)\n        return [];\n    if (start === end)\n        return [];\n    if (start === 0 && end === glyph.codePoints.length)\n        return [glyph];\n    const codePoints = glyph.codePoints.slice(start, end);\n    const string = String.fromCodePoint(...codePoints);\n    // passing LTR To force fontkit to not reverse the string\n    return font\n        ? font.layout(string, undefined, undefined, undefined, 'ltr').glyphs\n        : [glyph];\n};\n\n/**\n * Return glyph index at string index, if glyph indices present.\n * Otherwise return string index\n *\n * @param index - Index\n * @param run - Run\n * @returns Glyph index\n */\nconst glyphIndexAt = (index, run) => {\n    const result = run?.glyphIndices?.[index];\n    return isNil(result) ? index : result;\n};\n\n/**\n * Returns new array starting with zero, and keeping same relation between consecutive values\n *\n * @param array - List\n * @returns Normalized array\n */\nconst normalize = (array) => {\n    const head = array[0];\n    return array.map((value) => value - head);\n};\n\n/**\n * Slice run between glyph indices range\n *\n * @param start - Glyph index\n * @param end - Glyph index\n * @param run - Run\n * @returns Sliced run\n */\nconst slice$1 = (start, end, run) => {\n    const runScale = scale(run);\n    const font = getFont(run);\n    // Get glyph start and end indices\n    const startIndex = glyphIndexAt(start, run);\n    const endIndex = glyphIndexAt(end, run);\n    // Get start and end glyph\n    const startGlyph = run.glyphs?.[startIndex];\n    const endGlyph = run.glyphs?.[endIndex];\n    // Get start ligature chunks (if any)\n    const startOffset = offset(start, run);\n    const startGlyphs = startOffset > 0 ? slice$2(startOffset, Infinity, font, startGlyph) : [];\n    // Get end ligature chunks (if any)\n    const endOffset = offset(end, run);\n    const endGlyphs = slice$2(0, endOffset, font, endGlyph);\n    // Compute new glyphs\n    const sliceStart = startIndex + Math.min(1, startOffset);\n    const glyphs = (run.glyphs || []).slice(sliceStart, endIndex);\n    // Compute new positions\n    const glyphPosition = (g) => ({\n        xAdvance: g.advanceWidth * runScale,\n        yAdvance: 0,\n        xOffset: 0,\n        yOffset: 0,\n    });\n    const startPositions = startGlyphs.map(glyphPosition);\n    const positions = (run.positions || []).slice(sliceStart, endIndex);\n    const endPositions = endGlyphs.map(glyphPosition);\n    return Object.assign({}, run, {\n        start: run.start + start,\n        end: Math.min(run.end, run.start + end),\n        glyphIndices: normalize((run.glyphIndices || []).slice(start, end)),\n        glyphs: [startGlyphs, glyphs, endGlyphs].flat(),\n        positions: [startPositions, positions, endPositions].flat(),\n    });\n};\n\n/**\n * Get run index that contains passed index\n *\n * @param index - Index\n * @param runs - Runs\n * @returns Run index\n */\nconst runIndexAt$1 = (index, runs) => {\n    if (!runs)\n        return -1;\n    return runs.findIndex((run) => run.start <= index && index < run.end);\n};\n\n/**\n * Filter runs contained between start and end\n *\n * @param start\n * @param end\n * @param runs\n * @returns Filtered runs\n */\nconst filter = (start, end, runs) => {\n    const startIndex = runIndexAt$1(start, runs);\n    const endIndex = Math.max(runIndexAt$1(end - 1, runs), startIndex);\n    return runs.slice(startIndex, endIndex + 1);\n};\n\n/**\n * Subtract scalar to run\n *\n * @param index - Scalar\n * @param run - Run\n * @returns Subtracted run\n */\nconst subtract = (index, run) => {\n    const start = run.start - index;\n    const end = run.end - index;\n    return Object.assign({}, run, { start, end });\n};\n\n/**\n * Slice array of runs\n *\n * @param start - Offset\n * @param end - Offset\n * @param runs\n * @returns Sliced runs\n */\nconst sliceRuns = (start, end, runs) => {\n    const sliceFirstRun = (a) => slice$1(start - a.start, end - a.start, a);\n    const sliceLastRun = (a) => slice$1(0, end - a.start, a);\n    return runs.map((run, i) => {\n        let result = run;\n        const isFirst = i === 0;\n        const isLast = !isFirst && i === runs.length - 1;\n        if (isFirst)\n            result = sliceFirstRun(run);\n        if (isLast)\n            result = sliceLastRun(run);\n        return subtract(start, result);\n    });\n};\n/**\n * Slice attributed string between two indices\n *\n * @param start - Offset\n * @param end - Offset\n * @param attributedString - Attributed string\n * @returns Attributed string\n */\nconst slice = (start, end, attributedString) => {\n    if (attributedString.string.length === 0)\n        return attributedString;\n    const string = attributedString.string.slice(start, end);\n    const filteredRuns = filter(start, end, attributedString.runs);\n    const slicedRuns = sliceRuns(start, end, filteredRuns);\n    return Object.assign({}, attributedString, { string, runs: slicedRuns });\n};\n\nconst findCharIndex = (string) => {\n    return string.search(/\\S/g);\n};\nconst findLastCharIndex = (string) => {\n    const match = string.match(/\\S/g);\n    return match ? string.lastIndexOf(match[match.length - 1]) : -1;\n};\n/**\n * Removes (strips) whitespace from both ends of the attributted string.\n *\n * @param attributedString - Attributed string\n * @returns Attributed string\n */\nconst trim = (attributedString) => {\n    const start = findCharIndex(attributedString.string);\n    const end = findLastCharIndex(attributedString.string);\n    return slice(start, end + 1, attributedString);\n};\n\n/**\n * Returns empty run\n *\n * @returns Empty run\n */\nconst empty$1 = () => {\n    return {\n        start: 0,\n        end: 0,\n        glyphIndices: [],\n        glyphs: [],\n        positions: [],\n        attributes: {},\n    };\n};\n\n/**\n * Check if value is a number\n *\n * @param value - Value to check\n * @returns Whether value is a number\n */\nconst isNumber = (value) => {\n    return typeof value === 'number';\n};\n\n/**\n * Append glyph indices with given length\n *\n * Ex. appendIndices(3, [0, 1, 2, 2]) => [0, 1, 2, 2, 3, 3, 3]\n *\n * @param length - Length\n * @param indices - Glyph indices\n * @returns Extended glyph indices\n */\nconst appendIndices = (length, indices) => {\n    const lastIndex = last(indices);\n    const value = isNil(lastIndex) ? 0 : lastIndex + 1;\n    const newIndices = Array(length).fill(value);\n    return indices.concat(newIndices);\n};\n\n/**\n * Get glyph for a given code point\n *\n * @param value - CodePoint\n * @param font - Font\n * @returns Glyph\n * */\nconst fromCodePoint = (value, font) => {\n    if (typeof font === 'string')\n        return null;\n    return font && value ? font.glyphForCodePoint(value) : null;\n};\n\n/**\n * Append glyph to run\n *\n * @param glyph - Glyph\n * @param run - Run\n * @returns Run with glyph\n */\nconst appendGlyph = (glyph, run) => {\n    const glyphLength = glyph.codePoints?.length || 0;\n    const end = run.end + glyphLength;\n    const glyphs = run.glyphs.concat(glyph);\n    const glyphIndices = appendIndices(glyphLength, run.glyphIndices);\n    if (!run.positions)\n        return Object.assign({}, run, { end, glyphs, glyphIndices });\n    const positions = run.positions.concat({\n        xAdvance: glyph.advanceWidth * scale(run),\n        yAdvance: 0,\n        xOffset: 0,\n        yOffset: 0,\n    });\n    return Object.assign({}, run, { end, glyphs, glyphIndices, positions });\n};\n/**\n * Append glyph or code point to run\n *\n * @param value - Glyph or codePoint\n * @param run - Run\n * @returns Run with glyph\n */\nconst append$1 = (value, run) => {\n    if (!value)\n        return run;\n    const font = getFont(run);\n    const glyph = isNumber(value) ? fromCodePoint(value, font) : value;\n    return appendGlyph(glyph, run);\n};\n\n/**\n * Get string from array of code points\n *\n * @param codePoints - Points\n * @returns String\n */\nconst stringFromCodePoints = (codePoints) => {\n    return String.fromCodePoint(...(codePoints || []));\n};\n\n/**\n * Append glyph into last run of attributed string\n *\n * @param glyph - Glyph or code point\n * @param attributedString - Attributed string\n * @returns Attributed string with new glyph\n */\nconst append = (glyph, attributedString) => {\n    const codePoints = typeof glyph === 'number' ? [glyph] : glyph?.codePoints;\n    const codePointsString = stringFromCodePoints(codePoints || []);\n    const string = attributedString.string + codePointsString;\n    const firstRuns = attributedString.runs.slice(0, -1);\n    const lastRun = last(attributedString.runs) || empty$1();\n    const runs = firstRuns.concat(append$1(glyph, lastRun));\n    return Object.assign({}, attributedString, { string, runs });\n};\n\nconst ELLIPSIS_UNICODE = 8230;\nconst ELLIPSIS_STRING = String.fromCharCode(ELLIPSIS_UNICODE);\n/**\n * Get ellipsis codepoint. This may be different in standard and embedded fonts\n *\n * @param font\n * @returns Ellipsis codepoint\n */\nconst getEllipsisCodePoint = (font) => {\n    if (!font.encode)\n        return ELLIPSIS_UNICODE;\n    const [codePoints] = font.encode(ELLIPSIS_STRING);\n    return parseInt(codePoints[0], 16);\n};\n/**\n * Trucante block with ellipsis\n *\n * @param paragraph - Paragraph\n * @returns Sliced paragraph\n */\nconst truncate = (paragraph) => {\n    const runs = last(paragraph)?.runs || [];\n    const font = last(runs)?.attributes?.font[0];\n    if (font) {\n        const index = paragraph.length - 1;\n        const codePoint = getEllipsisCodePoint(font);\n        const glyph = font.glyphForCodePoint(codePoint);\n        const lastBlock = append(glyph, trim(paragraph[index]));\n        return Object.assign([], paragraph, { [index]: lastBlock });\n    }\n    return paragraph;\n};\n\n/**\n * Omit attribute from run\n *\n * @param value - Attribute key\n * @param run - Run\n * @returns Run without ommited attribute\n */\nconst omit = (value, run) => {\n    const attributes = Object.assign({}, run.attributes);\n    delete attributes[value];\n    return Object.assign({}, run, { attributes });\n};\n\n/**\n * Get run ascent\n *\n * @param run - Run\n * @returns Ascent\n */\nconst ascent$1 = (run) => {\n    const { font, attachment } = run.attributes;\n    const attachmentHeight = attachment?.height || 0;\n    const fontAscent = typeof font === 'string' ? 0 : font?.[0]?.ascent || 0;\n    return Math.max(attachmentHeight, fontAscent * scale(run));\n};\n\n/**\n * Get run descent\n *\n * @param run - Run\n * @returns Descent\n */\nconst descent = (run) => {\n    const font = run.attributes?.font;\n    const fontDescent = typeof font === 'string' ? 0 : font?.[0]?.descent || 0;\n    return scale(run) * fontDescent;\n};\n\n/**\n * Get run lineGap\n *\n * @param run - Run\n * @returns LineGap\n */\nconst lineGap = (run) => {\n    const font = run.attributes?.font;\n    const lineGap = typeof font === 'string' ? 0 : font?.[0]?.lineGap || 0;\n    return lineGap * scale(run);\n};\n\n/**\n * Get run height\n *\n * @param run - Run\n * @returns Height\n */\nconst height$1 = (run) => {\n    const lineHeight = run.attributes?.lineHeight;\n    return lineHeight || lineGap(run) + ascent$1(run) - descent(run);\n};\n\n/**\n * Returns attributed string height\n *\n * @param attributedString - Attributed string\n * @returns Height\n */\nconst height = (attributedString) => {\n    const reducer = (acc, run) => Math.max(acc, height$1(run));\n    return attributedString.runs.reduce(reducer, 0);\n};\n\n/**\n * Checks if two rects intersect each other\n *\n * @param a - Rect A\n * @param b - Rect B\n * @returns Whether rects intersect\n */\nconst intersects = (a, b) => {\n    const x = Math.max(a.x, b.x);\n    const num1 = Math.min(a.x + a.width, b.x + b.width);\n    const y = Math.max(a.y, b.y);\n    const num2 = Math.min(a.y + a.height, b.y + b.height);\n    return num1 >= x && num2 >= y;\n};\n\nconst getLineFragment = (lineRect, excludeRect) => {\n    if (!intersects(excludeRect, lineRect))\n        return [lineRect];\n    const eStart = excludeRect.x;\n    const eEnd = excludeRect.x + excludeRect.width;\n    const lStart = lineRect.x;\n    const lEnd = lineRect.x + lineRect.width;\n    const a = Object.assign({}, lineRect, { width: eStart - lStart });\n    const b = Object.assign({}, lineRect, { x: eEnd, width: lEnd - eEnd });\n    return [a, b].filter((r) => r.width > 0);\n};\nconst getLineFragments = (rect, excludeRects) => {\n    let fragments = [rect];\n    for (let i = 0; i < excludeRects.length; i += 1) {\n        const excludeRect = excludeRects[i];\n        fragments = fragments.reduce((acc, fragment) => {\n            const pieces = getLineFragment(fragment, excludeRect);\n            return acc.concat(pieces);\n        }, []);\n    }\n    return fragments;\n};\nconst generateLineRects = (container, height) => {\n    const { excludeRects, ...rect } = container;\n    if (!excludeRects)\n        return [rect];\n    const lineRects = [];\n    const maxY = Math.max(...excludeRects.map((r) => r.y + r.height));\n    let currentRect = rect;\n    while (currentRect.y < maxY) {\n        const [lineRect, rest] = partition(currentRect, height);\n        const lineRectFragments = getLineFragments(lineRect, excludeRects);\n        currentRect = rest;\n        lineRects.push(...lineRectFragments);\n    }\n    return [...lineRects, currentRect];\n};\n\nconst ATTACHMENT_CODE$1 = '\\ufffc'; // 65532\n/**\n * Remove attachment attribute if no char present\n *\n * @param line - Line\n * @returns Line\n */\nconst purgeAttachments = (line) => {\n    const shouldPurge = !line.string.includes(ATTACHMENT_CODE$1);\n    if (!shouldPurge)\n        return line;\n    const runs = line.runs.map((run) => omit('attachment', run));\n    return Object.assign({}, line, { runs });\n};\n/**\n * Layout paragraphs inside rectangle\n *\n * @param rects - Rects\n * @param lines - Attributed strings\n * @param indent\n * @returns layout blocks\n */\nconst layoutLines = (rects, lines, indent) => {\n    let rect = rects.shift();\n    let currentY = rect.y;\n    return lines.map((line, i) => {\n        const lineIndent = i === 0 ? indent : 0;\n        const style = line.runs?.[0]?.attributes || {};\n        const height$1 = Math.max(height(line), style.lineHeight);\n        if (currentY + height$1 > rect.y + rect.height && rects.length > 0) {\n            rect = rects.shift();\n            currentY = rect.y;\n        }\n        const newLine = {\n            string: line.string,\n            runs: line.runs,\n            box: {\n                x: rect.x + lineIndent,\n                y: currentY,\n                width: rect.width - lineIndent,\n                height: height$1,\n            },\n        };\n        currentY += height$1;\n        return purgeAttachments(newLine);\n    });\n};\n/**\n * Performs line breaking and layout\n *\n * @param engines - Engines\n * @param options - Layout options\n */\nconst layoutParagraph = (engines, options = {}) => {\n    /**\n     * @param container - Container\n     * @param paragraph - Attributed string\n     * @returns Layout block\n     */\n    return (container, paragraph) => {\n        const height$1 = height(paragraph);\n        const indent = paragraph.runs?.[0]?.attributes?.indent || 0;\n        const rects = generateLineRects(container, height$1);\n        const availableWidths = rects.map((r) => r.width);\n        availableWidths.unshift(availableWidths[0] - indent);\n        const lines = engines.linebreaker(options)(paragraph, availableWidths);\n        return layoutLines(rects, lines, indent);\n    };\n};\n\n/**\n * Slice block at given height\n *\n * @param height - Height\n * @param paragraph - Paragraph\n * @returns Sliced paragraph\n */\nconst sliceAtHeight = (height, paragraph) => {\n    const newBlock = [];\n    let counter = 0;\n    for (let i = 0; i < paragraph.length; i += 1) {\n        const line = paragraph[i];\n        counter += line.box.height;\n        if (counter < height) {\n            newBlock.push(line);\n        }\n        else {\n            break;\n        }\n    }\n    return newBlock;\n};\n\n/**\n * Layout paragraphs inside container until it does not\n * fit anymore, performing line wrapping in the process.\n *\n * @param  engines - Engines\n * @param  options - Layout options\n * @param container - Container\n */\nconst typesetter = (engines, options, container) => {\n    /**\n     * @param attributedStrings - Attributed strings (paragraphs)\n     * @returns Paragraph blocks\n     */\n    return (attributedStrings) => {\n        const result = [];\n        const paragraphs = [...attributedStrings];\n        const layout = layoutParagraph(engines, options);\n        const maxLines = isNil(container.maxLines) ? Infinity : container.maxLines;\n        const truncateEllipsis = container.truncateMode === 'ellipsis';\n        let linesCount = maxLines;\n        let paragraphRect = copy(container);\n        let nextParagraph = paragraphs.shift();\n        while (linesCount > 0 && nextParagraph) {\n            const paragraph = layout(paragraphRect, nextParagraph);\n            const slicedBlock = paragraph.slice(0, linesCount);\n            const linesHeight = height$2(slicedBlock);\n            const shouldTruncate = truncateEllipsis && paragraph.length !== slicedBlock.length;\n            linesCount -= slicedBlock.length;\n            if (paragraphRect.height >= linesHeight) {\n                result.push(shouldTruncate ? truncate(slicedBlock) : slicedBlock);\n                paragraphRect = crop(linesHeight, paragraphRect);\n                nextParagraph = paragraphs.shift();\n            }\n            else {\n                result.push(truncate(sliceAtHeight(paragraphRect.height, slicedBlock)));\n                break;\n            }\n        }\n        return result;\n    };\n};\n\n/**\n * Get attributed string start value\n *\n * @param attributedString - Attributed string\n * @returns Start\n */\nconst start = (attributedString) => {\n    const { runs } = attributedString;\n    return runs.length === 0 ? 0 : runs[0].start;\n};\n\n/**\n * Get attributed string end value\n *\n * @param attributedString - Attributed string\n * @returns End\n */\nconst end = (attributedString) => {\n    const { runs } = attributedString;\n    return runs.length === 0 ? 0 : last(runs).end;\n};\n\n/**\n * Get attributed string length\n *\n * @param attributedString - Attributed string\n * @returns End\n */\nconst length$1 = (attributedString) => {\n    return end(attributedString) - start(attributedString);\n};\n\nconst bidi$2 = bidiFactory();\nconst getBidiLevels$1 = (runs) => {\n    return runs.reduce((acc, run) => {\n        const length = run.end - run.start;\n        const levels = repeat(run.attributes.bidiLevel, length);\n        return acc.concat(levels);\n    }, []);\n};\nconst getReorderedIndices = (string, segments) => {\n    // Fill an array with indices\n    const indices = [];\n    for (let i = 0; i < string.length; i += 1) {\n        indices[i] = i;\n    }\n    // Reverse each segment in order\n    segments.forEach(([start, end]) => {\n        const slice = indices.slice(start, end + 1);\n        for (let i = slice.length - 1; i >= 0; i -= 1) {\n            indices[end - i] = slice[i];\n        }\n    });\n    return indices;\n};\nconst getItemAtIndex = (runs, objectName, index) => {\n    for (let i = 0; i < runs.length; i += 1) {\n        const run = runs[i];\n        const updatedIndex = run.glyphIndices[index - run.start];\n        if (index >= run.start && index < run.end) {\n            return run[objectName][updatedIndex];\n        }\n    }\n    throw new Error(`index ${index} out of range`);\n};\nconst reorderLine = (line) => {\n    const levels = getBidiLevels$1(line.runs);\n    const direction = line.runs[0]?.attributes.direction;\n    const level = direction === 'rtl' ? 1 : 0;\n    const end = length$1(line) - 1;\n    const paragraphs = [{ start: 0, end, level }];\n    const embeddingLevels = { paragraphs, levels };\n    const segments = bidi$2.getReorderSegments(line.string, embeddingLevels);\n    // No need for bidi reordering\n    if (segments.length === 0)\n        return line;\n    const indices = getReorderedIndices(line.string, segments);\n    const updatedString = bidi$2.getReorderedString(line.string, embeddingLevels);\n    const updatedRuns = line.runs.map((run) => {\n        const selectedIndices = indices.slice(run.start, run.end);\n        const updatedGlyphs = [];\n        const updatedPositions = [];\n        const addedGlyphs = new Set();\n        for (let i = 0; i < selectedIndices.length; i += 1) {\n            const index = selectedIndices[i];\n            const glyph = getItemAtIndex(line.runs, 'glyphs', index);\n            if (addedGlyphs.has(glyph.id))\n                continue;\n            updatedGlyphs.push(glyph);\n            updatedPositions.push(getItemAtIndex(line.runs, 'positions', index));\n            if (glyph.isLigature) {\n                addedGlyphs.add(glyph.id);\n            }\n        }\n        return {\n            ...run,\n            glyphs: updatedGlyphs,\n            positions: updatedPositions,\n        };\n    });\n    return {\n        box: line.box,\n        runs: updatedRuns,\n        string: updatedString,\n    };\n};\nconst reorderParagraph = (paragraph) => paragraph.map(reorderLine);\n/**\n * Perform bidi reordering\n *\n * @returns Reordered paragraphs\n */\nconst bidiReordering = () => {\n    /**\n     * @param paragraphs - Paragraphs\n     * @returns Reordered paragraphs\n     */\n    return (paragraphs) => paragraphs.map(reorderParagraph);\n};\n\nconst DUMMY_CODEPOINT = 123;\n/**\n * Resolve string indices based on glyphs code points\n *\n * @param glyphs\n * @returns Glyph indices\n */\nconst resolve = (glyphs = []) => {\n    return glyphs.reduce((acc, glyph) => {\n        const codePoints = glyph?.codePoints || [DUMMY_CODEPOINT];\n        if (acc.length === 0)\n            return codePoints.map(() => 0);\n        const last = acc[acc.length - 1];\n        const next = codePoints.map(() => last + 1);\n        return [...acc, ...next];\n    }, []);\n};\n\nconst getCharacterSpacing = (run) => {\n    return run.attributes?.characterSpacing || 0;\n};\n/**\n * Scale run positions\n *\n * @param  run\n * @param  positions\n * @returns Scaled positions\n */\nconst scalePositions = (run, positions) => {\n    const runScale = scale(run);\n    const characterSpacing = getCharacterSpacing(run);\n    return positions.map((position, i) => {\n        const isLast = i === positions.length;\n        const xSpacing = isLast ? 0 : characterSpacing;\n        return Object.assign({}, position, {\n            xAdvance: position.xAdvance * runScale + xSpacing,\n            yAdvance: position.yAdvance * runScale,\n            xOffset: position.xOffset * runScale,\n            yOffset: position.yOffset * runScale,\n        });\n    });\n};\n/**\n * Create glyph run\n *\n * @param string string\n */\nconst layoutRun = (string) => {\n    /**\n     * @param run - Run\n     * @returns Glyph run\n     */\n    return (run) => {\n        const { start, end, attributes = {} } = run;\n        const { font } = attributes;\n        if (!font)\n            return { ...run, glyphs: [], glyphIndices: [], positions: [] };\n        const runString = string.slice(start, end);\n        if (typeof font === 'string')\n            throw new Error('Invalid font');\n        // passing LTR To force fontkit to not reverse the string\n        const glyphRun = font[0].layout(runString, undefined, undefined, undefined, 'ltr');\n        const positions = scalePositions(run, glyphRun.positions);\n        const glyphIndices = resolve(glyphRun.glyphs);\n        const result = {\n            ...run,\n            positions,\n            glyphIndices,\n            glyphs: glyphRun.glyphs,\n        };\n        return result;\n    };\n};\n/**\n * Generate glyphs for single attributed string\n */\nconst generateGlyphs = () => {\n    /**\n     * @param attributedString - Attributed string\n     * @returns Attributed string with glyphs\n     */\n    return (attributedString) => {\n        const runs = attributedString.runs.map(layoutRun(attributedString.string));\n        const res = Object.assign({}, attributedString, { runs });\n        return res;\n    };\n};\n\n/**\n * Resolves yOffset for run\n *\n * @param run - Run\n * @returns Run\n */\nconst resolveRunYOffset = (run) => {\n    if (!run.positions)\n        return run;\n    const unitsPerEm = run.attributes?.font?.[0]?.unitsPerEm || 0;\n    const yOffset = (run.attributes?.yOffset || 0) * unitsPerEm;\n    const positions = run.positions.map((p) => Object.assign({}, p, { yOffset }));\n    return Object.assign({}, run, { positions });\n};\n/**\n * Resolves yOffset for multiple paragraphs\n */\nconst resolveYOffset = () => {\n    /**\n     * @param attributedString - Attributed string\n     * @returns Attributed string\n     */\n    return (attributedString) => {\n        const runs = attributedString.runs.map(resolveRunYOffset);\n        const res = Object.assign({}, attributedString, { runs });\n        return res;\n    };\n};\n\n/**\n * Sort runs in ascending order\n *\n * @param runs\n * @returns Sorted runs\n */\nconst sort = (runs) => {\n    return runs.sort((a, b) => a.start - b.start || a.end - b.end);\n};\n\n/**\n * Is run empty (start === end)\n *\n * @param run - Run\n * @returns Is run empty\n */\nconst isEmpty = (run) => {\n    return run.start === run.end;\n};\n\n/**\n * Sort points in ascending order\n * @param a - First point\n * @param b - Second point\n * @returns Sort order\n */\nconst sortPoints = (a, b) => {\n    return a[1] - b[1] || a[3] - b[3];\n};\n/**\n * @param runs\n * @returns Points\n */\nconst generatePoints = (runs) => {\n    const result = runs.reduce((acc, run, i) => {\n        return acc.concat([\n            ['start', run.start, run.attributes, i],\n            ['end', run.end, run.attributes, i],\n        ]);\n    }, []);\n    return result.sort(sortPoints);\n};\n/**\n * @param runs\n * @returns Merged runs\n */\nconst mergeRuns = (runs) => {\n    return runs.reduce((acc, run) => {\n        const attributes = Object.assign({}, acc.attributes, run.attributes);\n        return Object.assign({}, run, { attributes });\n    }, {});\n};\n/**\n * @param runs\n * @returns Grouped runs\n */\nconst groupEmptyRuns = (runs) => {\n    const groups = runs.reduce((acc, run) => {\n        if (!acc[run.start])\n            acc[run.start] = [];\n        acc[run.start].push(run);\n        return acc;\n    }, []);\n    return Object.values(groups);\n};\n/**\n * @param runs\n * @returns Flattened runs\n */\nconst flattenEmptyRuns = (runs) => {\n    return groupEmptyRuns(runs).map(mergeRuns);\n};\n/**\n * @param runs\n * @returns Flattened runs\n */\nconst flattenRegularRuns = (runs) => {\n    const res = [];\n    const points = generatePoints(runs);\n    let start = -1;\n    let attrs = {};\n    const stack = [];\n    for (let i = 0; i < points.length; i += 1) {\n        const [type, offset, attributes] = points[i];\n        if (start !== -1 && start < offset) {\n            res.push({\n                start,\n                end: offset,\n                attributes: attrs,\n                glyphIndices: [],\n                glyphs: [],\n                positions: [],\n            });\n        }\n        if (type === 'start') {\n            stack.push(attributes);\n            attrs = Object.assign({}, attrs, attributes);\n        }\n        else {\n            attrs = {};\n            for (let j = 0; j < stack.length; j += 1) {\n                if (stack[j] === attributes) {\n                    stack.splice(j--, 1);\n                }\n                else {\n                    attrs = Object.assign({}, attrs, stack[j]);\n                }\n            }\n        }\n        start = offset;\n    }\n    return res;\n};\n/**\n * Flatten many runs\n *\n * @param runs\n * @returns Flattened runs\n */\nconst flatten = (runs = []) => {\n    const emptyRuns = flattenEmptyRuns(runs.filter((run) => isEmpty(run)));\n    const regularRuns = flattenRegularRuns(runs.filter((run) => !isEmpty(run)));\n    return sort(emptyRuns.concat(regularRuns));\n};\n\n/**\n * Returns empty attributed string\n *\n * @returns Empty attributed string\n */\nconst empty = () => ({ string: '', runs: [] });\n\n/**\n *\n * @param attributedString\n * @returns Attributed string without font\n */\nconst omitFont = (attributedString) => {\n    const runs = attributedString.runs.map((run) => omit('font', run));\n    return Object.assign({}, attributedString, { runs });\n};\n/**\n * Performs font substitution and script itemization on attributed string\n *\n * @param engines - engines\n */\nconst preprocessRuns = (engines) => {\n    /**\n     * @param attributedString - Attributed string\n     * @returns Processed attributed string\n     */\n    return (attributedString) => {\n        if (isNil(attributedString))\n            return empty();\n        const { string } = attributedString;\n        const { fontSubstitution, scriptItemizer, bidi } = engines;\n        const { runs: omittedFontRuns } = omitFont(attributedString);\n        const { runs: itemizationRuns } = scriptItemizer()(attributedString);\n        const { runs: substitutedRuns } = fontSubstitution()(attributedString);\n        const { runs: bidiRuns } = bidi()(attributedString);\n        const runs = bidiRuns\n            .concat(substitutedRuns)\n            .concat(itemizationRuns)\n            .concat(omittedFontRuns);\n        return { string, runs: flatten(runs) };\n    };\n};\n\n/**\n * Breaks attributed string into paragraphs\n */\nconst splitParagraphs = () => {\n    /**\n     * @param attributedString - Attributed string\n     * @returns Paragraphs attributed strings\n     */\n    return (attributedString) => {\n        const paragraphs = [];\n        let start = 0;\n        let breakPoint = attributedString.string.indexOf('\\n') + 1;\n        while (breakPoint > 0) {\n            paragraphs.push(slice(start, breakPoint, attributedString));\n            start = breakPoint;\n            breakPoint = attributedString.string.indexOf('\\n', breakPoint) + 1;\n        }\n        if (start === 0) {\n            paragraphs.push(attributedString);\n        }\n        else if (start < attributedString.string.length) {\n            paragraphs.push(slice(start, length$1(attributedString), attributedString));\n        }\n        return paragraphs;\n    };\n};\n\n/**\n * Return positions advance width\n *\n * @param positions - Positions\n * @returns {number} advance width\n */\nconst advanceWidth$2 = (positions) => {\n    return positions.reduce((acc, pos) => acc + (pos.xAdvance || 0), 0);\n};\n\n/**\n * Return run advance width\n *\n * @param run - Run\n * @returns Advance width\n */\nconst advanceWidth$1 = (run) => {\n    return advanceWidth$2(run.positions || []);\n};\n\n/**\n * Returns attributed string advancewidth\n *\n * @param attributedString - Attributed string\n * @returns Advance width\n */\nconst advanceWidth = (attributedString) => {\n    const reducer = (acc, run) => acc + advanceWidth$1(run);\n    return attributedString.runs.reduce(reducer, 0);\n};\n\nconst WHITE_SPACES_CODE = 32;\n/**\n * Check if glyph is white space\n *\n * @param glyph - Glyph\n * @returns Whether glyph is white space\n * */\nconst isWhiteSpace = (glyph) => {\n    const codePoints = glyph?.codePoints || [];\n    return codePoints.includes(WHITE_SPACES_CODE);\n};\n\n/**\n * Get white space leading positions\n *\n * @param run - Run\n * @returns White space leading positions\n */\nconst leadingPositions = (run) => {\n    const glyphs = run.glyphs || [];\n    const positions = run.positions || [];\n    const leadingWhitespaces = glyphs.findIndex((g) => !isWhiteSpace(g));\n    return positions.slice(0, leadingWhitespaces);\n};\n/**\n * Get run leading white space offset\n *\n * @param run - Run\n * @returns Leading white space offset\n */\nconst leadingOffset$1 = (run) => {\n    const positions = leadingPositions(run);\n    return positions.reduce((acc, pos) => acc + (pos.xAdvance || 0), 0);\n};\n\n/**\n * Get attributed string leading white space offset\n *\n * @param attributedString - Attributed string\n * @returns Leading white space offset\n */\nconst leadingOffset = (attributedString) => {\n    const runs = attributedString.runs || [];\n    return leadingOffset$1(runs[0]);\n};\n\n/**\n * Get white space trailing positions\n *\n * @param run run\n * @returns White space trailing positions\n */\nconst trailingPositions = (run) => {\n    const glyphs = reverse(run.glyphs || []);\n    const positions = reverse(run.positions || []);\n    const leadingWhitespaces = glyphs.findIndex((g) => !isWhiteSpace(g));\n    return positions.slice(0, leadingWhitespaces);\n};\n/**\n * Get run trailing white space offset\n *\n * @param run - Run\n * @returns Trailing white space offset\n */\nconst trailingOffset$1 = (run) => {\n    const positions = trailingPositions(run);\n    return positions.reduce((acc, pos) => acc + (pos.xAdvance || 0), 0);\n};\n\n/**\n * Get attributed string trailing white space offset\n *\n * @param attributedString - Attributed string\n * @returns Trailing white space offset\n */\nconst trailingOffset = (attributedString) => {\n    const runs = attributedString.runs || [];\n    return trailingOffset$1(last(runs));\n};\n\n/**\n * Drop last char of run\n *\n * @param run - Run\n * @returns Run without last char\n */\nconst dropLast$1 = (run) => {\n    return slice$1(0, run.end - run.start - 1, run);\n};\n\n/**\n * Drop last glyph\n *\n * @param attributedString - Attributed string\n * @returns Attributed string with new glyph\n */\nconst dropLast = (attributedString) => {\n    const string = dropLast$2(attributedString.string);\n    const runs = adjust(-1, dropLast$1, attributedString.runs);\n    return Object.assign({}, attributedString, { string, runs });\n};\n\nconst ALIGNMENT_FACTORS = { center: 0.5, right: 1 };\n/**\n * Remove new line char at the end of line if present\n *\n * @param line\n * @returns Line\n */\nconst removeNewLine = (line) => {\n    return last(line.string) === '\\n' ? dropLast(line) : line;\n};\nconst getOverflowLeft = (line) => {\n    return leadingOffset(line) + (line.overflowLeft || 0);\n};\nconst getOverflowRight = (line) => {\n    return trailingOffset(line) + (line.overflowRight || 0);\n};\n/**\n * Ignore whitespace at the start and end of a line for alignment\n *\n * @param line\n * @returns Line\n */\nconst adjustOverflow = (line) => {\n    const overflowLeft = getOverflowLeft(line);\n    const overflowRight = getOverflowRight(line);\n    const x = line.box.x - overflowLeft;\n    const width = line.box.width + overflowLeft + overflowRight;\n    const box = Object.assign({}, line.box, { x, width });\n    return Object.assign({}, line, { box, overflowLeft, overflowRight });\n};\n/**\n * Performs line justification by calling appropiate engine\n *\n * @param engines - Engines\n * @param options - Layout options\n * @param align - Text align\n */\nconst justifyLine$1 = (engines, options, align) => {\n    /**\n     * @param line - Line\n     * @returns Line\n     */\n    return (line) => {\n        const lineWidth = advanceWidth(line);\n        const alignFactor = ALIGNMENT_FACTORS[align] || 0;\n        const remainingWidth = Math.max(0, line.box.width - lineWidth);\n        const shouldJustify = align === 'justify' || lineWidth > line.box.width;\n        const x = line.box.x + remainingWidth * alignFactor;\n        const box = Object.assign({}, line.box, { x });\n        const newLine = Object.assign({}, line, { box });\n        return shouldJustify ? engines.justification(options)(newLine) : newLine;\n    };\n};\nconst finalizeLine = (line) => {\n    let lineAscent = 0;\n    let lineDescent = 0;\n    let lineHeight = 0;\n    let lineXAdvance = 0;\n    const runs = line.runs.map((run) => {\n        const height = height$1(run);\n        const ascent = ascent$1(run);\n        const descent$1 = descent(run);\n        const xAdvance = advanceWidth$1(run);\n        lineHeight = Math.max(lineHeight, height);\n        lineAscent = Math.max(lineAscent, ascent);\n        lineDescent = Math.max(lineDescent, descent$1);\n        lineXAdvance += xAdvance;\n        return Object.assign({}, run, { height, ascent, descent: descent$1, xAdvance });\n    });\n    return Object.assign({}, line, {\n        runs,\n        height: lineHeight,\n        ascent: lineAscent,\n        descent: lineDescent,\n        xAdvance: lineXAdvance,\n    });\n};\n/**\n * Finalize line by performing line justification\n * and text decoration (using appropiate engines)\n *\n * @param engines - Engines\n * @param options - Layout options\n */\nconst finalizeBlock = (engines, options) => {\n    /**\n     * @param line - Line\n     * @param i - Line index\n     * @param lines - Total lines\n     * @returns Line\n     */\n    return (line, index, lines) => {\n        const isLastFragment = index === lines.length - 1;\n        const style = line.runs?.[0]?.attributes || {};\n        const align = isLastFragment ? style.alignLastLine : style.align;\n        return compose(finalizeLine, engines.textDecoration(), justifyLine$1(engines, options, align), adjustOverflow, removeNewLine)(line);\n    };\n};\n/**\n * Finalize line block by performing line justification\n * and text decoration (using appropiate engines)\n *\n * @param engines - Engines\n * @param options - Layout options\n */\nconst finalizeFragments = (engines, options) => {\n    /**\n     * @param paragraphs - Paragraphs\n     * @returns Paragraphs\n     */\n    return (paragraphs) => {\n        const blockFinalizer = finalizeBlock(engines, options);\n        return paragraphs.map((paragraph) => paragraph.map(blockFinalizer));\n    };\n};\n\nconst ATTACHMENT_CODE = 0xfffc; // 65532\nconst isReplaceGlyph = (glyph) => glyph.codePoints.includes(ATTACHMENT_CODE);\n/**\n * Resolve attachments of run\n *\n * @param run\n * @returns Run\n */\nconst resolveRunAttachments = (run) => {\n    if (!run.positions)\n        return run;\n    const glyphs = run.glyphs || [];\n    const attachment = run.attributes?.attachment;\n    if (!attachment)\n        return run;\n    const positions = run.positions.map((position, i) => {\n        const glyph = glyphs[i];\n        if (attachment.width && isReplaceGlyph(glyph)) {\n            return Object.assign({}, position, { xAdvance: attachment.width });\n        }\n        return Object.assign({}, position);\n    });\n    return Object.assign({}, run, { positions });\n};\n/**\n * Resolve attachments for multiple paragraphs\n */\nconst resolveAttachments = () => {\n    /**\n     * @param attributedString - Attributed string\n     * @returns Attributed string\n     */\n    return (attributedString) => {\n        const runs = attributedString.runs.map(resolveRunAttachments);\n        const res = Object.assign({}, attributedString, { runs });\n        return res;\n    };\n};\n\n/**\n * @param attributes - Attributes\n * @returns Attributes with defaults\n */\nconst applyAttributes = (a) => {\n    return {\n        align: a.align || (a.direction === 'rtl' ? 'right' : 'left'),\n        alignLastLine: a.alignLastLine || (a.align === 'justify' ? 'left' : a.align || 'left'),\n        attachment: a.attachment || null,\n        backgroundColor: a.backgroundColor || null,\n        bullet: a.bullet || null,\n        characterSpacing: a.characterSpacing || 0,\n        color: a.color || 'black',\n        direction: a.direction || 'ltr',\n        features: a.features || [],\n        fill: a.fill !== false,\n        font: a.font || [],\n        fontSize: a.fontSize || 12,\n        hangingPunctuation: a.hangingPunctuation || false,\n        hyphenationFactor: a.hyphenationFactor || 0,\n        indent: a.indent || 0,\n        justificationFactor: a.justificationFactor || 1,\n        lineHeight: a.lineHeight || null,\n        lineSpacing: a.lineSpacing || 0,\n        link: a.link || null,\n        marginLeft: a.marginLeft || a.margin || 0,\n        marginRight: a.marginRight || a.margin || 0,\n        opacity: a.opacity,\n        paddingTop: a.paddingTop || a.padding || 0,\n        paragraphSpacing: a.paragraphSpacing || 0,\n        script: a.script || null,\n        shrinkFactor: a.shrinkFactor || 0,\n        strike: a.strike || false,\n        strikeColor: a.strikeColor || a.color || 'black',\n        strikeStyle: a.strikeStyle || 'solid',\n        stroke: a.stroke || false,\n        underline: a.underline || false,\n        underlineColor: a.underlineColor || a.color || 'black',\n        underlineStyle: a.underlineStyle || 'solid',\n        verticalAlign: a.verticalAlign || null,\n        wordSpacing: a.wordSpacing || 0,\n        yOffset: a.yOffset || 0,\n    };\n};\n/**\n * Apply default style to run\n *\n * @param run - Run\n * @returns Run with default styles\n */\nconst applyRunStyles = (run) => {\n    const attributes = applyAttributes(run.attributes);\n    return Object.assign({}, run, { attributes });\n};\n/**\n * Apply default attributes for an attributed string\n */\nconst applyDefaultStyles = () => {\n    return (attributedString) => {\n        const string = attributedString.string || '';\n        const runs = (attributedString.runs || []).map(applyRunStyles);\n        return { string, runs };\n    };\n};\n\n/**\n * Apply scaling and yOffset for verticalAlign 'sub' and 'super'.\n */\nconst verticalAlignment = () => {\n    /**\n     * @param attributedString - Attributed string\n     * @returns Attributed string\n     */\n    return (attributedString) => {\n        attributedString.runs.forEach((run) => {\n            const { attributes } = run;\n            const { verticalAlign } = attributes;\n            if (verticalAlign === 'sub') {\n                attributes.yOffset = -0.2;\n            }\n            else if (verticalAlign === 'super') {\n                attributes.yOffset = 0.4;\n            }\n        });\n        return attributedString;\n    };\n};\n\nconst bidi$1 = bidiFactory();\n/**\n * @param runs\n * @returns Bidi levels\n */\nconst getBidiLevels = (runs) => {\n    return runs.reduce((acc, run) => {\n        const length = run.end - run.start;\n        const levels = repeat(run.attributes.bidiLevel, length);\n        return acc.concat(levels);\n    }, []);\n};\n/**\n * Perform bidi mirroring\n */\nconst mirrorString = () => {\n    /**\n     * @param attributedString - Attributed string\n     * @returns Attributed string\n     */\n    return (attributedString) => {\n        const levels = getBidiLevels(attributedString.runs);\n        let updatedString = '';\n        attributedString.string.split('').forEach((char, index) => {\n            const isRTL = levels[index] % 2 === 1;\n            const mirroredChar = isRTL\n                ? bidi$1.getMirroredCharacter(attributedString.string.charAt(index))\n                : null;\n            updatedString += mirroredChar || char;\n        });\n        const result = {\n            ...attributedString,\n            string: updatedString,\n        };\n        return result;\n    };\n};\n\n/**\n * A LayoutEngine is the main object that performs text layout.\n * It accepts an AttributedString and a Container object\n * to layout text into, and uses several helper objects to perform\n * various layout tasks. These objects can be overridden to customize\n * layout behavior.\n */\nconst layoutEngine = (engines) => {\n    return (attributedString, container, options = {}) => {\n        const processParagraph = compose(resolveYOffset(), resolveAttachments(), verticalAlignment(), wrapWords(engines, options), generateGlyphs(), mirrorString(), preprocessRuns(engines));\n        const processParagraphs = (paragraphs) => paragraphs.map(processParagraph);\n        return compose(finalizeFragments(engines, options), bidiReordering(), typesetter(engines, options, container), processParagraphs, splitParagraphs(), applyDefaultStyles())(attributedString);\n    };\n};\n\nconst bidi = bidiFactory();\nconst bidiEngine = () => {\n    /**\n     * @param attributedString - Attributed string\n     * @returns Attributed string\n     */\n    return (attributedString) => {\n        const { string } = attributedString;\n        const direction = attributedString.runs[0]?.attributes.direction;\n        const { levels } = bidi.getEmbeddingLevels(string, direction);\n        let lastLevel = null;\n        let lastIndex = 0;\n        let index = 0;\n        const runs = [];\n        for (let i = 0; i < levels.length; i += 1) {\n            const level = levels[i];\n            if (level !== lastLevel) {\n                if (lastLevel !== null) {\n                    runs.push({\n                        start: lastIndex,\n                        end: index,\n                        attributes: { bidiLevel: lastLevel },\n                    });\n                }\n                lastIndex = index;\n                lastLevel = level;\n            }\n            index += 1;\n        }\n        if (lastIndex < string.length) {\n            runs.push({\n                start: lastIndex,\n                end: string.length,\n                attributes: { bidiLevel: lastLevel },\n            });\n        }\n        const result = { string, runs };\n        return result;\n    };\n};\n\nconst INFINITY = 10000;\nconst getNextBreakpoint = (subnodes, widths, lineNumber) => {\n    let position = null;\n    let minimumBadness = Infinity;\n    const sum = { width: 0, stretch: 0, shrink: 0 };\n    const lineLength = widths[Math.min(lineNumber, widths.length - 1)];\n    const calculateRatio = (node) => {\n        const stretch = 'stretch' in node ? node.stretch : null;\n        if (sum.width < lineLength) {\n            if (!stretch)\n                return INFINITY;\n            return sum.stretch - stretch > 0\n                ? (lineLength - sum.width) / sum.stretch\n                : INFINITY;\n        }\n        const shrink = 'shrink' in node ? node.shrink : null;\n        if (sum.width > lineLength) {\n            if (!shrink)\n                return INFINITY;\n            return sum.shrink - shrink > 0\n                ? (lineLength - sum.width) / sum.shrink\n                : INFINITY;\n        }\n        return 0;\n    };\n    for (let i = 0; i < subnodes.length; i += 1) {\n        const node = subnodes[i];\n        if (node.type === 'box') {\n            sum.width += node.width;\n        }\n        if (node.type === 'glue') {\n            sum.width += node.width;\n            sum.stretch += node.stretch;\n            sum.shrink += node.shrink;\n        }\n        if (sum.width - sum.shrink > lineLength) {\n            if (position === null) {\n                let j = i === 0 ? i + 1 : i;\n                while (j < subnodes.length &&\n                    (subnodes[j].type === 'glue' || subnodes[j].type === 'penalty')) {\n                    j++;\n                }\n                position = j - 1;\n            }\n            break;\n        }\n        if (node.type === 'penalty' || node.type === 'glue') {\n            const ratio = calculateRatio(node);\n            const penalty = node.type === 'penalty' ? node.penalty : 0;\n            const badness = 100 * Math.abs(ratio) ** 3 + penalty;\n            if (minimumBadness >= badness) {\n                position = i;\n                minimumBadness = badness;\n            }\n        }\n    }\n    return sum.width - sum.shrink > lineLength ? position : null;\n};\nconst applyBestFit = (nodes, widths) => {\n    let count = 0;\n    let lineNumber = 0;\n    let subnodes = nodes;\n    const breakpoints = [0];\n    while (subnodes.length > 0) {\n        const breakpoint = getNextBreakpoint(subnodes, widths, lineNumber);\n        if (breakpoint !== null) {\n            count += breakpoint;\n            breakpoints.push(count);\n            subnodes = subnodes.slice(breakpoint + 1, subnodes.length);\n            count++;\n            lineNumber++;\n        }\n        else {\n            subnodes = [];\n        }\n    }\n    return breakpoints;\n};\n\n/* eslint-disable max-classes-per-file */\nclass LinkedListNode {\n    data;\n    prev;\n    next;\n    constructor(data) {\n        this.data = data;\n        this.prev = null;\n        this.next = null;\n    }\n}\nclass LinkedList {\n    static Node = LinkedListNode;\n    head;\n    tail;\n    listSize;\n    listLength;\n    constructor() {\n        this.head = null;\n        this.tail = null;\n        this.listSize = 0;\n        this.listLength = 0;\n    }\n    isLinked(node) {\n        return !((node &&\n            node.prev === null &&\n            node.next === null &&\n            this.tail !== node &&\n            this.head !== node) ||\n            this.isEmpty());\n    }\n    size() {\n        return this.listSize;\n    }\n    isEmpty() {\n        return this.listSize === 0;\n    }\n    first() {\n        return this.head;\n    }\n    last() {\n        return this.last;\n    }\n    forEach(callback) {\n        let node = this.head;\n        while (node !== null) {\n            callback(node);\n            node = node.next;\n        }\n    }\n    at(i) {\n        let node = this.head;\n        let index = 0;\n        if (i >= this.listLength || i < 0) {\n            return null;\n        }\n        while (node !== null) {\n            if (i === index) {\n                return node;\n            }\n            node = node.next;\n            index += 1;\n        }\n        return null;\n    }\n    insertAfter(node, newNode) {\n        if (!this.isLinked(node))\n            return this;\n        newNode.prev = node;\n        newNode.next = node.next;\n        if (node.next === null) {\n            this.tail = newNode;\n        }\n        else {\n            node.next.prev = newNode;\n        }\n        node.next = newNode;\n        this.listSize += 1;\n        return this;\n    }\n    insertBefore(node, newNode) {\n        if (!this.isLinked(node))\n            return this;\n        newNode.prev = node.prev;\n        newNode.next = node;\n        if (node.prev === null) {\n            this.head = newNode;\n        }\n        else {\n            node.prev.next = newNode;\n        }\n        node.prev = newNode;\n        this.listSize += 1;\n        return this;\n    }\n    push(node) {\n        if (this.head === null) {\n            this.unshift(node);\n        }\n        else {\n            this.insertAfter(this.tail, node);\n        }\n        return this;\n    }\n    unshift(node) {\n        if (this.head === null) {\n            this.head = node;\n            this.tail = node;\n            node.prev = null;\n            node.next = null;\n            this.listSize += 1;\n        }\n        else {\n            this.insertBefore(this.head, node);\n        }\n        return this;\n    }\n    remove(node) {\n        if (!this.isLinked(node))\n            return this;\n        if (node.prev === null) {\n            this.head = node.next;\n        }\n        else {\n            node.prev.next = node.next;\n        }\n        if (node.next === null) {\n            this.tail = node.prev;\n        }\n        else {\n            node.next.prev = node.prev;\n        }\n        this.listSize -= 1;\n        return this;\n    }\n}\n\n/**\n * Licensed under the new BSD License.\n * Copyright 2009-2010, Bram Stein\n * All rights reserved.\n */\nfunction breakpoint(position, demerits, line, fitnessClass, totals, previous) {\n    return {\n        position,\n        demerits,\n        line,\n        fitnessClass,\n        totals: totals || {\n            width: 0,\n            stretch: 0,\n            shrink: 0,\n        },\n        previous,\n    };\n}\nfunction computeCost(nodes, lineLengths, sum, end, active, currentLine) {\n    let width = sum.width - active.totals.width;\n    let stretch = 0;\n    let shrink = 0;\n    // If the current line index is within the list of linelengths, use it, otherwise use\n    // the last line length of the list.\n    const lineLength = currentLine < lineLengths.length\n        ? lineLengths[currentLine - 1]\n        : lineLengths[lineLengths.length - 1];\n    if (nodes[end].type === 'penalty') {\n        width += nodes[end].width;\n    }\n    // Calculate the stretch ratio\n    if (width < lineLength) {\n        stretch = sum.stretch - active.totals.stretch;\n        if (stretch > 0) {\n            return (lineLength - width) / stretch;\n        }\n        return linebreak.infinity;\n    }\n    // Calculate the shrink ratio\n    if (width > lineLength) {\n        shrink = sum.shrink - active.totals.shrink;\n        if (shrink > 0) {\n            return (lineLength - width) / shrink;\n        }\n        return linebreak.infinity;\n    }\n    // perfect match\n    return 0;\n}\n// Add width, stretch and shrink values from the current\n// break point up to the next box or forced penalty.\nfunction computeSum(nodes, sum, breakPointIndex) {\n    const result = {\n        width: sum.width,\n        stretch: sum.stretch,\n        shrink: sum.shrink,\n    };\n    for (let i = breakPointIndex; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.type === 'glue') {\n            result.width += node.width;\n            result.stretch += node.stretch;\n            result.shrink += node.shrink;\n        }\n        else if (node.type === 'box' ||\n            (node.type === 'penalty' &&\n                node.penalty === -linebreak.infinity &&\n                i > breakPointIndex)) {\n            break;\n        }\n    }\n    return result;\n}\nfunction findBestBreakpoints(activeNodes) {\n    const breakpoints = [];\n    if (activeNodes.size() === 0)\n        return [];\n    let tmp = { data: { demerits: Infinity } };\n    // Find the best active node (the one with the least total demerits.)\n    activeNodes.forEach((node) => {\n        if (node.data.demerits < tmp.data.demerits) {\n            tmp = node;\n        }\n    });\n    while (tmp !== null) {\n        breakpoints.push(tmp.data.position);\n        tmp = tmp.data.previous;\n    }\n    return breakpoints.reverse();\n}\n/**\n * @param nodes\n * @param availableWidths\n * @param tolerance\n * @preserve Knuth and Plass line breaking algorithm in JavaScript\n */\nconst linebreak = (nodes, availableWidths, tolerance) => {\n    // Demerits are used as a way to penalize bad line breaks\n    //  - line: applied to each line, depending on how much spaces need to stretch or shrink\n    //  - flagged: applied when consecutive lines end in hyphenation\n    //  - fitness: algorithm groups lines into fitness classes based on how loose or tight the spacing is.\n    //             if a paragraph has consecutive lines from different fitness classes,\n    //             a fitness demerit is applied to maintain visual consistency.\n    const options = {\n        demerits: { line: 10, flagged: 100, fitness: 3000 },\n        tolerance: tolerance || 3,\n    };\n    const activeNodes = new LinkedList();\n    const sum = { width: 0, stretch: 0, shrink: 0 };\n    const lineLengths = availableWidths;\n    // Add an active node for the start of the paragraph.\n    activeNodes.push(new LinkedList.Node(breakpoint(0, 0, 0, 0, undefined, null)));\n    // The main loop of the algorithm\n    function mainLoop(node, index, nodes) {\n        let active = activeNodes.first();\n        // The inner loop iterates through all the active nodes with line < currentLine and then\n        // breaks out to insert the new active node candidates before looking at the next active\n        // nodes for the next lines. The result of this is that the active node list is always\n        // sorted by line number.\n        while (active !== null) {\n            let currentLine = 0;\n            // Candidates fo each fitness class\n            const candidates = [\n                { active: undefined, demerits: Infinity },\n                { active: undefined, demerits: Infinity },\n                { active: undefined, demerits: Infinity },\n                { active: undefined, demerits: Infinity },\n            ];\n            // Iterate through the linked list of active nodes to find new potential active nodes and deactivate current active nodes.\n            while (active !== null) {\n                currentLine = active.data.line + 1;\n                const ratio = computeCost(nodes, lineLengths, sum, index, active.data, currentLine);\n                // Deactive nodes when the distance between the current active node and the\n                // current node becomes too large (i.e. it exceeds the stretch limit and the stretch\n                // ratio becomes negative) or when the current node is a forced break (i.e. the end\n                // of the paragraph when we want to remove all active nodes, but possibly have a final\n                // candidate active node---if the paragraph can be set using the given tolerance value.)\n                if (ratio < -1 ||\n                    (node.type === 'penalty' && node.penalty === -linebreak.infinity)) {\n                    activeNodes.remove(active);\n                }\n                // If the ratio is within the valid range of -1 <= ratio <= tolerance calculate the\n                // total demerits and record a candidate active node.\n                if (ratio >= -1 && ratio <= options.tolerance) {\n                    const badness = 100 * Math.pow(Math.abs(ratio), 3);\n                    let demerits = 0;\n                    // Positive penalty\n                    if (node.type === 'penalty' && node.penalty >= 0) {\n                        demerits =\n                            Math.pow(options.demerits.line + badness, 2) +\n                                Math.pow(node.penalty, 2);\n                        // Negative penalty but not a forced break\n                    }\n                    else if (node.type === 'penalty' &&\n                        node.penalty !== -linebreak.infinity) {\n                        demerits =\n                            Math.pow(options.demerits.line + badness, 2) -\n                                Math.pow(node.penalty, 2);\n                        // All other cases\n                    }\n                    else {\n                        demerits = Math.pow(options.demerits.line + badness, 2);\n                    }\n                    if (node.type === 'penalty' &&\n                        nodes[active.data.position].type === 'penalty') {\n                        demerits +=\n                            options.demerits.flagged *\n                                node.flagged *\n                                // @ts-expect-error node is penalty here\n                                nodes[active.data.position].flagged;\n                    }\n                    // Calculate the fitness class for this candidate active node.\n                    let currentClass;\n                    if (ratio < -0.5) {\n                        currentClass = 0;\n                    }\n                    else if (ratio <= 0.5) {\n                        currentClass = 1;\n                    }\n                    else if (ratio <= 1) {\n                        currentClass = 2;\n                    }\n                    else {\n                        currentClass = 3;\n                    }\n                    // Add a fitness penalty to the demerits if the fitness classes of two adjacent lines differ too much.\n                    if (Math.abs(currentClass - active.data.fitnessClass) > 1) {\n                        demerits += options.demerits.fitness;\n                    }\n                    // Add the total demerits of the active node to get the total demerits of this candidate node.\n                    demerits += active.data.demerits;\n                    // Only store the best candidate for each fitness class\n                    if (demerits < candidates[currentClass].demerits) {\n                        candidates[currentClass] = { active, demerits };\n                    }\n                }\n                active = active.next;\n                // Stop iterating through active nodes to insert new candidate active nodes in the active list\n                // before moving on to the active nodes for the next line.\n                // TODO: The Knuth and Plass paper suggests a conditional for currentLine < j0. This means paragraphs\n                // with identical line lengths will not be sorted by line number. Find out if that is a desirable outcome.\n                // For now I left this out, as it only adds minimal overhead to the algorithm and keeping the active node\n                // list sorted has a higher priority.\n                if (active !== null && active.data.line >= currentLine) {\n                    break;\n                }\n            }\n            const tmpSum = computeSum(nodes, sum, index);\n            for (let fitnessClass = 0; fitnessClass < candidates.length; fitnessClass += 1) {\n                const candidate = candidates[fitnessClass];\n                if (candidate.demerits === Infinity)\n                    continue;\n                const newNode = new LinkedList.Node(breakpoint(index, candidate.demerits, candidate.active.data.line + 1, fitnessClass, tmpSum, candidate.active));\n                if (active !== null) {\n                    activeNodes.insertBefore(active, newNode);\n                }\n                else {\n                    activeNodes.push(newNode);\n                }\n            }\n        }\n    }\n    nodes.forEach((node, index, nodes) => {\n        if (node.type === 'box') {\n            sum.width += node.width;\n            return;\n        }\n        if (node.type === 'glue') {\n            const precedesBox = index > 0 && nodes[index - 1].type === 'box';\n            if (precedesBox)\n                mainLoop(node, index, nodes);\n            sum.width += node.width;\n            sum.stretch += node.stretch;\n            sum.shrink += node.shrink;\n            return;\n        }\n        if (node.type === 'penalty' && node.penalty !== linebreak.infinity) {\n            mainLoop(node, index, nodes);\n        }\n    });\n    return findBestBreakpoints(activeNodes);\n};\nlinebreak.infinity = 10000;\nlinebreak.glue = (width, start, end, stretch, shrink) => ({\n    type: 'glue',\n    start,\n    end,\n    width,\n    stretch,\n    shrink,\n});\nlinebreak.box = (width, start, end, hyphenated = false) => ({\n    type: 'box',\n    width,\n    start,\n    end,\n    hyphenated,\n});\nlinebreak.penalty = (width, penalty, flagged) => ({\n    type: 'penalty',\n    width,\n    penalty,\n    flagged,\n});\n\n/**\n * Add scalar to run\n *\n * @param index - Scalar\n * @param run - Run\n * @returns Added run\n */\nconst add = (index, run) => {\n    const start = run.start + index;\n    const end = run.end + index;\n    return Object.assign({}, run, { start, end });\n};\n\n/**\n * Get run length\n *\n * @param run - Run\n * @returns Length\n */\nconst length = (run) => {\n    return run.end - run.start;\n};\n\n/**\n * Concats two runs into one\n *\n * @param runA - First run\n * @param runB - Second run\n * @returns Concatenated run\n */\nconst concat = (runA, runB) => {\n    const end = runA.end + length(runB);\n    const glyphs = (runA.glyphs || []).concat(runB.glyphs || []);\n    const positions = (runA.positions || []).concat(runB.positions || []);\n    const attributes = Object.assign({}, runA.attributes, runB.attributes);\n    const runAIndices = runA.glyphIndices || [];\n    const runALastIndex = last(runAIndices) || 0;\n    const runBIndices = (runB.glyphIndices || []).map((i) => i + runALastIndex + 1);\n    const glyphIndices = normalize(runAIndices.concat(runBIndices));\n    return Object.assign({}, runA, {\n        end,\n        glyphs,\n        positions,\n        attributes,\n        glyphIndices,\n    });\n};\n\n/**\n * Insert glyph to run in the given index\n *\n * @param index - Index\n * @param glyph - Glyph\n * @param run - Run\n * @returns Run with glyph\n */\nconst insertGlyph$1 = (index, glyph, run) => {\n    if (!glyph)\n        return run;\n    // Split resolves ligature splitting in case new glyph breaks some\n    const leadingRun = slice$1(0, index, run);\n    const trailingRun = slice$1(index, Infinity, run);\n    return concat(append$1(glyph, leadingRun), trailingRun);\n};\n/**\n * Insert either glyph or code point to run in the given index\n *\n * @param index - Index\n * @param value - Glyph or codePoint\n * @param run - Run\n * @returns Run with glyph\n */\nconst insert = (index, value, run) => {\n    const font = getFont(run);\n    const glyph = isNumber(value) ? fromCodePoint(value, font) : value;\n    return insertGlyph$1(index, glyph, run);\n};\n\n/**\n * Get run index at char index\n *\n * @param index - Char index\n * @param attributedString - Attributed string\n * @returns Run index\n */\nconst runIndexAt = (index, attributedString) => {\n    return runIndexAt$1(index, attributedString.runs);\n};\n\n/**\n * Insert glyph into attributed string\n *\n * @param index - Index\n * @param glyph - Glyph or code point\n * @param attributedString - Attributed string\n * @returns Attributed string with new glyph\n */\nconst insertGlyph = (index, glyph, attributedString) => {\n    const runIndex = runIndexAt(index, attributedString);\n    // Add glyph to the end if run index invalid\n    if (runIndex === -1)\n        return append(glyph, attributedString);\n    const codePoints = [glyph] ;\n    const string = attributedString.string.slice(0, index) +\n        stringFromCodePoints(codePoints) +\n        attributedString.string.slice(index);\n    const runs = attributedString.runs.map((run, i) => {\n        if (i === runIndex)\n            return insert(index - run.start, glyph, run);\n        if (i > runIndex)\n            return add(codePoints.length, run);\n        return run;\n    });\n    return Object.assign({}, attributedString, { string, runs });\n};\n\n/**\n * Advance width between two string indices\n *\n * @param start - Glyph index\n * @param end - Glyph index\n * @param run - Run\n * @returns Advanced width run\n */\nconst advanceWidthBetween$1 = (start, end, run) => {\n    const runStart = run.start || 0;\n    const glyphStartIndex = Math.max(0, glyphIndexAt(start - runStart, run));\n    const glyphEndIndex = Math.max(0, glyphIndexAt(end - runStart, run));\n    const positions = (run.positions || []).slice(glyphStartIndex, glyphEndIndex);\n    return advanceWidth$2(positions);\n};\n\n/**\n * Advance width between start and end\n * Does not consider ligature splitting for the moment.\n * Check performance impact on supporting this\n *\n * @param start - Start offset\n * @param end - End offset\n * @param attributedString\n * @returns Advance width\n */\nconst advanceWidthBetween = (start, end, attributedString) => {\n    const runs = filter(start, end, attributedString.runs);\n    return runs.reduce((acc, run) => acc + advanceWidthBetween$1(start, end, run), 0);\n};\n\nconst HYPHEN = 0x002d;\nconst TOLERANCE_STEPS = 5;\nconst TOLERANCE_LIMIT = 50;\nconst opts = {\n    width: 3,\n    stretch: 6,\n    shrink: 9,\n};\n/**\n * Slice attributed string to many lines\n *\n * @param attributedString - Attributed string\n * @param nodes\n * @param breaks\n * @returns Attributed strings\n */\nconst breakLines = (attributedString, nodes, breaks) => {\n    let start = 0;\n    let end = null;\n    const lines = breaks.reduce((acc, breakPoint) => {\n        const node = nodes[breakPoint];\n        const prevNode = nodes[breakPoint - 1];\n        // Last breakpoint corresponds to K&P mandatory final glue\n        if (breakPoint === nodes.length - 1)\n            return acc;\n        let line;\n        if (node.type === 'penalty') {\n            // @ts-expect-error penalty node will always preceed box or glue node\n            end = prevNode.end;\n            line = slice(start, end, attributedString);\n            line = insertGlyph(line.string.length, HYPHEN, line);\n        }\n        else {\n            end = node.end;\n            line = slice(start, end, attributedString);\n        }\n        start = end;\n        return [...acc, line];\n    }, []);\n    // Last line\n    lines.push(slice(start, attributedString.string.length, attributedString));\n    return lines;\n};\n/**\n * Return Knuth & Plass nodes based on line and previously calculated syllables\n *\n * @param attributedString - Attributed string\n * @param attributes - Attributes\n * @param options - Layout options\n * @returns ?\n */\nconst getNodes = (attributedString, { align }, options) => {\n    let start = 0;\n    const hyphenWidth = 5;\n    const { syllables } = attributedString;\n    const hyphenPenalty = options.hyphenationPenalty || (align === 'justify' ? 100 : 600);\n    const result = syllables.reduce((acc, s, index) => {\n        const width = advanceWidthBetween(start, start + s.length, attributedString);\n        if (s.trim() === '') {\n            const stretch = (width * opts.width) / opts.stretch;\n            const shrink = (width * opts.width) / opts.shrink;\n            const end = start + s.length;\n            // Add glue node. Glue nodes are used to fill the space between words.\n            acc.push(linebreak.glue(width, start, end, stretch, shrink));\n        }\n        else {\n            const hyphenated = syllables[index + 1] !== ' ';\n            const end = start + s.length;\n            // Add box node. Box nodes are used to represent words.\n            acc.push(linebreak.box(width, start, end, hyphenated));\n            if (syllables[index + 1] && hyphenated) {\n                // Add penalty node. Penalty nodes are used to represent hyphenation points.\n                acc.push(linebreak.penalty(hyphenWidth, hyphenPenalty, 1));\n            }\n        }\n        start += s.length;\n        return acc;\n    }, []);\n    // Add mandatory final glue\n    result.push(linebreak.glue(0, start, start, linebreak.infinity, 0));\n    result.push(linebreak.penalty(0, -linebreak.infinity, 1));\n    return result;\n};\n/**\n * @param attributedString - Attributed string\n * @returns Attributes\n */\nconst getAttributes = (attributedString) => {\n    return attributedString.runs?.[0]?.attributes || {};\n};\n/**\n * Performs Knuth & Plass line breaking algorithm\n * Fallbacks to best fit algorithm if latter not successful\n *\n * @param options - Layout options\n */\nconst linebreaker = (options) => {\n    /**\n     * @param attributedString - Attributed string\n     * @param availableWidths - Available widths\n     * @returns Attributed string\n     */\n    return (attributedString, availableWidths) => {\n        let tolerance = options.tolerance || 4;\n        const attributes = getAttributes(attributedString);\n        const nodes = getNodes(attributedString, attributes, options);\n        let breaks = linebreak(nodes, availableWidths, tolerance);\n        // Try again with a higher tolerance if the line breaking failed.\n        while (breaks.length === 0 && tolerance < TOLERANCE_LIMIT) {\n            tolerance += TOLERANCE_STEPS;\n            breaks = linebreak(nodes, availableWidths, tolerance);\n        }\n        if (breaks.length === 0 || (breaks.length === 1 && breaks[0] === 0)) {\n            breaks = applyBestFit(nodes, availableWidths);\n        }\n        return breakLines(attributedString, nodes, breaks.slice(1));\n    };\n};\n\nvar Direction;\n(function (Direction) {\n    Direction[Direction[\"GROW\"] = 0] = \"GROW\";\n    Direction[Direction[\"SHRINK\"] = 1] = \"SHRINK\";\n})(Direction || (Direction = {}));\nconst WHITESPACE_PRIORITY = 1;\nconst LETTER_PRIORITY = 2;\nconst EXPAND_WHITESPACE_FACTOR = {\n    before: 0.5,\n    after: 0.5,\n    priority: WHITESPACE_PRIORITY,\n    unconstrained: false,\n};\nconst EXPAND_CHAR_FACTOR = {\n    before: 0.14453125, // 37/256\n    after: 0.14453125,\n    priority: LETTER_PRIORITY,\n    unconstrained: false,\n};\nconst SHRINK_WHITESPACE_FACTOR = {\n    before: -0.04296875, // -11/256\n    after: -0.04296875,\n    priority: WHITESPACE_PRIORITY,\n    unconstrained: false,\n};\nconst SHRINK_CHAR_FACTOR = {\n    before: -0.04296875,\n    after: -0.04296875,\n    priority: LETTER_PRIORITY,\n    unconstrained: false,\n};\nconst getCharFactor = (direction, options) => {\n    const expandCharFactor = options.expandCharFactor || {};\n    const shrinkCharFactor = options.shrinkCharFactor || {};\n    return direction === Direction.GROW\n        ? Object.assign({}, EXPAND_CHAR_FACTOR, expandCharFactor)\n        : Object.assign({}, SHRINK_CHAR_FACTOR, shrinkCharFactor);\n};\nconst getWhitespaceFactor = (direction, options) => {\n    const expandWhitespaceFactor = options.expandWhitespaceFactor || {};\n    const shrinkWhitespaceFactor = options.shrinkWhitespaceFactor || {};\n    return direction === Direction.GROW\n        ? Object.assign({}, EXPAND_WHITESPACE_FACTOR, expandWhitespaceFactor)\n        : Object.assign({}, SHRINK_WHITESPACE_FACTOR, shrinkWhitespaceFactor);\n};\nconst factor = (direction, options) => (glyphs) => {\n    const charFactor = getCharFactor(direction, options);\n    const whitespaceFactor = getWhitespaceFactor(direction, options);\n    const factors = [];\n    for (let index = 0; index < glyphs.length; index += 1) {\n        let f;\n        const glyph = glyphs[index];\n        if (isWhiteSpace(glyph)) {\n            f = Object.assign({}, whitespaceFactor);\n            if (index === glyphs.length - 1) {\n                f.before = 0;\n                if (index > 0) {\n                    factors[index - 1].after = 0;\n                }\n            }\n        }\n        else if (glyph.isMark && index > 0) {\n            f = Object.assign({}, factors[index - 1]);\n            f.before = 0;\n            factors[index - 1].after = 0;\n        }\n        else {\n            f = Object.assign({}, charFactor);\n        }\n        factors.push(f);\n    }\n    return factors;\n};\nconst getFactors = (gap, line, options) => {\n    const direction = gap > 0 ? Direction.GROW : Direction.SHRINK;\n    const getFactor = factor(direction, options);\n    const factors = line.runs.reduce((acc, run) => {\n        return acc.concat(getFactor(run.glyphs));\n    }, []);\n    factors[0].before = 0;\n    factors[factors.length - 1].after = 0;\n    return factors;\n};\n\nconst KASHIDA_PRIORITY = 0;\nconst NULL_PRIORITY = 3;\nconst getDistances = (gap, factors) => {\n    let total = 0;\n    const priorities = [];\n    const unconstrained = [];\n    for (let priority = KASHIDA_PRIORITY; priority <= NULL_PRIORITY; priority += 1) {\n        priorities[priority] = unconstrained[priority] = 0;\n    }\n    // sum the factors at each priority\n    for (let j = 0; j < factors.length; j += 1) {\n        const f = factors[j];\n        const sum = f.before + f.after;\n        total += sum;\n        priorities[f.priority] += sum;\n        if (f.unconstrained) {\n            unconstrained[f.priority] += sum;\n        }\n    }\n    // choose the priorities that need to be applied\n    let highestPriority = -1;\n    let highestPrioritySum = 0;\n    let remainingGap = gap;\n    let priority;\n    for (priority = KASHIDA_PRIORITY; priority <= NULL_PRIORITY; priority += 1) {\n        const prioritySum = priorities[priority];\n        if (prioritySum !== 0) {\n            if (highestPriority === -1) {\n                highestPriority = priority;\n                highestPrioritySum = prioritySum;\n            }\n            // if this priority covers the remaining gap, we're done\n            if (Math.abs(remainingGap) <= Math.abs(prioritySum)) {\n                priorities[priority] = remainingGap / prioritySum;\n                unconstrained[priority] = 0;\n                remainingGap = 0;\n                break;\n            }\n            // mark that we need to use 100% of the adjustment from\n            // this priority, and subtract the space that it consumes\n            priorities[priority] = 1;\n            remainingGap -= prioritySum;\n            // if this priority has unconstrained glyphs, let them consume the remaining space\n            if (unconstrained[priority] !== 0) {\n                unconstrained[priority] = remainingGap / unconstrained[priority];\n                remainingGap = 0;\n                break;\n            }\n        }\n    }\n    // zero out remaining priorities (if any)\n    for (let p = priority + 1; p <= NULL_PRIORITY; p += 1) {\n        priorities[p] = 0;\n        unconstrained[p] = 0;\n    }\n    // if there is still space left over, assign it to the highest priority that we saw.\n    // this violates their factors, but it only happens in extreme cases\n    if (remainingGap > 0 && highestPriority > -1) {\n        priorities[highestPriority] =\n            (highestPrioritySum + (gap - total)) / highestPrioritySum;\n    }\n    // create and return an array of distances to add to each glyph's advance\n    const distances = [];\n    for (let index = 0; index < factors.length; index += 1) {\n        // the distance to add to this glyph is the sum of the space to add\n        // after this glyph, and the space to add before the next glyph\n        const f = factors[index];\n        const next = factors[index + 1];\n        let dist = f.after * priorities[f.priority];\n        if (next) {\n            dist += next.before * priorities[next.priority];\n        }\n        // if this glyph is unconstrained, add the unconstrained distance as well\n        if (f.unconstrained) {\n            dist += f.after * unconstrained[f.priority];\n            if (next) {\n                dist += next.before * unconstrained[next.priority];\n            }\n        }\n        distances.push(dist);\n    }\n    return distances;\n};\n\n/**\n * Adjust run positions by given distances\n *\n * @param distances\n * @param line\n * @returns Line\n */\nconst justifyLine = (distances, line) => {\n    let index = 0;\n    for (const run of line.runs) {\n        for (const position of run.positions) {\n            position.xAdvance += distances[index++];\n        }\n    }\n    return line;\n};\n/**\n * A JustificationEngine is used by a Typesetter to perform line fragment\n * justification. This implementation is based on a description of Apple's\n * justification algorithm from a PDF in the Apple Font Tools package.\n *\n * @param options - Layout options\n */\nconst justification = (options) => {\n    /**\n     * @param line\n     * @returns Line\n     */\n    return (line) => {\n        const gap = line.box.width - advanceWidth(line);\n        if (gap === 0)\n            return line; // Exact fit\n        const factors = getFactors(gap, line, options);\n        const distances = getDistances(gap, factors);\n        return justifyLine(distances, line);\n    };\n};\n\n/**\n * Returns attributed string ascent\n *\n * @param attributedString - Attributed string\n * @returns Ascent\n */\nconst ascent = (attributedString) => {\n    const reducer = (acc, run) => Math.max(acc, ascent$1(run));\n    return attributedString.runs.reduce(reducer, 0);\n};\n\n// The base font size used for calculating underline thickness.\nconst BASE_FONT_SIZE = 12;\n/**\n * A TextDecorationEngine is used by a Typesetter to generate\n * DecorationLines for a line fragment, including underlines\n * and strikes.\n */\nconst textDecoration = () => (line) => {\n    let x = line.overflowLeft || 0;\n    const overflowRight = line.overflowRight || 0;\n    const maxX = advanceWidth(line) - overflowRight;\n    line.decorationLines = [];\n    for (let i = 0; i < line.runs.length; i += 1) {\n        const run = line.runs[i];\n        const width = Math.min(maxX - x, advanceWidth$1(run));\n        const thickness = Math.max(0.5, Math.floor(run.attributes.fontSize / BASE_FONT_SIZE));\n        if (run.attributes.underline) {\n            const rect = {\n                x,\n                y: ascent(line) + thickness * 2,\n                width,\n                height: thickness,\n            };\n            const decorationLine = {\n                rect,\n                opacity: run.attributes.opacity,\n                color: run.attributes.underlineColor || 'black',\n                style: run.attributes.underlineStyle || 'solid',\n            };\n            line.decorationLines.push(decorationLine);\n        }\n        if (run.attributes.strike) {\n            const y = ascent(line) - ascent$1(run) / 3;\n            const rect = { x, y, width, height: thickness };\n            const decorationLine = {\n                rect,\n                opacity: run.attributes.opacity,\n                color: run.attributes.strikeColor || 'black',\n                style: run.attributes.strikeStyle || 'solid',\n            };\n            line.decorationLines.push(decorationLine);\n        }\n        x += width;\n    }\n    return line;\n};\n\nconst ignoredScripts = ['Common', 'Inherited', 'Unknown'];\n/**\n * Resolves unicode script in runs, grouping equal runs together\n */\nconst scriptItemizer = () => {\n    /**\n     * @param attributedString - Attributed string\n     * @returns Attributed string\n     */\n    return (attributedString) => {\n        const { string } = attributedString;\n        let lastScript = 'Unknown';\n        let lastIndex = 0;\n        let index = 0;\n        const runs = [];\n        if (!string)\n            return empty();\n        for (let i = 0; i < string.length; i += 1) {\n            const char = string[i];\n            const codePoint = char.codePointAt(0);\n            const script = unicode.getScript(codePoint);\n            if (script !== lastScript && !ignoredScripts.includes(script)) {\n                if (lastScript !== 'Unknown') {\n                    runs.push({\n                        start: lastIndex,\n                        end: index,\n                        attributes: { script: lastScript },\n                    });\n                }\n                lastIndex = index;\n                lastScript = script;\n            }\n            index += char.length;\n        }\n        if (lastIndex < string.length) {\n            runs.push({\n                start: lastIndex,\n                end: string.length,\n                attributes: { script: lastScript },\n            });\n        }\n        const result = { string, runs: runs };\n        return result;\n    };\n};\n\nconst SOFT_HYPHEN = '\\u00ad';\nconst hyphenator = hyphen(pattern);\n/**\n * @param word\n * @returns Word parts\n */\nconst splitHyphen = (word) => {\n    return word.split(SOFT_HYPHEN);\n};\nconst cache = {};\n/**\n * @param word\n * @returns Word parts\n */\nconst getParts = (word) => {\n    const base = word.includes(SOFT_HYPHEN) ? word : hyphenator(word);\n    return splitHyphen(base);\n};\nconst wordHyphenation = () => {\n    /**\n     * @param word - Word\n     * @returns Word parts\n     */\n    return (word) => {\n        const cacheKey = `_${word}`;\n        if (isNil(word))\n            return [];\n        if (cache[cacheKey])\n            return cache[cacheKey];\n        cache[cacheKey] = getParts(word);\n        return cache[cacheKey];\n    };\n};\n\nconst IGNORED_CODE_POINTS = [173];\nconst getFontSize = (run) => run.attributes.fontSize || 12;\nconst pickFontFromFontStack = (codePoint, fontStack, lastFont) => {\n    const fontStackWithFallback = [...fontStack, lastFont];\n    for (let i = 0; i < fontStackWithFallback.length; i += 1) {\n        const font = fontStackWithFallback[i];\n        if (!IGNORED_CODE_POINTS.includes(codePoint) &&\n            font &&\n            font.hasGlyphForCodePoint &&\n            font.hasGlyphForCodePoint(codePoint)) {\n            return font;\n        }\n    }\n    return fontStack.at(-1);\n};\nconst fontSubstitution = () => ({ string, runs }) => {\n    let lastFont = null;\n    let lastFontSize = null;\n    let lastIndex = 0;\n    let index = 0;\n    const res = [];\n    for (let i = 0; i < runs.length; i += 1) {\n        const run = runs[i];\n        if (string.length === 0) {\n            res.push({\n                start: 0,\n                end: 0,\n                attributes: { font: run.attributes.font },\n            });\n            break;\n        }\n        const chars = string.slice(run.start, run.end);\n        for (let j = 0; j < chars.length; j += 1) {\n            const char = chars[j];\n            const codePoint = char.codePointAt(0);\n            // If the default font does not have a glyph and the fallback font does, we use it\n            const font = pickFontFromFontStack(codePoint, run.attributes.font, lastFont);\n            const fontSize = getFontSize(run);\n            // If anything that would impact res has changed, update it\n            if (font !== lastFont ||\n                fontSize !== lastFontSize ||\n                font.unitsPerEm !== lastFont.unitsPerEm) {\n                if (lastFont) {\n                    res.push({\n                        start: lastIndex,\n                        end: index,\n                        attributes: {\n                            font: [lastFont],\n                            scale: lastFontSize / lastFont.unitsPerEm,\n                        },\n                    });\n                }\n                lastFont = font;\n                lastFontSize = fontSize;\n                lastIndex = index;\n            }\n            index += char.length;\n        }\n    }\n    if (lastIndex < string.length) {\n        const fontSize = getFontSize(last(runs));\n        res.push({\n            start: lastIndex,\n            end: string.length,\n            attributes: {\n                font: [lastFont],\n                scale: fontSize / lastFont.unitsPerEm,\n            },\n        });\n    }\n    return { string, runs: res };\n};\n\nexport { bidiEngine as bidi, layoutEngine as default, fontSubstitution, fromFragments, justification, linebreaker, scriptItemizer, textDecoration, wordHyphenation };\n"]},"metadata":{},"sourceType":"module"}