{"ast":null,"code":"import { Struct } from './Struct.js';\n\nconst getPath = (object, pathArray) => {\n  return pathArray.reduce((prevObj, key) => prevObj && prevObj[key], object);\n};\n\nexport class VersionedStruct extends Struct {\n  constructor(type) {\n    let versions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    this.type = type;\n    this.versions = versions;\n\n    if (typeof type === 'string') {\n      this.versionPath = type.split('.');\n    }\n  }\n\n  decode(stream, parent) {\n    let length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    const res = this._setup(stream, parent, length);\n\n    if (typeof this.type === 'string') {\n      res.version = getPath(parent, this.versionPath);\n    } else {\n      res.version = this.type.decode(stream);\n    }\n\n    if (this.versions.header) {\n      this._parseFields(stream, res, this.versions.header);\n    }\n\n    const fields = this.versions[res.version];\n\n    if (fields == null) {\n      throw new Error(`Unknown version ${res.version}`);\n    }\n\n    if (fields instanceof VersionedStruct) {\n      return fields.decode(stream, parent);\n    }\n\n    this._parseFields(stream, res, fields);\n\n    if (this.process != null) {\n      this.process.call(res, stream);\n    }\n\n    return res;\n  }\n\n  size(val, parent) {\n    let includePointers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let key, type;\n\n    if (!val) {\n      throw new Error('Not a fixed size');\n    }\n\n    if (this.preEncode != null) {\n      this.preEncode.call(val);\n    }\n\n    const ctx = {\n      parent,\n      val,\n      pointerSize: 0\n    };\n    let size = 0;\n\n    if (typeof this.type !== 'string') {\n      size += this.type.size(val.version, ctx);\n    }\n\n    if (this.versions.header) {\n      for (key in this.versions.header) {\n        type = this.versions.header[key];\n\n        if (type.size != null) {\n          size += type.size(val[key], ctx);\n        }\n      }\n    }\n\n    const fields = this.versions[val.version];\n\n    if (fields == null) {\n      throw new Error(`Unknown version ${val.version}`);\n    }\n\n    for (key in fields) {\n      type = fields[key];\n\n      if (type.size != null) {\n        size += type.size(val[key], ctx);\n      }\n    }\n\n    if (includePointers) {\n      size += ctx.pointerSize;\n    }\n\n    return size;\n  }\n\n  encode(stream, val, parent) {\n    let key, type;\n\n    if (this.preEncode != null) {\n      this.preEncode.call(val, stream);\n    }\n\n    const ctx = {\n      pointers: [],\n      startOffset: stream.pos,\n      parent,\n      val,\n      pointerSize: 0\n    };\n    ctx.pointerOffset = stream.pos + this.size(val, ctx, false);\n\n    if (typeof this.type !== 'string') {\n      this.type.encode(stream, val.version);\n    }\n\n    if (this.versions.header) {\n      for (key in this.versions.header) {\n        type = this.versions.header[key];\n\n        if (type.encode != null) {\n          type.encode(stream, val[key], ctx);\n        }\n      }\n    }\n\n    const fields = this.versions[val.version];\n\n    for (key in fields) {\n      type = fields[key];\n\n      if (type.encode != null) {\n        type.encode(stream, val[key], ctx);\n      }\n    }\n\n    let i = 0;\n\n    while (i < ctx.pointers.length) {\n      const ptr = ctx.pointers[i++];\n      ptr.type.encode(stream, ptr.val, ptr.parent);\n    }\n  }\n\n}","map":{"version":3,"sources":["C:/Users/PC/Documents/PROGRAMMING/MERN/frontend/node_modules/restructure/src/VersionedStruct.js"],"names":["Struct","getPath","object","pathArray","reduce","prevObj","key","VersionedStruct","constructor","type","versions","versionPath","split","decode","stream","parent","length","res","_setup","version","header","_parseFields","fields","Error","process","call","size","val","includePointers","preEncode","ctx","pointerSize","encode","pointers","startOffset","pos","pointerOffset","i","ptr"],"mappings":"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","sourcesContent":["import {Struct} from './Struct.js';\n\nconst getPath = (object, pathArray) => {\n  return pathArray.reduce((prevObj, key) => prevObj && prevObj[key], object);\n};\n\nexport class VersionedStruct extends Struct {\n  constructor(type, versions = {}) {\n    super();\n    this.type = type;\n    this.versions = versions;\n    if (typeof type === 'string') {\n      this.versionPath = type.split('.');\n    }\n  }\n\n  decode(stream, parent, length = 0) {\n    const res = this._setup(stream, parent, length);\n\n    if (typeof this.type === 'string') {\n      res.version = getPath(parent, this.versionPath);\n    } else {\n      res.version = this.type.decode(stream);\n    }\n\n    if (this.versions.header) {\n      this._parseFields(stream, res, this.versions.header);\n    }\n\n    const fields = this.versions[res.version];\n    if ((fields == null)) {\n      throw new Error(`Unknown version ${res.version}`);\n    }\n\n    if (fields instanceof VersionedStruct) {\n      return fields.decode(stream, parent);\n    }\n\n    this._parseFields(stream, res, fields);\n\n    if (this.process != null) {\n      this.process.call(res, stream);\n    }\n    return res;\n  }\n\n  size(val, parent, includePointers = true) {\n    let key, type;\n    if (!val) {\n      throw new Error('Not a fixed size');\n    }\n\n    if (this.preEncode != null) {\n      this.preEncode.call(val);\n    }\n\n    const ctx = {\n      parent,\n      val,\n      pointerSize: 0\n    };\n\n    let size = 0;\n    if (typeof this.type !== 'string') {\n      size += this.type.size(val.version, ctx);\n    }\n\n    if (this.versions.header) {\n      for (key in this.versions.header) {\n        type = this.versions.header[key];\n        if (type.size != null) {\n          size += type.size(val[key], ctx);\n        }\n      }\n    }\n\n    const fields = this.versions[val.version];\n    if ((fields == null)) {\n      throw new Error(`Unknown version ${val.version}`);\n    }\n\n    for (key in fields) {\n      type = fields[key];\n      if (type.size != null) {\n        size += type.size(val[key], ctx);\n      }\n    }\n\n    if (includePointers) {\n      size += ctx.pointerSize;\n    }\n\n    return size;\n  }\n\n  encode(stream, val, parent) {\n    let key, type;\n    if (this.preEncode != null) {\n      this.preEncode.call(val, stream);\n    }\n\n    const ctx = {\n      pointers: [],\n      startOffset: stream.pos,\n      parent,\n      val,\n      pointerSize: 0\n    };\n\n    ctx.pointerOffset = stream.pos + this.size(val, ctx, false);\n\n    if (typeof this.type !== 'string') {\n      this.type.encode(stream, val.version);\n    }\n\n    if (this.versions.header) {\n      for (key in this.versions.header) {\n        type = this.versions.header[key];\n        if (type.encode != null) {\n          type.encode(stream, val[key], ctx);\n        }\n      }\n    }\n\n    const fields = this.versions[val.version];\n    for (key in fields) {\n      type = fields[key];\n      if (type.encode != null) {\n        type.encode(stream, val[key], ctx);\n      }\n    }\n\n    let i = 0;\n    while (i < ctx.pointers.length) {\n      const ptr = ctx.pointers[i++];\n      ptr.type.encode(stream, ptr.val, ptr.parent);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}